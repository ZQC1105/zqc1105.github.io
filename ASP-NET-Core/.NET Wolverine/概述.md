# .NET Wolverine 核心功能详解

## **1. 消息处理（核心功能）**

### **极简的消息处理器**

```csharp
// 传统方式 vs Wolverine方式
// ---------- 传统方式 ----------
public class OrderHandler : IHandler<ProcessOrder>
{
    public async Task Handle(ProcessOrder command, CancellationToken ct)
    {
        // 需要手动处理依赖、取消令牌等
    }
}

// ---------- Wolverine方式 ----------
public static class OrderHandler
{
    // 方法名可以是 Handle, Consume, 或任何名称
    public static async Task Handle(
        ProcessOrder command,
        IOrderRepository repository, // 自动注入
        CancellationToken cancellationToken) // 自动注入
    {
        await repository.ProcessOrder(command.OrderId);
    }
}
```

## **2. 集成消息总线**

### **支持多种传输方式**

```csharp
// 1. 内存队列
builder.Services.AddWolverine(opts =>
{
    opts.UseRabbitMq();      // RabbitMQ
    opts.UseAzureServiceBus(); // Azure Service Bus
    opts.UseAmazonSqs();     // AWS SQS
    opts.UsePostgresqlPersistence(); // PostgreSQL
});

// 2. 发布消息
public class OrderService
{
    public async Task CreateOrder(IMessageBus bus)
    {
        // 发布到本地队列
        await bus.PublishAsync(new ProcessOrder());

        // 发送到特定队列
        await bus.EndpointFor("orders-high-priority")
            .SendAsync(new ProcessOrder());
    }
}
```

## **3. 工作流与 Saga**

### **有状态工作流**

```csharp
public class OrderSaga : Saga
{
    public Guid OrderId { get; set; }

    // Saga状态
    public OrderStatus Status { get; set; }

    // 启动消息
    public static (OrderSaga, OrderStarted) Start(StartOrder command)
    {
        var saga = new OrderSaga { OrderId = command.OrderId };
        var message = new OrderStarted(command.OrderId);
        return (saga, message);
    }

    // 处理后续消息
    public void Handle(PaymentReceived payment)
    {
        Status = OrderStatus.Paid;
        // 自动关联到正确的Saga实例
    }
}
```

## **4. HTTP 端点集成**

### **Minimal API 风格**

```csharp
// 自动映射HTTP端点
public static class OrderEndpoints
{
    // POST /api/orders
    [WolverinePost("/api/orders")]
    public static (IResult, OrderCreated) CreateOrder(
        CreateOrderRequest request,
        IOrderService service)
    {
        var orderId = service.CreateOrder(request);
        var created = new OrderCreated(orderId);

        // 返回：HTTP响应 + 要发布的消息
        return (Results.Created($"/orders/{orderId}", orderId), created);
    }

    // 更简洁的方式
    public static OrderCreated Create(CreateOrderRequest request)
    {
        // 自动返回 201 Created
        return new OrderCreated(Guid.NewGuid());
    }
}
```

## **5. 中间件与行为**

### **AOP 风格中间件**

```csharp
public class ValidationMiddleware : ICommandMiddleware
{
    public async Task ExecuteAsync(
        ICommandContext context,
        Func<Task> next)
    {
        // 执行前验证
        if (!IsValid(context.Command))
            throw new ValidationException();

        // 执行处理器
        await next();

        // 执行后处理
        LogCompletion(context);
    }
}

// 自动应用中间件
builder.Services.AddWolverine(opts =>
{
    opts.Policies.AddMiddleware<ValidationMiddleware>();
    opts.Policies.AddMiddleware<LoggingMiddleware>();
    opts.Policies.AddMiddleware<TransactionMiddleware>();
});
```

## **6. 测试支持**

### **单元测试友好**

```csharp
[Test]
public async Task should_process_order()
{
    // 1. 安排
    var handler = new OrderHandler();
    var command = new ProcessOrder(Guid.NewGuid());

    // 2. 使用Wolverine测试工具
    var host = await Host.CreateDefaultBuilder()
        .UseWolverine()
        .StartAsync();

    // 3. 执行
    await host.InvokeAsync(command);

    // 4. 断言
    // 验证消息发送、状态变更等
}
```

## **7. 持久化与事务**

### **发件箱模式**

```csharp
public class OrderService
{
    public async Task PlaceOrder(
        PlaceOrder command,
        IDocumentSession session, // Marten集成
        IMessageBus bus)
    {
        // 1. 保存业务数据
        var order = new Order { ... };
        session.Store(order);

        // 2. 发布消息（自动加入当前事务）
        await bus.PublishAsync(new OrderPlaced(order.Id));

        // 3. 所有操作在同一个事务中提交
        // 如果保存失败，消息也不会发送
    }
}
```

## **8. 诊断和监控**

```csharp
// 结构化日志
public class OrderHandler
{
    public async Task<OrderResult> Handle(
        ProcessOrder command,
        ILogger<OrderHandler> logger,
        IMetrics metrics)
    {
        using var activity = Activity.Current?.Start();

        logger.LogInformation("Processing order {OrderId}", command.OrderId);

        metrics.Increment("orders.processed");

        return new OrderResult();
    }
}
```

## **9. 配置和策略**

```csharp
builder.Services.AddWolverine(opts =>
{
    // 并发控制
    opts.Handlers.MaximumParallelMessages(10);

    // 重试策略
    opts.Policies.OnException<TimeoutException>()
        .RetryWithCooldown(50, 100, 250);

    // 消息路由
    opts.PublishMessage<OrderCreated>()
        .ToRabbitExchange("orders")
        .UseRoutingKey("order.created");

    // 限流
    opts.Policies.UseDurableInbox();
    opts.Policies.UseDurableOutbox();
});
```

## **10. 实时通信**

```csharp
// 集成SignalR/WebSockets
public class NotificationService
{
    public async Task SendNotification(
        SendNotification command,
        IHubContext<NotificationHub> hubContext)
    {
        await hubContext.Clients
            .User(command.UserId)
            .SendAsync("ReceiveNotification", command.Message);
    }
}
```

## **主要优势总结**

1. **零样板代码** - 不需要接口、基类
2. **高性能** - 基于 Source Generator，无反射
3. **开发体验** - 优秀的 IDE 支持，编译时检查
4. **可测试性** - 设计时考虑了测试
5. **生产就绪** - 内置重试、监控、事务等
6. **渐进采用** - 可以逐步替换现有代码

## **适用场景**

- 微服务间的消息通信
- 后台任务处理
- 事件驱动架构
- CQRS 实现
- 批处理作业
- 实时通知系统

Wolverine 特别适合需要高吞吐量、低延迟的消息处理场景，它的"约定优于配置"理念大幅减少了开发人员需要编写的模板代码。
