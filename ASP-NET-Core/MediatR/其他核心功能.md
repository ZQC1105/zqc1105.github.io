**不，MediatR 远不止 IRequest 和 INotification！** 这两个接口确实是 MediatR 最核心的部分，但框架还提供了其他重要的功能和扩展点。

让我详细介绍一下 MediatR 的完整功能集：

## 1. **管道行为（Pipeline Behaviors） - 非常重要的功能！**

这是 MediatR 的杀手级特性之一，实现了 AOP（面向切面编程）。

```csharp
// 管道行为接口
public interface IPipelineBehavior<TRequest, TResponse>
{
    Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken);
}

// 实际应用示例
public class LoggingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
{
    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        // 执行前
        Log.Information("Handling {RequestType}", typeof(TRequest).Name);
        var timer = Stopwatch.StartNew();

        try
        {
            var response = await next();  // 调用下一个行为或处理器
            timer.Stop();

            // 执行后
            Log.Information("Handled {RequestType} in {Elapsed}ms",
                typeof(TRequest).Name, timer.ElapsedMilliseconds);

            return response;
        }
        catch (Exception ex)
        {
            Log.Error(ex, "Error handling {RequestType}", typeof(TRequest).Name);
            throw;
        }
    }
}

// 更多的管道行为示例
public class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken ct)
    {
        var validators = _serviceProvider.GetServices<IValidator<TRequest>>();
        foreach (var validator in validators)
        {
            var result = await validator.ValidateAsync(request, ct);
            if (!result.IsValid)
                throw new ValidationException(result.Errors);
        }

        return await next();
    }
}

public class TransactionBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken ct)
    {
        await using var transaction = await _context.Database.BeginTransactionAsync(ct);

        try
        {
            var response = await next();
            await transaction.CommitAsync(ct);
            return response;
        }
        catch
        {
            await transaction.RollbackAsync(ct);
            throw;
        }
    }
}

public class CachingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : ICacheable
{
    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken ct)
    {
        var cacheKey = request.CacheKey;
        var cached = await _cache.GetAsync<TResponse>(cacheKey, ct);

        if (cached != null)
            return cached;

        var response = await next();
        await _cache.SetAsync(cacheKey, response, TimeSpan.FromMinutes(5), ct);

        return response;
    }
}

// 注册管道行为
services.AddTransient(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));
services.AddTransient(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));
services.AddTransient(typeof(IPipelineBehavior<,>), typeof(TransactionBehavior<,>));
services.AddTransient(typeof(IPipelineBehavior<,>), typeof(CachingBehavior<,>));
```

## 2. **预处理和后处理器（Request Pre/Post Processors）**

```csharp
// 请求预处理器
public interface IRequestPreProcessor<TRequest>
{
    Task Process(TRequest request, CancellationToken cancellationToken);
}

// 请求后处理器
public interface IRequestPostProcessor<TRequest, TResponse>
{
    Task Process(TRequest request, TResponse response, CancellationToken cancellationToken);
}

// 示例：性能监控
public class PerformancePostProcessor<TRequest, TResponse> : IRequestPostProcessor<TRequest, TResponse>
{
    public Task Process(TRequest request, TResponse response, CancellationToken cancellationToken)
    {
        // 记录性能指标
        Metrics.RecordRequest(typeof(TRequest).Name, response);
        return Task.CompletedTask;
    }
}
```

## 3. **自定义发布策略**

```csharp
// 默认是并行发布所有处理器，但可以自定义
public class CustomPublisher : INotificationPublisher
{
    public async Task Publish(IEnumerable<NotificationHandlerExecutor> handlerExecutors,
        INotification notification,
        CancellationToken cancellationToken)
    {
        // 自定义发布逻辑
        foreach (var handler in handlerExecutors)
        {
            await handler.HandlerCallback(notification, cancellationToken).ConfigureAwait(false);
        }
    }
}

// 注册自定义发布者
services.AddScoped<INotificationPublisher, CustomPublisher>();
```

## 4. **流式请求（Stream Requests）- MediatR 12+**

```csharp
// 支持返回异步流
public record GetWeatherForecastsQuery(string City) : IStreamRequest<WeatherForecast>;

public class GetWeatherForecastsHandler : IStreamRequestHandler<GetWeatherForecastsQuery, WeatherForecast>
{
    public async IAsyncEnumerable<WeatherForecast> Handle(
        GetWeatherForecastsQuery request,
        CancellationToken cancellationToken)
    {
        for (int i = 0; i < 5; i++)
        {
            yield return new WeatherForecast
            {
                Date = DateTime.Now.AddDays(i),
                TemperatureC = Random.Shared.Next(-20, 55),
                Summary = "Warm"
            };

            await Task.Delay(100, cancellationToken); // 模拟延迟
        }
    }
}

// 使用流式请求
await foreach (var forecast in _mediator.CreateStream(new GetWeatherForecastsQuery("London")))
{
    Console.WriteLine($"{forecast.Date}: {forecast.TemperatureC}C");
}
```

## 5. **并行发布策略**

```csharp
// 可以配置通知是并行处理还是顺序处理
services.AddMediatR(cfg =>
{
    cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
    cfg.NotificationPublisher = new TaskWhenAllPublisher();  // 并行（默认）
    // 或
    cfg.NotificationPublisher = new ForeachAwaitPublisher(); // 顺序
});
```

## 6. **自定义处理器注册**

```csharp
// 可以自定义如何发现和注册处理器
services.AddMediatR(cfg =>
{
    // 手动注册特定类型
    cfg.RegisterHandlersFromAssemblyContaining<Startup>();

    // 或者使用自定义的发现逻辑
    cfg.AddOpenBehavior(typeof(LoggingBehavior<,>));
    cfg.AddOpenRequestPreProcessor(typeof(GenericRequestPreProcessor<>));
});
```

## 7. **丰富的配置选项**

```csharp
var services = new ServiceCollection();

services.AddMediatR(config =>
{
    // 1. 自定义处理器发现
    config.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
    config.RegisterServicesFromAssemblies(Assembly.GetEntryAssembly(), typeof(IMediator).Assembly);

    // 2. 自定义发布策略
    config.NotificationPublisher = new TaskWhenAllPublisher();
    config.NotificationPublisherType = typeof(TaskWhenAllPublisher);

    // 3. 生命周期配置
    config.Lifetime = ServiceLifetime.Scoped;

    // 4. 请求异常处理
    config.RequestExceptionActionProcessorStrategy = RequestExceptionActionProcessorStrategy.ApplyForUnhandledExceptions;

    // 5. 自定义处理器注册
    config.MediatorImplementationType = typeof(CustomMediator);
});
```

## 8. **自定义中介者实现**

```csharp
// 如果需要特殊逻辑，可以替换默认的 Mediator
public class CustomMediator : Mediator
{
    public CustomMediator(
        IServiceProvider serviceFactory,
        IEnumerable<IRequestPreProcessor<object>> requestPreProcessors,
        IEnumerable<IRequestPostProcessor<object, object>> requestPostProcessors)
        : base(serviceFactory, requestPreProcessors, requestPostProcessors)
    {
    }

    protected override Task PublishCore(
        IEnumerable<NotificationHandlerExecutor> handlerExecutors,
        INotification notification,
        CancellationToken cancellationToken)
    {
        // 自定义发布逻辑
        return base.PublishCore(handlerExecutors, notification, cancellationToken);
    }
}

// 注册自定义中介者
services.AddScoped<IMediator, CustomMediator>();
```

## 完整的功能架构图

```
MediatR 完整功能体系
├── 核心消息类型
│   ├── IRequest<TResponse>     (请求/响应 - 一对一)
│   ├── IStreamRequest<T>       (流式请求 - 新特性)
│   └── INotification          (发布/订阅 - 一对多)
│
├── 处理器接口
│   ├── IRequestHandler<T,R>    (请求处理器)
│   ├── IStreamRequestHandler<T,R> (流处理器)
│   └── INotificationHandler<T> (通知处理器)
│
├── 管道系统 (Pipeline)
│   ├── IPipelineBehavior<T,R>  (管道行为 - AOP)
│   ├── IRequestPreProcessor<T>  (预处理)
│   └── IRequestPostProcessor<T,R> (后处理)
│
├── 发布策略
│   ├── INotificationPublisher  (自定义发布)
│   └── 内置策略: 并行/顺序
│
├── 配置系统
│   ├── 处理器发现
│   ├── 生命周期管理
│   └── 异常处理策略
│
└── 扩展点
    ├── 自定义 Mediator
    ├── 自定义 ServiceFactory
    └── 自定义 Handler 调用
```

## 实际项目中的完整配置示例

```csharp
public static class MediatRConfiguration
{
    public static IServiceCollection AddCustomMediatR(this IServiceCollection services)
    {
        services.AddMediatR(cfg =>
        {
            // 1. 注册程序集
            cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());

            // 2. 配置管道行为（执行顺序很重要！）
            cfg.AddBehavior(typeof(LoggingBehavior<,>));
            cfg.AddBehavior(typeof(ValidationBehavior<,>));
            cfg.AddBehavior(typeof(AuthorizationBehavior<,>));
            cfg.AddBehavior(typeof(TransactionBehavior<,>));
            cfg.AddBehavior(typeof(CachingBehavior<,>));
            cfg.AddBehavior(typeof(MetricsBehavior<,>));

            // 3. 配置预处理
            cfg.AddRequestPreProcessor(typeof(AuditPreProcessor<>));

            // 4. 配置发布策略
            cfg.NotificationPublisher = new CustomNotificationPublisher();

            // 5. 自定义生命周期
            cfg.Lifetime = ServiceLifetime.Scoped;
        });

        // 6. 注册FluentValidation
        services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());

        return services;
    }
}

// 在实际应用中
public class OrderProcessingPipeline
{
    public async Task<OrderResult> ProcessOrder(OrderCommand command)
    {
        // 经过完整的管道处理：
        // 1. AuditPreProcessor → 记录开始
        // 2. LoggingBehavior → 记录日志
        // 3. ValidationBehavior → 验证
        // 4. AuthorizationBehavior → 权限检查
        // 5. TransactionBehavior → 事务管理
        // 6. Handler → 业务逻辑
        // 7. CachingBehavior → 缓存结果
        // 8. MetricsBehavior → 记录指标
        // 9. RequestPostProcessor → 后处理

        return await _mediator.Send(command);
    }
}
```

## 总结

**MediatR 远不止 IRequest 和 INotification！** 它的核心是一个**完整的消息处理框架**，包含：

1. **核心消息类型**（IRequest, INotification, IStreamRequest）
2. **强大的管道系统**（Pipeline Behaviors - 这才是真正强大的地方）
3. **预处理/后处理机制**
4. **灵活的发布策略**
5. **流式处理支持**
6. **丰富的配置选项**
7. **完整的扩展点**

**真正让 MediatR 强大的不是消息本身，而是围绕消息构建的完整管道生态系统！** 管道行为让你可以在不修改业务代码的情况下，轻松添加日志、验证、事务、缓存、监控等横切关注点，这是 MediatR 最大的价值所在。
