# **MediatR 管道行为 vs ASP.NET Core 中间件：深度对比**

这两者都是基于管道模式的设计，但在**层级、职责和使用场景**上有本质区别。让我详细对比一下：

## 1. **架构层级对比**

### ASP.NET Core 中间件（HTTP 层面）

```
HTTP Request
    ↓
ASP.NET Core 中间件管道
    ├── Exception Handling Middleware   (异常处理)
    ├── Static Files Middleware         (静态文件)
    ├── Authentication Middleware       (认证)
    ├── Authorization Middleware        (授权)
    ├── Routing Middleware              (路由)
    ├── Endpoint Middleware             (端点)
    └── ...自定义中间件
```

### MediatR 管道行为（业务层面）

```
Endpoint (Controller/API)
    ↓
业务命令/查询 (IRequest/INotification)
    ↓
MediatR 管道行为
    ├── LoggingBehavior         (日志)
    ├── ValidationBehavior      (验证)
    ├── AuthorizationBehavior   (授权)
    ├── TransactionBehavior     (事务)
    ├── CachingBehavior         (缓存)
    └── ...业务处理器 (Handler)
```

## 2. **核心区别对比表**

| 维度         | ASP.NET Core 中间件         | MediatR 管道行为                |
| ------------ | --------------------------- | ------------------------------- |
| **作用层级** | HTTP 请求/响应层面          | 业务逻辑层面                    |
| **处理对象** | `HttpContext`               | `IRequest<T>` / `INotification` |
| **生命周期** | 请求级别 (Singleton/Scoped) | 请求级别 (通常 Scoped)          |
| **执行时机** | HTTP 请求到达时             | 业务命令/查询执行时             |
| **依赖注入** | 构造函数注入                | 构造函数注入                    |
| **管道顺序** | 注册顺序执行                | 注册顺序执行                    |
| **异常处理** | 中间件链处理                | 管道行为内处理                  |
| **返回结果** | 修改 `HttpContext.Response` | 返回 `TResponse`                |

## 3. **代码实现对比**

### ASP.NET Core 中间件

```csharp
// 中间件接口
public interface IMiddleware
{
    Task InvokeAsync(HttpContext context, RequestDelegate next);
}

// 自定义中间件示例
public class CustomMiddleware : IMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        // 1. 请求处理前
        Log.Information($"开始处理请求: {context.Request.Path}");
        var stopwatch = Stopwatch.StartNew();

        try
        {
            // 2. 调用下一个中间件
            await next(context);
            stopwatch.Stop();

            // 3. 响应处理后
            Log.Information($"请求处理完成: {context.Request.Path}, " +
                           $"状态码: {context.Response.StatusCode}, " +
                           $"耗时: {stopwatch.ElapsedMilliseconds}ms");
        }
        catch (Exception ex)
        {
            // 4. 异常处理
            Log.Error(ex, $"请求处理失败: {context.Request.Path}");

            context.Response.StatusCode = 500;
            await context.Response.WriteAsync("Internal Server Error");

            throw;
        }
    }
}

// 注册中间件
public void Configure(IApplicationBuilder app)
{
    app.UseMiddleware<CustomMiddleware>();
    app.UseAuthentication();
    app.UseAuthorization();
    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
    });
}
```

### MediatR 管道行为

```csharp
// 管道行为接口
public interface IPipelineBehavior<TRequest, TResponse>
{
    Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken);
}

// 自定义管道行为示例
public class CustomPipelineBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
{
    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        // 1. 处理前
        Log.Information($"开始处理业务请求: {typeof(TRequest).Name}");
        var stopwatch = Stopwatch.StartNew();

        try
        {
            // 2. 调用下一个行为或处理器
            var response = await next();
            stopwatch.Stop();

            // 3. 处理后
            Log.Information($"业务处理完成: {typeof(TRequest).Name}, " +
                           $"耗时: {stopwatch.ElapsedMilliseconds}ms");

            return response;
        }
        catch (Exception ex)
        {
            // 4. 异常处理
            stopwatch.Stop();
            Log.Error(ex, $"业务处理失败: {typeof(TRequest).Name}");
            throw;
        }
    }
}

// 注册管道行为
services.AddTransient(typeof(IPipelineBehavior<,>), typeof(CustomPipelineBehavior<,>));
```

## 4. **职责分离对比**

### **ASP.NET Core 中间件的职责**：

```csharp
public class HttpLevelMiddleware
{
    // 处理HTTP层面的事务
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        // 1. HTTP请求/响应处理
        context.Request.EnableBuffering();  // 允许重复读取请求体

        // 2. 跨域处理
        context.Response.Headers.Add("Access-Control-Allow-Origin", "*");

        // 3. 压缩处理
        if (context.Request.Headers["Accept-Encoding"].ToString().Contains("gzip"))
        {
            context.Response.Body = new GZipStream(context.Response.Body, CompressionLevel.Fastest);
        }

        // 4. 调用下一个中间件
        await next(context);

        // 5. HTTP响应后处理
        await context.Response.Body.FlushAsync();
    }
}
```

### **MediatR 管道行为的职责**：

```csharp
public class BusinessLevelPipelineBehavior<TRequest, TResponse>
    : IPipelineBehavior<TRequest, TResponse>
{
    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        // 1. 业务验证
        var validator = GetValidator<TRequest>();
        if (validator != null)
        {
            var result = await validator.ValidateAsync(request, cancellationToken);
            if (!result.IsValid)
                throw new ValidationException(result.Errors);
        }

        // 2. 业务授权
        if (request is ISecuredRequest securedRequest)
        {
            var user = _currentUserService.GetCurrentUser();
            if (!await _authorizationService.AuthorizeAsync(user, securedRequest))
                throw new UnauthorizedAccessException();
        }

        // 3. 业务事务
        await using var transaction = await _dbContext.Database.BeginTransactionAsync(cancellationToken);
        try
        {
            var response = await next();
            await _dbContext.SaveChangesAsync(cancellationToken);
            await transaction.CommitAsync(cancellationToken);
            return response;
        }
        catch
        {
            await transaction.RollbackAsync(cancellationToken);
            throw;
        }

        // 4. 业务缓存
        if (request is ICacheable cacheable)
        {
            var cacheKey = cacheable.GetCacheKey();
            await _cache.SetAsync(cacheKey, response, cancellationToken);
        }
    }
}
```

## 5. **实际项目中的协作关系**

```csharp
// 完整的请求处理流程
public class CompleteRequestFlow
{
    /*
    完整的请求处理链条：

    HTTP Request
        ↓
    ASP.NET Core 中间件管道（HTTP层面）
        ├── 1. 异常处理中间件
        ├── 2. HTTPS重定向中间件
        ├── 3. 静态文件中间件
        ├── 4. 路由中间件
        ├── 5. 认证中间件
        ├── 6. 授权中间件
        └── 7. 端点中间件 → 进入Controller

    Controller
        ↓
    MediatR 发送命令/查询
        ↓
    MediatR 管道行为（业务层面）
        ├── 1. 日志行为
        ├── 2. 验证行为
        ├── 3. 授权行为（业务授权）
        ├── 4. 事务行为
        ├── 5. 缓存行为
        └── 6. 业务处理器

    返回业务结果
        ↓
    Controller 返回 HTTP 响应
        ↓
    ASP.NET Core 中间件管道（响应层面）
        └── 响应压缩、CORS等处理
    */
}

// 实际代码示例
[ApiController]
[Route("api/orders")]
public class OrdersController : ControllerBase
{
    private readonly IMediator _mediator;

    [HttpPost]
    [Authorize(Roles = "Customer")]  // ← ASP.NET Core 中间件处理（HTTP授权）
    public async Task<IActionResult> CreateOrder([FromBody] CreateOrderRequest request)
    {
        // Controller 收到请求时，已经通过了：
        // 1. 异常处理中间件
        // 2. 认证中间件
        // 3. 授权中间件（检查了[Authorize]）

        var command = new CreateOrderCommand(
            request.ProductId,
            request.Quantity,
            User.Identity.Name  // 从HTTP上下文中获取用户
        );

        // 发送到 MediatR，进入业务管道
        var result = await _mediator.Send(command);

        // 返回 HTTP 响应
        return Ok(result);
    }
}

// MediatR 管道继续处理业务逻辑
public class CreateOrderCommandHandler : IRequestHandler<CreateOrderCommand, OrderResult>
{
    public async Task<OrderResult> Handle(CreateOrderCommand command, CancellationToken ct)
    {
        // 执行到这里时，已经通过了：
        // 1. LoggingBehavior（记录开始）
        // 2. ValidationBehavior（验证命令数据）
        // 3. AuthorizationBehavior（业务层面的额外授权检查）
        // 4. TransactionBehavior（开启事务）

        // 执行核心业务逻辑
        var order = await CreateOrderAsync(command, ct);

        // 继续通过管道：
        // 5. 业务逻辑执行后，TransactionBehavior 提交事务
        // 6. LoggingBehavior 记录完成

        return new OrderResult(order.Id);
    }
}
```

## 6. **关键区别总结**

### **关注点不同**：

```csharp
// ASP.NET Core 中间件关注：
public class HttpConcerns
{
    // 1. HTTP协议处理
    public void HandleHttpProtocol()
    {
        // 请求/响应格式、状态码、头信息
        // CORS、HTTPS重定向、压缩
        // 静态文件服务、WebSocket
    }

    // 2. 基础设施
    public void HandleInfrastructure()
    {
        // 请求路由、端点选择
        // 会话管理、本地化
        // 响应缓存、输出缓存
    }

    // 3. 安全
    public void HandleSecurity()
    {
        // 认证（Authentication）
        // 授权（Authorization - 基于角色/策略）
        // CSRF防护、速率限制
    }
}

// MediatR 管道行为关注：
public class BusinessConcerns
{
    // 1. 业务逻辑处理
    public void HandleBusinessLogic()
    {
        // 业务验证（数据规则）
        // 业务授权（业务规则权限）
        // 业务事务（一致性）
    }

    // 2. 业务监控
    public void HandleBusinessMonitoring()
    {
        // 业务日志（业务操作记录）
        // 性能监控（业务方法耗时）
        // 业务指标（成功/失败统计）
    }

    // 3. 业务优化
    public void HandleBusinessOptimization()
    {
        // 业务缓存（业务数据缓存）
        // 重试机制（业务失败重试）
        // 业务降级（熔断机制）
    }
}
```

### **执行顺序示例**：

```csharp
// 一个HTTP请求的完整旅程
public class RequestJourney
{
    public async Task<IActionResult> ProcessRequest()
    {
        /*
        执行顺序：

        阶段1: HTTP管道 (ASP.NET Core 中间件)
        --------------------------------------------
        1. UseExceptionHandler()         // 全局异常处理
        2. UseHsts()                    // HSTS安全策略
        3. UseHttpsRedirection()        // HTTPS重定向
        4. UseStaticFiles()             // 静态文件
        5. UseRouting()                 // 路由
        6. UseAuthentication()          // 认证
        7. UseAuthorization()           // 授权
        8. UseEndpoints()               // 端点

        阶段2: Controller处理
        --------------------------------------------
        9. Controller.OnActionExecuting()
        10. Controller.ActionMethod()
        11. Controller.OnActionExecuted()

        阶段3: 业务管道 (MediatR 管道行为)
        --------------------------------------------
        12. LoggingBehavior (开始)
        13. ValidationBehavior
        14. AuthorizationBehavior (业务授权)
        15. TransactionBehavior
        16. CachingBehavior
        17. Actual Business Handler     // 真正执行业务逻辑
        18. CachingBehavior (缓存结果)
        19. TransactionBehavior (提交)
        20. LoggingBehavior (完成)

        阶段4: 返回HTTP响应
        --------------------------------------------
        21. Controller 格式化响应
        22. 反向经过ASP.NET Core中间件
        23. 返回给客户端
        */
    }
}
```

## 7. **如何选择合适的管道**

### **使用 ASP.NET Core 中间件当**：

```csharp
// 场景1：处理HTTP协议相关
app.UseHttpsRedirection();
app.UseCors("AllowAll");
app.UseResponseCompression();

// 场景2：全局异常处理
app.UseExceptionHandler(errorApp =>
{
    errorApp.Run(async context =>
    {
        context.Response.StatusCode = 500;
        await context.Response.WriteAsync("Something went wrong!");
    });
});

// 场景3：认证/授权（身份层面）
app.UseAuthentication();   // 确认用户是谁
app.UseAuthorization();    // 确认用户能做什么（基于角色/策略）

// 场景4：请求/响应转换
app.Use(async (context, next) =>
{
    // 修改请求头
    context.Request.Headers["X-Custom-Header"] = "Value";

    await next();

    // 修改响应
    context.Response.Headers["X-Response-Time"] = DateTime.UtcNow.ToString();
});
```

### **使用 MediatR 管道行为当**：

```csharp
// 场景1：业务验证（数据规则）
public class BusinessValidationBehavior<TRequest, TResponse>
    : IPipelineBehavior<TRequest, TResponse>
{
    // 验证业务规则，而不是HTTP格式
    // 例如：库存是否足够、用户信用是否良好等
}

// 场景2：业务事务（一致性保证）
public class BusinessTransactionBehavior<TRequest, TResponse>
    : IPipelineBehavior<TRequest, TResponse>
{
    // 业务事务管理，确保业务操作的一致性
}

// 场景3：业务缓存（业务数据）
public class BusinessCachingBehavior<TRequest, TResponse>
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : ICacheable
{
    // 缓存业务查询结果，提高性能
}

// 场景4：业务监控
public class BusinessMetricsBehavior<TRequest, TResponse>
    : IPipelineBehavior<TRequest, TResponse>
{
    // 记录业务指标：成功率、响应时间、业务异常
}
```

## 8. **常见误区**

### **误区 1：在中间件中处理业务逻辑**

```csharp
// ❌ 错误做法：在中间件中处理业务
public class BadMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        // 错误：在HTTP中间件中直接操作数据库
        if (context.Request.Path.StartsWithSegments("/api/orders"))
        {
            var orderService = context.RequestServices.GetRequiredService<IOrderService>();
            // 直接调用业务服务 → 混淆了HTTP和业务层
            await orderService.ProcessOrderAsync();
        }

        await next(context);
    }
}

// ✅ 正确做法：中间件只处理HTTP层面
public class GoodMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        // 只处理HTTP层面的事务
        Log.Information($"HTTP请求: {context.Request.Method} {context.Request.Path}");

        // 将业务逻辑交给Controller和MediatR
        await next(context);

        Log.Information($"HTTP响应: {context.Response.StatusCode}");
    }
}
```

### **误区 2：在管道行为中处理 HTTP 事务**

```csharp
// ❌ 错误做法：在管道行为中处理HTTP
public class BadPipelineBehavior<TRequest, TResponse>
    : IPipelineBehavior<TRequest, TResponse>
{
    public async Task<TResponse> Handle(TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken ct)
    {
        // 错误：试图访问HttpContext
        var httpContext = _httpContextAccessor.HttpContext;
        if (httpContext != null)
        {
            // 修改HTTP响应头 → 应该在中间件中做
            httpContext.Response.Headers.Add("X-Custom", "Value");
        }

        return await next();
    }
}

// ✅ 正确做法：管道行为只关注业务
public class GoodPipelineBehavior<TRequest, TResponse>
    : IPipelineBehavior<TRequest, TResponse>
{
    public async Task<TResponse> Handle(TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken ct)
    {
        // 只处理业务层面的事务
        Log.Information($"业务请求: {typeof(TRequest).Name}");

        var response = await next();

        Log.Information($"业务完成: {typeof(TRequest).Name}");

        return response;
    }
}
```

## **总结**

**ASP.NET Core 中间件**和**MediatR 管道行为**是**不同层面的管道设计**：

| 方面         | ASP.NET Core 中间件                        | MediatR 管道行为                         |
| ------------ | ------------------------------------------ | ---------------------------------------- |
| **层次**     | **基础设施层**                             | **业务应用层**                           |
| **职责**     | HTTP 协议处理、路由、安全                  | 业务逻辑处理、验证、事务                 |
| **类比**     | **高速公路系统**（道路、收费站、交通规则） | **物流公司内部流程**（接单、打包、运输） |
| **关注点**   | 如何接收请求、如何返回响应                 | 如何处理业务、如何保证一致性             |
| **变化频率** | 相对稳定（协议标准）                       | 经常变化（业务需求）                     |

**简单记忆**：

- **中间件**处理 **HTTP 怎么来怎么回** 的问题
- **管道行为**处理 **业务怎么做** 的问题

两者可以完美协作，中间件确保 HTTP 请求正确到达业务层，管道行为确保业务逻辑正确执行，共同构建一个清晰、可维护的应用架构。
