跨站脚本（XSS）和跨站请求伪造（CSRF）是两种完全不同的 Web 攻击方式，经常被初学者混为一谈。下面用 1 张表 + 1 张图帮你秒懂区别，并给出 ASP.NET Core 下的防护速查表。

---

### 1 XSS vs CSRF 一眼对比

| 维度 | XSS（跨站脚本） | CSRF（跨站请求伪造） |
|---|---|---|
| 核心目标 | **让浏览器执行攻击者写的 JavaScript** | **让浏览器冒充用户身份调用接口** |
| 是否需要 JS 执行 | ✅ 必须执行恶意脚本 | ❌ 不需要脚本，只要自动提交表单 / 图片 |
| 盗取对象 | Cookie、Token、页面内容、用户输入 | 用户会话（Cookie）+ 权限 |
| 攻击载体 | 用户输入未转义 → 页面回显 | 第三方站点自动提交表单 / fetch |
| 防御要点 | **输出转义** + **CSP** + **HttpOnly** | **Anti-Forgery Token** + **SameSite Cookie** |
| ASP.NET Core 内置 | `System.Text.Encodings.Web` + CSP 中间件 | `IAntiforgery` + `[ValidateAntiForgeryToken]` |

---

### 2 XSS 在 ASP.NET Core 的 3 行防护

1. **Razor 默认自动转义**  
   只要用 `@Model.Property` 输出，就会转成 `&lt; &gt; &amp;` 等实体，杜绝 99% 反射型 XSS。

2. **富文本场景**  
   需要渲染 HTML 时，先跑白名单过滤库：  
   ```bash
   dotnet add package Ganss.XSS
   ```
   ```csharp
   var sanitizer = new Ganss.XSS.HtmlSanitizer();
   var clean = sanitizer.Sanitize(userHtml);
   ```

3. **响应头加 CSP**  
   ```csharp
   app.Use(async (ctx, next) =>
   {
       ctx.Response.Headers.Append("Content-Security-Policy",
           "default-src 'self'; script-src 'self'; object-src 'none';");
       await next();
   });
   ```
   即使被注入 `<script>`，浏览器也会拦截。

---

### 3 一句话总结

- **XSS = 服务器“轻信”用户输入，浏览器执行了恶意脚本。**  
- **CSRF = 服务器“轻信”浏览器请求，用户身份被冒用。**

把输出转义 + CSP 当成 XSS 疫苗；把 Anti-Forgery Token + SameSite 当成 CSRF 疫苗，两种针都打了，站点才算“双保险”。

下面给一份“**复制即可用**”的 ASP.NET Core 最小清单，让你 3 分钟把“输出转义 + Anti-Forgery Token”同时上线。  
（假设 .NET 8 + MVC，老版本把 `Program.cs` 换成 `Startup.cs` 写法即可）

---

### 1. 输出转义（防 XSS）

| 场景 | 做法 | 是否已安全 |
|---|---|---|
| 普通文本 | `@Model.UserName` | ✅ Razor 默认转义 |
| 富文本/HTML | 先过滤再 `@Html.Raw()` | 需手动调用白名单 |
| JSON 响应 | `System.Text.Json` 默认转义 | ✅ |
| JavaScript 变量 | `@Json.Serialize(Model)` | ✅ 自动转义 |

**富文本过滤代码（一次性）**  
```bash
dotnet add package Ganss.XSS
```

```csharp
public static class HtmlSanitizerHelper
{
    private static readonly HtmlSanitizer _sanitizer = new();
    public static string SafeHtml(string raw) => _sanitizer.Sanitize(raw);
}
```

**控制器**  
```csharp
post.Content = HtmlSanitizerHelper.SafeHtml(model.Content);
```

**响应头再加 CSP（一次性）**  
```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.Use(async (c, n) =>
{
    c.Response.Headers.Append("Content-Security-Policy",
                              "default-src 'self'; script-src 'self'; object-src 'none';");
    await n();
});
```

---

### 2. Anti-Forgery Token（防 CSRF）

**视图**  
```html
<form method="post" asp-action="Create">
    <!-- Tag Helper 自动输出 Token -->
    <input asp-for="Title" />
    <button type="submit">保存</button>
</form>
```

**或手动 AJAX**  
```html
@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery af
<meta name="xsrf-token" content="@af.GetAndStoreTokens(Context).RequestToken" />

<script>
fetch('/post/create', {
    method: 'POST',
    headers: {
        'RequestVerificationToken': 
            document.querySelector('meta[name="xsrf-token"]').content,
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({title: 'hello'})
});
</script>
```

**控制器**  
```csharp
[HttpPost]
[ValidateAntiForgeryToken]   // ← 必加
public IActionResult Create(PostVm vm) { ... }
```

---

### 3. 一键验证是否生效

| 测试项 | 操作 | 期望结果 |
|---|---|---|
| XSS | 在输入框写 `<script>alert(1)</script>` 并回显 | 页面出现转义后的 `&lt;script&gt;` 或干净标签 |
| CSRF | 把表单复制到本地 html，去掉 Token 直接提交 | 400 / 403 验证失败 |

---

打完收工：  
**“输出转义”让浏览器把用户输入当纯文本；“Anti-Forgery Token”让服务器把非法请求直接拒掉。**  
两句话，两套防护，同时上线即可。

**JSON 响应本身** 就已经 **自带转义**（`System.Text.Json` / `Newtonsoft.Json` 都会把 `" < > &` 等转义成 `\u0022 \u003c \u003e \u0026`），**不会触发 XSS**——**前提是你别“手欠”把 JSON 嵌入到 HTML 页面或 JS 字符串时拆掉转义**。

---

### 1. 纯 JSON 接口 → 默认安全

```csharp
[HttpGet("/api/user/{id}")]
public IActionResult GetUser(int id)
{
    var user = _repo.Get(id);
    return Ok(user);          // Content-Type: application/json
}
```

- 浏览器按 JSON 解析，**不会执行其中任何 HTML/JS**。
- 即使 `user.Name = "<script>alert(1)</script>"`，返回也是：
  ```json
  {"name":"\u003Cscript\u003Ealert(1)\u003C/script\u003E"}
  ```

---

### 2. 唯一会翻车的情况：把 JSON 塞进 HTML

| 错误做法 | 后果 |
|---|---|
| 后端 `return Content(json, "text/html")` | 浏览器按 HTML 解析，直接执行 `<script>` |
| Razor 里 `<script>var data = @Html.Raw(Json.Serialize(obj))</script>` | 若 `obj` 里出现 `</script>` 即可提前闭合脚本块，造成注入 |
| 手动拼接 `return Content($"callback({json})", "application/javascript")` | JSONP 模式，必须自己做 JS 字符串转义 |

---

### 3. 最小安全 checklist（JSON 接口）

✅ **返回 JSON 用框架助手**  
```csharp
return Ok(obj);                // 或 Results.Json(obj)  in Minimal API
```

✅ **Content-Type 保持** `application/json`  
（框架自动设置，别手动改成 `text/html`）

✅ **不要把 JSON 当 HTML 返回**  
如果必须“内嵌”到 Razor 页面，用：
```html
<script>
  var data = @Json.Serialize(obj);   // 自带 JS 转义
</script>
```

---

### 4. 结论

- **只要接口返回的是标准 JSON 并且 Content-Type 正确**，你就**无需再做“输出转义”**；
- **XSS 风险只出现在“把 JSON 当 HTML/JS 字符串拼接”时**——别让这种情况发生即可。