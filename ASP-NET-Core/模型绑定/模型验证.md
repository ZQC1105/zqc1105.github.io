
# [介绍](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/validation?view=aspnetcore-9.0)

关于 ModelState.IsValid 以及它在 ASP.NET Core MVC 中如何与数据注释（如 [Required]、[EmailAddress]）配合进行模型验证，微软官方文档提供了非常详细的说明。
✅ 官方文档地址（推荐）：

🔗 [ASP.NET Core 中的模型验证](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/validation)
URL:
https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/validation

📚 该页面涵盖的核心内容包括：

主题 说明

---

🔹 验证属性（如 [Required], [EmailAddress]） 如何使用数据注释进行声明式验证。
🔹 ModelState.IsValid 如何在控制器中使用它判断模型是否有效。
🔹 验证错误处理 当验证失败时如何返回视图或返回错误 JSON。
🔹 客户端验证 如何启用基于 jQuery 的客户端验证（无刷新校验）。
🔹 自定义验证 创建自定义验证属性或实现 IValidatableObject。
🔹 复杂类型验证 验证嵌套对象、集合等。

🧪 示例代码（来自文档）

```csharp
[HttpPost]
public IActionResult Create(Product product)
{
if (ModelState.IsValid)
{
// 模型验证通过，保存数据
\_context.Products.Add(product);
\_context.SaveChanges();
return RedirectToAction("Index");
}

// 验证失败，返回视图并显示错误
return View(product);
}
```
你可以在上述文档中找到这个模式的完整解释。

标记帮助程序中的验证显示（asp-validation-for）：
https://learn.microsoft.com/zh-cn/aspnet/core/mvc/views/working-with-forms


一句话结论：

> ✅ **优先用模型验证（属性注解、FluentValidation 等）把“语法/格式级”问题拦在门外；**  
> ✅ **进入方法后再做“业务语义级”检查（重复、权限、余额、库存…）。**  
> 两者不是二选一，而是**分层把关**：**模型验证越早越好，业务验证越集中越清晰**。

------------------------------------------------
1. 模型验证该做的事（早做、自动做）
| 典型例子 | 是否适合模型验证 | 原因 |
|---|---|---|
| 邮箱格式、手机号格式、身份证号正则 | ✅ | 与业务无关，可复用，越早失败越省资源 |
| 数字范围（年龄 0-120）、字符串长度 | ✅ | 纯粹输入合法性，可声明式写一次 |
| 密码、确认密码一致性 | ✅ | 可用 `IValidatableObject` 或 FluentValidation 一次解决 |
| 日期格式、枚举值在范围内 | ✅ | 框架自动帮你返回 400，省得写 `if` |

→ 这些在**模型绑定阶段**就完成，ASP.NET Core 会自动返回 `400 BadRequest` + `ModelState`，**前后端都能复用**，**控制器方法体里看不到任何 `if`**。

------------------------------------------------
2. 方法体里再做的事（晚做、显式做）
| 典型例子 | 是否适合模型验证 | 推荐做法 |
|---|---|---|
| 注册时“用户名已存在” | ❌ | 属于业务规则，需要查数据库，模型验证阶段做会**污染数据层**或**性能差** |
| 下单时“库存不足” | ❌ | 依赖实时库存，需要事务/分布式锁，模型验证阶段无法保证一致性 |
| 转账时“余额足够” | ❌ | 需要一致性读，模型验证阶段做会** race condition** |
| 权限/角色校验 | ❌ | 依赖当前登录人，模型验证拿不到 `ICurrentUser` |

→ 这些放在**服务层/命令处理器**里显式检查，失败时抛自定义业务异常（如 `DomainException`），再由**异常中间件**统一转 409/422/403 等语义码。

------------------------------------------------
3. 实战分层代码模板

```csharp
[ApiController]
[Route("[controller]")]
public class OrderController : ControllerBase
{
    private readonly IOrderService _orderService;

    [HttpPost]
    public async Task<IActionResult> CreateOrder(CreateOrderDto dto)
    {
        // 1. 框架已帮你完成模型验证（属性、FluentValidation）
        if (!ModelState.IsValid)           // 实际这一行可省，[ApiController] 会自动 400
            return ValidationProblem(ModelState);

        // 2. 业务语义验证，交给服务层
        var result = await _orderService.CreateOrderAsync(dto);
        return result.Match<IActionResult>(
            succ => Ok(succ),
            fail => fail.Code switch
            {
                BusinessError.InsufficientStock => Conflict(new { code = "STOCK_SHORT", message = fail.Message }),
                BusinessError.ProductOffline    => BadRequest(new { code = "PRODUCT_OFFLINE", message = fail.Message }),
                _                               => Problem(fail.Message, statusCode: 500)
            });
    }
}
```

------------------------------------------------
4. 判断口诀

| 问题 | 答案 |
|---|---|
| 这条规则**不依赖数据库、不依赖外部状态**？ | ✅ 模型验证 |
| 这条规则**需要读库、需要调用远程服务、需要当前用户上下文**？ | ❌ 模型验证，放方法里 |
| 这条规则**想在 Swagger/OpenAPI 里自动生成文档**？ | ✅ 模型验证 |
| 这条规则**可能随业务频繁变化**？ | ❌ 模型验证，放服务层更灵活 |

------------------------------------------------
5. 小结

1. **模型验证 = 语法过滤器**，越早越好，最好让请求进不到你的业务代码。  
2. **业务验证 = 语义决策器**，必须显式写，集中写，方便单测、事务、审计。  
3. 两者结合，控制器方法体才能保持**“瘦”**：只有一行调度，看不到 `if (!ModelState)` 也看不到 `if (user == null)`。
