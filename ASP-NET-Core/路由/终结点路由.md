标题栏：地址一模一样，为何一会404、一会400、一会200？——“模板→约束→绑定”三步踩点图解

一句话拆成三步，看完就明白“为什么地址一样却可能 404、400 或 200”。

---

1. 模板匹配 —— 先看“形状”对不对  
- 把请求路径 `/api/test2/int/xyz` 按字面量+占位符拆成令牌。  
- 只要有一个字符对不上字面量（比如把 `int` 写成 `integer`），直接 404，后续两步都不执行。  
- 占位符 `{id}` 只管“占坑”，此时不验证内容，连 `xyz` 也能过。

---

2. 内联约束 —— 再验“类型”合不合法  
- 模板里写了 `{id:int}`，框架就用 int 路由约束 检查刚才占坑拿到的字符串。  
- 能转成 `int` → 通过，进下一步；转失败 → 立即 404，动作方法都不会被调用。  
- 常见内联约束还有 `{min:guid}`、`{price:range(1,100)}`、`{name:alpha}` 等，路由阶段就拒掉，比模型绑定更早。

---

3. 模型绑定 —— 最后把“字符串”变成“CLR 对象”  
- 只要模板和约束都过了，路由表就选定目标方法；接下来把占位符的值按参数名/类型再加工。  
- 示例：`int id` 会把 `"3"` → `3`；若方法签名为 `DateTime dt`，框架就调 `DateTime.Parse`。  
- 转换失败 → 不再改路由结果，而是记一条模型状态错误，最终 400 BadRequest（返回 `ProblemDetails` JSON）。

---

一张图看懂三件套先后关系

```
请求路径
   │
   ▼
1. 模板匹配 ──形状→ 404（找不到路由）
   │ 通过
   ▼
2. 内联约束 ──类型→ 404（约束不符）
   │ 通过
   ▼
3. 模型绑定 ──转换→ 400（绑定失败） / 200（成功进方法）
```

记住：  
- 想“提前拒”用 内联约束（404）；  
- 想“进来再判”靠 模型绑定（400）；  
- 模板只决定“有没有这条路”，不管值合不合法。

属于 **ASP.NET Core 路由（Routing）** 子系统，更精确地说，是 **终结点路由（Endpoint Routing）** 管道里 **“模板→约束→绑定”** 三连击：

1. 模板匹配 —— `EndpointRoutingMiddleware` 根据 `RoutePattern` 做字面量令牌比对（404）。  
2. 内联约束 —— `RouteConstraint` 实现（如 `IntRouteConstraint`）在选定终结点前做类型预检（还是404）。  
3. 模型绑定 —— `ModelBinding` 系统（由 `ControllerActionInvoker` 调用）把字符串值转成 CLR 类型，失败时写 `ModelState` 并返回 400。

所以，这段流程横跨了  
**Microsoft.AspNetCore.Routing**（模板+约束）  
和  
**Microsoft.AspNetCore.Mvc.ModelBinding**（绑定）  
两个组件，但统一在 **终结点路由** 这一层面对外暴露行为。
