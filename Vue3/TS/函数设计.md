在 TypeScript 中，以对象形式接收可选参数并为每个属性提供默认值是一种非常常见且优雅的函数设计模式。它兼顾了调用灵活性、可读性与类型安全。以下是完整总结：

✅ 核心写法（推荐模板）

ts
function myFunction(
requiredParam: string,
{
optionA = 'defaultA',
optionB = 42,
optionC = false
}: {
optionA?: string;
optionB?: number;
optionC?: boolean;
} = {}
): void {
// 函数体
}

🔍 关键组成部分解析

部分 说明
------ ------
{ ... } 对第二个参数进行对象解构
optionX = defaultValue 为每个属性设置默认值（若未传或为 undefined）
: { ... } 显式声明该对象参数的类型结构（确保类型安全）
= {} 为整个对象参数设置默认空对象，使其完全可选

✅ 优势

1. 调用灵活
可省略整个配置对象
可只传部分选项（其余用默认值）
ts
myFunction('hello');
myFunction('hello', { optionC: true });
myFunction('hello', { optionA: 'custom', optionB: 100 });

2. 语义清晰
命名参数比位置参数更易读，尤其当选项较多时。

3. 类型安全
TypeScript 会检查：
是否传入了非法属性（多余字段会报错，除非开启 exactOptionalPropertyTypes 或使用 Record<string, any>）
属性类型是否匹配
必填项是否缺失（本例中无必填配置项，但可通过去掉 ? 实现）

4. 易于扩展
新增选项不会破坏现有调用代码。

🛠️ 进阶技巧
1. 某些配置项设为必填
去掉 ? 即可：
ts
{
requiredOption: string; // 必填
optionalOption?: number; // 可选
}
⚠️ 注意：即使对象整体有默认值 {}，如果内部有必填属性，调用时仍需提供它，否则会报错。
2. 使用接口提升可读性
ts
interface MyOptions {
optionA?: string;
optionB?: number;
optionC?: boolean;
}

function myFunction(
requiredParam: string,
{ optionA = 'default', optionB = 0, optionC = false }: MyOptions = {}
) { / ... / }
3. 允许额外属性（谨慎使用）
ts
{
optionA?: string;
[key: string]: any; // 允许其他任意属性
}
通常不推荐，会削弱类型安全性。

⚠️ 常见陷阱
不要忘记 = {}
如果漏写，调用时必须传入一个对象（即使为空），失去“可选”意义。
避免在解构中访问自身（如 computed 中）
这是逻辑错误，与参数设计无关，但容易混淆。
注意默认值是“运行时”创建的
如果默认值是对象/数组，每次调用都会复用同一个引用（除非用工厂函数）：
ts
// ❌ 危险：所有调用共享同一个数组
function fn({ list = [] }: { list?: number[] } = {}) { ... }

// ✅ 安全（如需独立实例，应在函数体内处理）

💡 最佳实践总结
✅ 优先使用“带默认值的对象参数”代替多个可选位置参数
✅ 显式声明对象类型（或用 interface）
✅ 为每个属性提供合理的默认值
✅ 保持默认对象 = {} 使整个参数可省略

这种模式广泛应用于现代库（如 Axios、Vue Composition API、Lodash 等），是 TypeScript 函数设计的黄金标准之一。