# TypeScript 的结构类型系统：基于形状的类型兼容

## 一、基本概念对比

### 1. 名义类型系统 (Nominal Typing) - 如 C#、Java

```csharp
// C# - 名义类型
public class Person {
    public string Name { get; set; }
    public int Age { get; set; }
}

public class Employee {
    public string Name { get; set; }
    public int Age { get; set; }
    public string EmployeeId { get; set; }
}

// 即使形状相同，类型也不同
Person person = new Person { Name = "Alice", Age = 30 };
Employee employee = person; // 编译错误！类型不兼容

// 显式转换需要继承关系
public class Employee : Person {
    public string EmployeeId { get; set; }
}
```

### 2. 结构类型系统 (Structural Typing) - TypeScript

```typescript
// TypeScript - 结构类型
interface Person {
  name: string;
  age: number;
}

interface Employee {
  name: string;
  age: number;
  employeeId: string;
}

// 基于形状的类型兼容
const person: Person = { name: "Alice", age: 30 };
const employee: Employee = {
  name: "Bob",
  age: 25,
  employeeId: "E001",
};

// Person 拥有 Employee 所需的所有属性
const alice: Person = employee; // ✅ 兼容！因为 employee 有 name 和 age
// Employee 缺少 employeeId 属性
const bob: Employee = person; // ❌ 错误！person 缺少 employeeId
```

## 二、核心原理：鸭子类型

**"如果它走起来像鸭子，叫起来像鸭子，那么它就是鸭子"**

```typescript
// 鸭子类型的经典示例
interface Duck {
  walk(): void;
  quack(): void;
}

class RealDuck {
  walk() {
    console.log("Duck walking");
  }
  quack() {
    console.log("Quack!");
  }
}

class ToyDuck {
  walk() {
    console.log("Toy duck walking");
  }
  quack() {
    console.log("Squeak!");
  }
  // 额外方法
  batteryLevel() {
    return 100;
  }
}

function makeDuckWalk(duck: Duck) {
  duck.walk();
}

// 两种"鸭子"都可以使用
makeDuckWalk(new RealDuck()); // ✅
makeDuckWalk(new ToyDuck()); // ✅

// 字面量对象也可以
makeDuckWalk({
  walk: () => console.log("Walking"),
  quack: () => console.log("Quacking"),
}); // ✅
```

## 三、类型兼容性的规则

### 1. 属性兼容性

```typescript
interface Source {
  name: string;
  age: number;
}

interface Target {
  name: string;
}

const source: Source = { name: "Alice", age: 30 };
const target: Target = source; // ✅ 兼容！Target 的所有属性 Source 都有

// 目标类型可以缺少属性，但不能多出属性
interface BigTarget {
  name: string;
  age: number;
  extra: string;
}

const bigTarget: BigTarget = source; // ❌ 错误！source 缺少 extra 属性
```

### 2. 函数兼容性

```typescript
// 参数兼容性 - 逆变
type Handler = (event: Event) => void;

// 可以接受更具体的参数
const mouseHandler: Handler = (event: MouseEvent) => {
  console.log(event.clientX, event.clientY);
}; // ✅ 兼容！

// 不能接受更宽泛的参数
const genericHandler = (event: object) => {
  console.log(event);
};
const h: Handler = genericHandler; // ❌ 错误！

// 返回类型兼容性 - 协变
type Creator = () => { name: string };

const createPerson: Creator = () => {
  return { name: "Alice", age: 30 }; // ✅ 可以返回更多属性
};

const createMinimal: Creator = () => {
  return { name: "Bob" }; // ✅ 可以返回更少属性（但必须包含必需属性）
};
```

### 3. 数组和元组兼容性

```typescript
// 数组兼容性
const numbers: number[] = [1, 2, 3];
const anyArray: any[] = numbers; // ✅ 兼容

// 元组兼容性
type Point2D = [number, number];
type Point3D = [number, number, number];

const point2D: Point2D = [1, 2];
const point3D: Point3D = [1, 2, 3];

const arr2D: number[] = point2D; // ✅ 元组可以赋值给数组
const arr3D: number[] = point3D; // ✅

// 但反过来不行
const p2: Point2D = arr2D; // ❌ 错误！数组不能赋值给元组
```

## 四、实际应用场景

### 1. 接口隔离原则

```typescript
// 最小接口依赖
interface User {
  id: string;
  name: string;
  email: string;
  // 很多其他属性...
}

// 只需要部分属性的函数
function sendEmail(user: { email: string; name: string }) {
  console.log(`Sending email to ${name} at ${email}`);
}

const fullUser: User = {
  id: "123",
  name: "Alice",
  email: "alice@example.com",
  // ... 其他属性
};

sendEmail(fullUser); // ✅ 完美兼容！

// 甚至可以使用字面量对象
sendEmail({ name: "Bob", email: "bob@example.com" }); // ✅
```

### 2. React Props 的模式

```typescript
// 组件 Props 类型
interface ButtonProps {
  label: string;
  onClick: () => void;
  disabled?: boolean;
  className?: string;
}

// 使用组件
const MyButton = (props: ButtonProps) => {
  return (
    <button
      onClick={props.onClick}
      disabled={props.disabled}
      className={props.className}
    >
      {props.label}
    </button>
  );
};

// 调用组件 - 灵活的传递方式
<MyButton
  label="Click me"
  onClick={() => console.log("Clicked")}
  disabled={false}
  className="btn-primary"
/>;

// 可以传入更多属性吗？
interface ExtendedProps extends ButtonProps {
  icon?: string;
  size?: "small" | "large";
}

const extendedProps: ExtendedProps = {
  label: "Extended",
  onClick: () => {},
  icon: "star",
  size: "large",
};

<MyButton {...extendedProps} />; // ✅ TypeScript 不会报错！
// 因为 ExtendedProps 包含 ButtonProps 的所有必需属性
```

### 3. API 响应处理

```typescript
// API 返回的完整类型
interface ApiResponse {
  status: number;
  data: {
    users: Array<{
      id: string;
      name: string;
      email: string;
      profile: {
        avatar: string;
        bio: string;
      };
    }>;
    pagination: {
      page: number;
      total: number;
    };
  };
}

// 只需要部分数据的函数
function processUserNames(response: {
  data: {
    users: Array<{ name: string }>;
  };
}) {
  return response.data.users.map((user) => user.name);
}

const fullResponse: ApiResponse = await fetchUsers();
const names = processUserNames(fullResponse); // ✅ 兼容！
```

## 五、高级类型兼容技巧

### 1. 使用 `satisfies` 运算符 (TypeScript 4.9+)

```typescript
// 验证形状但不改变推断类型
const config = {
  api: {
    endpoint: "https://api.example.com",
    timeout: 5000,
  },
  features: ["auth", "logging"],
} as const;

// 使用 satisfies 进行类型验证
const validConfig = {
  api: {
    endpoint: "https://api.example.com",
    timeout: 5000,
  },
  features: ["auth", "logging"] as const,
} satisfies {
  api: {
    endpoint: string;
    timeout: number;
  };
  features: readonly string[];
};

// 保持字面量类型的精确性
validConfig.features[0]; // 类型是 "auth"，不是 string
```

### 2. 品牌类型模拟名义类型

```typescript
// TypeScript 中模拟名义类型
declare const brand: unique symbol;

type Brand<T, B> = T & { [brand]: B };

type UserId = Brand<string, "UserId">;
type OrderId = Brand<string, "OrderId">;

function createUserId(id: string): UserId {
  return id as UserId;
}

function createOrderId(id: string): OrderId {
  return id as OrderId;
}

// 虽然结构相同，但品牌不同
const userId: UserId = createUserId("user-123");
const orderId: OrderId = createOrderId("order-456");

function processUserId(id: UserId) {
  console.log(id);
}

processUserId(userId); // ✅
processUserId(orderId); // ❌ 类型错误！即使它们都是 string
```

### 3. 精确类型控制

```typescript
// 使用 never 类型防止特定属性
interface ExactType {
  name: string;
  age: number;
  [key: string]: never; // 禁止额外属性
}

const exact: ExactType = {
  name: "Alice",
  age: 30,
  extra: "value", // ❌ 错误！不允许额外属性
};

// 使用 Omit 和 never 的组合
type StrictProps<T, P extends keyof T> = Omit<T, P> & {
  [K in P]?: never;
};

interface ComponentProps {
  variant: "primary" | "secondary";
  size?: "small" | "medium" | "large";
  disabled?: boolean;
}

// variant 和 size 互斥
type ExclusiveProps =
  | (StrictProps<ComponentProps, "size"> & { variant: "primary" })
  | (StrictProps<ComponentProps, "variant"> & { size: "large" });

const props1: ExclusiveProps = {
  variant: "primary", // ✅
  // 不能有 size 属性
};

const props2: ExclusiveProps = {
  size: "large", // ✅
  // 不能有 variant 属性
};
```

## 六、优缺点分析

### 优点：

1. **灵活性高**：无需显式继承或实现
2. **代码简洁**：减少样板代码
3. **易于重构**：类型会自动适配
4. **支持鸭子类型**：更贴近 JavaScript 的哲学
5. **渐进增强**：可以逐步添加类型约束

### 缺点：

1. **可能过于宽松**：意外的类型兼容
2. **名义语义缺失**：无法区分语义不同的相同结构
3. **重构风险**：改变一个类型可能影响多个地方
4. **性能考虑**：类型检查可能更复杂
5. **名称冲突**：不同来源的相同结构会被视为相同

## 七、最佳实践

1. **使用接口而非类型别名**：接口支持声明合并
2. **最小接口原则**：只声明必要的属性
3. **利用字面量类型**：提高类型精确度
4. **适当使用品牌类型**：需要名义语义时
5. **启用严格模式**：`strict: true` 在 tsconfig.json
6. **避免 `any`**：使用 `unknown` 或特定类型替代
7. **利用泛型约束**：`extends` 关键字限制形状

```typescript
// 良好的结构类型实践
interface Repository<T> {
  findById(id: string): Promise<T | null>;
  save(entity: T): Promise<T>;
}

// 具体实现
class UserRepository implements Repository<User> {
  async findById(id: string) {
    // 实现...
  }

  async save(user: User) {
    // 实现...
  }
}

// 使用 - 基于形状的依赖注入
function createService<T>(repository: Repository<T>) {
  return {
    async getById(id: string) {
      return repository.findById(id);
    },
  };
}

// 任何符合 Repository<User> 形状的对象都可以使用
const userService = createService(new UserRepository());
const mockUserService = createService({
  findById: async (id) => ({ id, name: "Mock User" }),
  save: async (user) => user,
});
```

TypeScript 的结构类型系统是其最强大的特性之一，它平衡了类型的严谨性和 JavaScript 的灵活性，使得类型系统既强大又实用。
