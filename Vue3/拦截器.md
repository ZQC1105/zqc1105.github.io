这段代码展示了 **Axios 请求拦截器** 的核心作用。让我详细解释：

## **拦截器的主要作用**

### **1. 自动添加认证信息（如本例）**
```javascript
// 每次请求自动携带 token，无需在每个请求中手动添加
const token = localStorage.getItem('token');
if (token && config.headers) {
  config.headers.Authorization = `Bearer ${token}`;
}
```
**效果**：所有通过 `apiClient` 发送的请求都会自动带上 Authorization 头。

### **2. 统一处理请求配置**
```javascript
apiClient.interceptors.request.use((config) => {
  // 统一设置 Content-Type
  config.headers['Content-Type'] = 'application/json';
  
  // 添加时间戳防止缓存
  if (config.method === 'get') {
    config.params = {
      ...config.params,
      _t: Date.now()
    };
  }
  
  return config;
});
```

### **3. 请求日志记录**
```javascript
apiClient.interceptors.request.use((config) => {
  console.log(`[${config.method.toUpperCase()}] ${config.url}`, config.data);
  return config;
});
```

## **完整的拦截器应用场景**

### **请求拦截器常见用途**
```javascript
apiClient.interceptors.request.use(
  (config) => {
    // 1. 身份认证
    const token = getToken();
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    
    // 2. 设置公共头信息
    config.headers['X-Requested-With'] = 'XMLHttpRequest';
    config.headers['Accept-Language'] = getLocale();
    
    // 3. 请求时间戳（防止 GET 缓存）
    if (config.method === 'get') {
      config.params = {
        ...config.params,
        _t: Date.now()
      };
    }
    
    // 4. 请求加密/签名
    if (config.data && config.needSign) {
      config.headers['X-Sign'] = generateSign(config.data);
    }
    
    // 5. 显示加载状态
    if (config.showLoading) {
      showLoading();
    }
    
    return config;
  },
  (error) => {
    // 请求配置出错时的处理
    hideLoading();
    return Promise.reject(error);
  }
);
```

### **配合响应拦截器使用**
```javascript
// 请求拦截器
apiClient.interceptors.request.use((config) => {
  config.headers.Authorization = `Bearer ${localStorage.getItem('token')}`;
  return config;
});

// 响应拦截器
apiClient.interceptors.response.use(
  (response) => {
    // 成功响应处理
    return response.data;
  },
  (error) => {
    // 统一错误处理
    if (error.response?.status === 401) {
      // Token 过期，跳转到登录页
      router.push('/login');
    }
    return Promise.reject(error);
  }
);
```

## **拦截器的工作流程**

```
发起请求 → 请求拦截器 → 服务器 → 响应拦截器 → 业务代码
    ↑          ↓           ↑          ↓
    └──────────┴───────────┴──────────┘
           错误时的反向传播
```

## **实际业务场景**

### **场景1：API 版本控制**
```javascript
apiClient.interceptors.request.use((config) => {
  config.headers['API-Version'] = 'v2';
  return config;
});
```

### **场景2：请求重试机制**
```javascript
apiClient.interceptors.response.use(null, async (error) => {
  const config = error.config;
  
  // 如果是网络错误且未重试过
  if (!error.response && !config.__retryCount) {
    config.__retryCount = config.__retryCount || 0;
    
    if (config.__retryCount < 3) {
      config.__retryCount++;
      await new Promise(resolve => setTimeout(resolve, 1000));
      return apiClient(config);
    }
  }
  
  return Promise.reject(error);
});
```

### **场景3：文件上传特殊处理**
```javascript
apiClient.interceptors.request.use((config) => {
  // 如果是文件上传，不设置 Content-Type，让浏览器自动设置
  if (config.data instanceof FormData) {
    delete config.headers['Content-Type'];
  }
  return config;
});
```

## **优势总结**

1. **代码复用**：避免在每个请求中重复添加 token
2. **集中管理**：所有请求的公共逻辑在一个地方处理
3. **可维护性**：修改认证逻辑只需改一处
4. **错误统一处理**：可以集中处理 401、403 等状态码
5. **性能监控**：可以统一添加请求耗时统计

这就是为什么拦截器在现代前端 HTTP 客户端库（Axios、Fetch 封装等）中被广泛使用的原因。