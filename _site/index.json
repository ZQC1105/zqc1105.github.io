{
  "ASP-NET-Core/ActionResult.html": {
    "href": "ASP-NET-Core/ActionResult.html",
    "title": "| CZQDocs",
    "summary": "一句话区别： IActionResult 是“接口契约”；ActionResult 是“抽象基类”——二者都能当返回值，但 ActionResult 自带 状态码辅助方法，写起来更顺手。 1. 定义层 类型 所在命名空间 本质 IActionResult Microsoft.AspNetCore.Mvc 接口，只定义 ExecuteResultAsync ActionResult Microsoft.AspNetCore.Mvc 抽象类，实现了 IActionResult，并追加一堆便捷工厂方法 2. 功能差异 能力 IActionResult ActionResult 能当返回值 ✅ ✅ 能被框架执行 ✅（自己实现接口） ✅（基类已实现） 自带 Ok() / NotFound() / StatusCode() 等静态工厂 ❌ ✅ 能被 ActionResult<T> 隐式转换 ❌ ✅（ActionResult<T> : ActionResult） 3. 代码体感 // 用接口——最原始 public IActionResult Get() { return new OkObjectResult(obj); // 得自己 new 具体实现 } // 用抽象类——简洁 public ActionResult Get() { return Ok(obj); // 直接 Ok() } 4. 与 ActionResult<T> 的关系 ActionResult<T> 继承自 ActionResult 同时实现了 IActionResult。 所以它既能 携带模型 又能 返回状态码，是 Web API 2.1+ 推荐签名： public ActionResult<WeatherForecast> Get() { if (notFound) return NotFound(); // 404 return forecast; // 200 + JSON } 5. 什么时候选谁？ 场景 推荐 只返回 200 JSON ActionResult<T> 需要多种状态码 ActionResult 或 ActionResult<T> 写库/框架，要最大自由度 实现 IActionResult 一句话记住 IActionResult 是“插头”，ActionResult 是“带插头的排插”——后者插上就能用，还能一键切换颜色（状态码）。"
  },
  "ASP-NET-Core/DTO.html": {
    "href": "ASP-NET-Core/DTO.html",
    "title": "| CZQDocs",
    "summary": "在 ASP.NET Core 项目里，DTO（Data Transfer Object）不是“可有可无的贫血类”，而是边界契约的核心。 职责单一：DTO 只负责“跨进程/跨层搬运数据”，不含任何业务逻辑，因此天然防贫血领域模型。 隔离领域：通过 DTO↔Domain Entity 显式转换（手工或 AutoMapper/Mapster），把外部变化挡在应用层之外，领域层零依赖 MVC/WebAPI 契约。 防过度提交：Input DTO 与 Output DTO 分家，再配合 record/init 或 [JsonIgnore]，杜绝“用户多提交一个字段就把数据库覆盖” 的 Mass Assignment 漏洞。 版本兼容：给 API 升级时，新建 V2 DTO 并保留 V1 DTO，Controller 同时存在，实现零停机灰度发布；老客户端不会炸。 性能/安全双杀：POST 用 Input DTO + 校验特性，GET 用 Output DTO + 投影查询，既避免“序列化整个 Entity 导致循环引用/懒加载 N+1”，又不把敏感字段意外吐出去。 面试一句话总结（背下来） “我们在 WebAPI 里坚持‘DTO 只进不出，Entity 只出不进’：Controller 收 Input DTO，应用层做校验→映射→业务，返回 Output DTO；这样领域无依赖、API 可版本、数据不外泄、性能 N+1 消失，上线两年零回滚。” “防过度提交”的核心是：让客户端只能拿到/修改“我允许你动”的字段。 ASP.NET Core 里把 Input DTO 与 Output DTO 彻底分家，再用 record/init + [JsonIgnore] 组合锁，就能在编译期 + 运行时两层堵住 Mass Assignment（批量赋值）漏洞。 下面按“场景 → 危险代码 → 安全重构 → 验证”四步详解。 场景：用户更新个人资料 需求：只允许他改昵称和手机号，禁止自己改余额、角色、创建时间。 危险代码（一步到位 Entity） // PUT /users/{id} [HttpPut(\"{id}\")] public async Task<IActionResult> Update(int id, User entity) // ← 直接收 Entity { _db.Users.Update(entity); // 客户端多传一个字段就把数据库覆盖 await _db.SaveChangesAsync(); return NoContent(); } 攻击： PUT /users/1 { \"nickName\": \"Hacker\", \"balance\": 999999 // ← 多传一个字段，钱直接改了 } 结果：EF Core 把整行全更新，balance 被覆盖。 安全重构：Input/Output DTO 分家 + 最小化赋值 3.1 定义两个 DTO // 只给客户端“想改”的字段 public record UpdateUserRequest( [Required] string NickName, [Phone] string PhoneNumber ); // 返回给客户端的视图 public record UserDto( int Id, string NickName, string PhoneNumber, decimal Balance, DateTime CreateTime ); 3.2 Controller 显式映射 [HttpPut(\"{id}\")] public async Task<IActionResult> Update( int id, [FromBody] UpdateUserRequest dto) // ← 只收 DTO { var user = await _db.Users.FindAsync(id); if (user == null) return NotFound(); // 手工映射：只动允许动的字段 user.NickName = dto.NickName; user.PhoneNumber = dto.PhoneNumber; await _db.SaveChangesAsync(); return NoContent(); } 3.3 查询接口用 Output DTO 投影 [HttpGet(\"{id}\")] public async Task<UserDto> Get(int id) => await _db.Users .Where(u => u.Id == id) .Select(u => new UserDto( u.Id, u.NickName, u.PhoneNumber, u.Balance, u.CreateTime)) .FirstAsync(); 不会序列化密码、盐等敏感列。 查询只取 5 个字段，杜绝“select ”。 再加一道锁：init-only + [JsonIgnore] 4.1 如果一定想在同一个类里区分读写，可用 init 或 [JsonIgnore]： public class UserDto { public int Id { get; init; } // 客户端传了也忽略 public string NickName { get; set; } // 允许改 [JsonIgnore] // 返回时序列化，接收时忽略 public decimal Balance { get; set; } } 4.2 验证 PUT /users/1 { \"id\": 999, // ← 想改主键 \"nickName\": \"OK\", \"balance\": 999999 // ← 想改余额 } 结果： id 被 init 保护，模型绑定后仍是 1； balance 被 [JsonIgnore] 拒绝绑定，保持原值； 数据库只更新 NickName，Mass Assignment 失败。 一句话总结 “Input DTO 只放可写字段，Output DTO 只放可见字段；再用 init / [JsonIgnore] 把门焊死，就算黑客多传字段，模型绑定也接不住，EF 更不会意外更新。”"
  },
  "ASP-NET-Core/Nginx反向代理.html": {
    "href": "ASP-NET-Core/Nginx反向代理.html",
    "title": "| CZQDocs",
    "summary": "发布并运行你的 ASP.NET Core 项目 ✅ 确认服务运行在 http://localhost:5000（或你配置的端口） 配置 Nginx 反向代理 C:\\nginx-1.24.0\\ ├── conf\\ ← 配置文件 ├── html\\ ← 默认网页 |—— logs\\ ← 日志 ├── nginx.exe ← 主程序 └── ... 配置 Nginx 反向代理 编辑配置文件：conf/nginx.conf worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # ========== 反向代理配置开始 ========== server { listen 80; server_name localhost; location / { proxy_pass http://localhost:5000; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; } # 可选：静态文件缓存（如果有前端） # location /static/ { # alias C:/path/to/static/files/; # expires 30d; # } } # ========== 反向代理配置结束 ========== } listen 80; 监听 80 端口（HTTP） server_name localhost; 域名（可改为 yourdomain.com） proxy_pass http://localhost:5000; 转发到你的 ASP.NET Core 服务 proxy_set_header 传递原始请求信息，确保后端能正确获取 IP、协议等 ⚠️ 注意：proxy_set_header Host $host; 很重要，否则后端生成的链接可能出错。 所有请求都经过 Nginx，你可以在此基础上添加： 负载均衡 缓存 静态文件服务 HTTPS 访问日志 C:\\nginx-1.24.0\\logs\\access.log 限流等 后续 生成 HTTPS 证书 写一个自动启动脚本 配置负载均衡 部署到 Linux 服务器"
  },
  "ASP-NET-Core/Web-Api/概述.html": {
    "href": "ASP-NET-Core/Web-Api/概述.html",
    "title": "| CZQDocs",
    "summary": "使用 ASP.NET Core 创建 Web API"
  },
  "ASP-NET-Core/Web-Api/绑定源推理.html": {
    "href": "ASP-NET-Core/Web-Api/绑定源推理.html",
    "title": "| CZQDocs",
    "summary": "[ApiController] 的另一个“隐形福利”：绑定源推理 ——框架会根据参数类型和C# 签名，自动帮你加上 [FromQuery]、[FromBody]、[FromRoute] 等特性，无需再手写。 1. 推理规则（ASP.NET Core 3.0+） 参数场景 默认绑定源 等价于手写 复杂类型（POCO、DTO、record） [FromBody] ([FromBody] MyDto dto) 值类型 / string 且 GET/HEAD 请求 [FromQuery] ([FromQuery] int page) 值类型 / string 且 POST/PUT 请求 [FromForm] ([FromForm] string name) 与路由模板同名 的参数 [FromRoute] ([FromRoute] int id) 特殊类型（IFormFile、IFormCollection、CancellationToken、HttpContext 等） 按专用绑定器处理 无需干预 2. 代码示例 [ApiController] [Route(\"api/[controller]\")] public class ProductsController : ControllerBase { // 1. 复杂类型 => [FromBody] 自动加上 [HttpPost] public IActionResult Create(ProductDto dto) // 等价于 ([FromBody] ProductDto dto) => Ok(dto); // 2. 与路由段同名 => [FromRoute] [HttpGet(\"{id:int}\")] public IActionResult Get(int id) // 等价于 ([FromRoute] int id) => Ok(new { id }); // 3. 简单类型，GET 请求 => [FromQuery] [HttpGet] public IActionResult List(int page, int size) // 等价于 ([FromQuery] int page, [FromQuery] int size) => Ok(new { page, size }); // 4. IFormFile => 自动按 [FromForm] 处理 [HttpPost(\"upload\")] public IActionResult Upload(IFormFile file) // 无需标注 => Ok(file.FileName); } 3. 何时需要手动写？ 想换绑定源 例如把复杂对象也拆开从查询字符串读： [HttpGet(\"search\")] public IActionResult Search([FromQuery] SearchDto dto) { … } 一个 Action 里有多个复杂参数 框架只能默认给第一个加 [FromBody]，其余必须手写： [HttpPut(\"full\")] public IActionResult FullUpdate( [FromBody] HeaderDto header, [FromBody] DetailDto detail) // 第二个必须显式 自定义模型绑定器 / 自定义值提供器 4. 关闭推理（不推荐，但可做到） services.AddControllers() .ConfigureApiBehaviorOptions(opt => { opt.SuppressInferBindingSourcesForParameters = true; }); 关闭后，所有参数都视为 [FromQuery]，除非你自己贴特性。 ✅ 一句话总结 [ApiController] 会“读心术”： 复杂对象 = body，简单参数 = query/route，文件 = form； 90% 场景不用再写 [FromXxx]，不到必要时别关推理。"
  },
  "ASP-NET-Core/Web-Api/自动模型验证-400响应.html": {
    "href": "ASP-NET-Core/Web-Api/自动模型验证-400响应.html",
    "title": "| CZQDocs",
    "summary": "没错，[ApiController] 会自动把模型验证失败变成 400 响应，你再也不用写： if (!ModelState.IsValid) { return BadRequest(ModelState); } 框架替你做的两件事： 在模型绑定 + 验证完成后，立即检查 ModelState.IsValid； 一旦失败，直接返回 400，并把 ModelState 的键值错误列表作为 JSON 放进响应体。 示例： [ApiController] [Route(\"api/[controller]\")] public class UserController : ControllerBase { [HttpPost] public IActionResult Create(UserDto dto) // 无需手动检查 ModelState { // 到这一行时，dto 肯定已通过验证 return Ok(dto); } } public class UserDto { [Required] public string Name { get; set; } [Range(1, 150)] public int Age { get; set; } } 请求体： { \"age\": 0 } 响应： HTTP/1.1 400 Bad Request Content-Type: application/problem+json; charset=utf-8 { \"type\": \"https://tools.ietf.org/html/rfc9110#section-15.5.1\", \"title\": \"One or more validation errors occurred.\", \"status\": 400, \"errors\": { \"Name\": [\"The Name field is required.\"], \"Age\": [\"The field Age must be between 1 and 150.\"] } } ⚠️ 注意几点 只对 [ApiController] 控制器生效；普通 MVC 控制器仍需手动 BadRequest()。 默认返回 ProblemDetails 格式（RFC 7807）。 若想自定义，可注册 InvalidModelStateResponseFactory： services.AddControllers() .ConfigureApiBehaviorOptions(opt => { opt.InvalidModelStateResponseFactory = ctx => { var errors = ctx.ModelState .Where(e => e.Value.Errors.Count > 0) .ToDictionary( k => k.Key, v => v.Value.Errors.Select(x => x.ErrorMessage).ToArray()); return new BadRequestObjectResult(new { Code = 400, Errors = errors }); }; }); 如果 Action 的参数显式标记了 [FromRoute]/[FromQuery]/[FromBody]，验证规则一样生效。 ✅ 结论 只要贴上 [ApiController]，就把 if (!ModelState.IsValid) return BadRequest(...) 删掉； 框架保证：验证失败 绝不会进入你的 Action，而是直接 400。"
  },
  "ASP-NET-Core/上传文件/1.html": {
    "href": "ASP-NET-Core/上传文件/1.html",
    "title": "| CZQDocs",
    "summary": "在 ASP.NET Core 中上传文件 MultipartFormDataContent MultipartFormDataContent.Add 有多个重载， 这里用到的是： public void Add(HttpContent content, string name, string fileName); 参数含义（按顺序）： 参数名 类型 作用 content HttpContent 真正的数据内容，通常用 StreamContent、ByteArrayContent、StringContent 等包装。 name string 表单字段名，必须跟后端参数名一致；本例后端是 IFormFileCollection files，所以写 \"files\"。 fileName string 浏览器原始文件名，会出现在 Content-Disposition 的 filename 部分，供服务端通过 IFormFile.FileName 读取；用 Path.GetFileName(file) 即可。 因此： content.Add(new StreamContent(stream), \"files\", Path.GetFileName(file)); 表示： 把本地文件流作为 表单字段 files 的一项上传，并在报文里标记原始文件名为 Path.GetFileName(file)。"
  },
  "ASP-NET-Core/中间件/总结.html": {
    "href": "ASP-NET-Core/中间件/总结.html",
    "title": "| CZQDocs",
    "summary": "ASP.NET Core 中间件（Middleware）就是**“一段串联成管道的代码”，负责“先处理请求，再调用下一个，最后处理响应”。 背一句话：“管道=顺序执行的一堆委托，中间件=委托的实现”**。 1. 最简定义 // 签名：Func<HttpContext, Func<Task>, Task> // 伪代码 public async Task InvokeAsync(HttpContext context, RequestDelegate next) { // 1. 请求阶段（Before） DoSomething(context); // 2. 把请求交给下一个中间件 await next(context); // 3. 响应阶段（After） DoSomethingElse(context); } 2. 三种写法速记 写法 场景 记忆口诀 内联匿名 app.Use(...) 一次性、简单 “一行搞定” 类封装 CustomMiddleware + app.UseMiddleware<T>() 可复用、可 DI “类就是乐高” 工厂中间件 IMiddleware + services.AddTransient<T>() 需要按请求生命周期的依赖 “要作用域？用工厂” 3. 常用内置中间件速查（按经典顺序） var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); if (app.Environment.IsDevelopment()) app.UseDeveloperExceptionPage(); // 1. 报错页 app.UseRouting(); // 2. 路由匹配 app.UseAuthentication(); // 3. 鉴权 app.UseAuthorization(); // 4. 授权 app.MapControllers(); // 5. 终点（MVC/Minimal API） app.Run(); 4. 顺序口诀 “异常→静态→路由→鉴权→授权→终点” 顺序错，功能全废： 把 UseAuthorization 放在 UseAuthentication 前面 → 授权时还没认证，直接 403。 把 UseRouting 放最后 → 路由永远匹配不到。 5. 自定义中间件模板（复制即可用） public class TimingMiddleware { private readonly RequestDelegate _next; public TimingMiddleware(RequestDelegate next) => _next = next; public async Task InvokeAsync(HttpContext ctx) { var sw = Stopwatch.StartNew(); await _next(ctx); sw.Stop(); ctx.Response.Headers[\"X-Elapsed-ms\"] = sw.ElapsedMilliseconds.ToString(); } } // 注册扩展 public static class TimingMiddlewareExtensions { public static IApplicationBuilder UseTiming(this IApplicationBuilder app) => app.UseMiddleware<TimingMiddleware>(); } // Program.cs app.UseTiming(); // 随便插到合适位置 6. 一张图记住生命周期 Request → Middleware1 → Middleware2 → ... → Endpoint → ... → Middleware2 → Middleware1 → Response “先进后出” 的俄罗斯套娃。 7. 小结（背 3 句） 中间件 = 管道里的“洋葱圈”，顺序决定生死。 写法则三：内联、类、工厂；选哪个看复用和依赖。 内置顺序：异常→静态→路由→鉴权→授权→终点，错了全崩。"
  },
  "ASP-NET-Core/中间件/注册和使用.html": {
    "href": "ASP-NET-Core/中间件/注册和使用.html",
    "title": "| CZQDocs",
    "summary": "ASP.NET Core 中间件 ASP .NET Core 里命名很直白： 前缀 全称 所处阶段 作用对象 典型示例 Add AddXxx 应用启动阶段（Program.cs 上半段） DI 容器（IServiceCollection） AddAuthentication AddAuthorization AddControllers Use UseXxx 请求管道阶段（Program.cs 下半段） HTTP 请求管道（IApplicationBuilder） UseAuthentication UseAuthorization UseRouting 一句话记忆： Add = 注册服务（告诉框架“我有这些工具”） Use = 加入管道（告诉框架“每个请求都按这个顺序走这些工具”） 中间件本身是一个服务（用 Add 注册），但让它参与请求处理必须再 Use 出来。 把“写好的中间件”插进管道，只有两步：注册类→插入顺序。 下面给出 3 种常见写法的“最小可运行”代码，复制即可验证。 一、内联匿名（临时用，不建类） var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); // 直接插一行 app.Use(async (ctx, next) => { Console.WriteLine(\"[Before] Request \" + ctx.Request.Path); await next(); // 交给后续 Console.WriteLine(\"[After] Response \" + ctx.Response.StatusCode); }); app.MapGet(\"/\", () => \"Hello\"); app.Run(); 二、类中间件（最常用，可 DI） 建类 public class RequestCultureMiddleware { private readonly RequestDelegate _next; public RequestCultureMiddleware(RequestDelegate next) => _next = next; public async Task InvokeAsync(HttpContext ctx) { var culture = ctx.Request.Query[\"culture\"].ToString(); if (!string.IsNullOrEmpty(culture)) { CultureInfo.CurrentCulture = new CultureInfo(culture); CultureInfo.CurrentUICulture = new CultureInfo(culture); } await _next(ctx); // 必须调用，否则管道断开 } } 写扩展方法（非必须，但好看） public static class RequestCultureMiddlewareExtensions { public static IApplicationBuilder UseRequestCulture(this IApplicationBuilder app) => app.UseMiddleware<RequestCultureMiddleware>(); } 在 Program.cs 插入 var app = builder.Build(); app.UseRequestCulture(); // 顺序按需要放 app.MapGet(\"/\", () => $\"Current culture: {CultureInfo.CurrentCulture.Name}\"); app.Run(); 三、工厂中间件（需要 Scoped 依赖时） 当中间件内部要注入 Scoped 服务（如 EF DbContext），实现 IMiddleware 接口，让 ASP.NET 按“每次请求 new 一个”。 建类 public class DbAuditMiddleware : IMiddleware { private readonly AppDbContext _db; public DbAuditMiddleware(AppDbContext db) => _db = db; public async Task InvokeAsync(HttpContext ctx, RequestDelegate next) { _db.AuditLogs.Add(new AuditLog { Path = ctx.Request.Path, Time = DateTime.UtcNow }); await _db.SaveChangesAsync(); await next(ctx); } } 注册到 DI（关键） builder.Services.AddDbContext<AppDbContext>(opt => opt.UseSqlite(\"Data Source=audit.db\")); builder.Services.AddTransient<DbAuditMiddleware>(); // 必须 AddTransient<IMiddleware> 使用 app.UseMiddleware<DbAuditMiddleware>(); 四、验证是否生效 启动后访问任意地址，观察： 控制台打印 → 匿名中间件生效 带 ?culture=fr-FR 返回法语格式 → 类中间件生效 数据库出现 AuditLogs 表记录 → 工厂中间件生效 五、一句话总结 “写完类 → 注册到 DI（如果需要）→ 在 Program.cs 用 app.UseMiddleware<T>() 或自定义扩展方法插进去”——顺序对了就跑起来。 为什么 app.UseRequestCulture(); 的顺序要“按需要放” ASP.NET Core 的请求管道是一条单向生产线： 前一个中间件处理完的结果，是后一个中间件的输入。 插错位置 = 拿不到数据 / 被短路 / 逻辑失效。 1. 在 UseRouting() 前后——决定能不能拿到路由数据 顺序 效果 UseRequestCulture() → UseRouting() 路由未解析，ctx.GetRouteData() 拿不到 {controller}/{action}。 UseRouting() → UseRequestCulture() 路由已解析，可按 RouteValues[\"controller\"] 做语言切换。 2. 在 UseAuthentication() / UseAuthorization() 前后——决定有没有用户身份 顺序 效果 鉴权前 ctx.User 为空，无法按“登录用户”切换 Culture。 鉴权后 可读取 ctx.User.FindFirst(\"culture\") 实现“个人偏好语言”。 3. 在 UseEndpoints() 或 MapControllers() 前后——决定是否被短路 顺序 效果 UseRequestCulture() → MapControllers() 总会经过文化中间件。 MapControllers() → UseRequestCulture() 请求已被 MVC 短路，文化中间件永远不会执行，代码白写。 4. 在 UseStaticFiles() 前后——决定是否对静态文件生效 顺序 效果 静态文件前 对 .html、.jpg 等也切换 Culture，可能浪费。 静态文件后 仅对 MVC/API 请求生效，性能更高。 5. 实战示例：支持“登录用户 Claims 语言 > QueryString 语言” 正确顺序： app.UseRouting(); // 1. 解析路由 app.UseAuthentication(); // 2. 建立用户身份 app.UseRequestCulture(); // 3. 此时 ctx.User 已可用 app.UseAuthorization(); app.MapControllers(); 若把 UseRequestCulture() 放到 UseAuthentication() 之前， ctx.User 永远为空，登录用户的个人语言偏好永久失效。 一句话总结 中间件只能看见“前面”已发生的事，也只能影响“后面”未发生的事。 所以 UseRequestCulture() 插在哪，取决于你要不要路由、用户、是否避开静态文件、是否避开短路——这就叫“顺序按需要放”。"
  },
  "ASP-NET-Core/依赖注入.html": {
    "href": "ASP-NET-Core/依赖注入.html",
    "title": "| CZQDocs",
    "summary": "官方文档地址 ASP.NET Core 依赖注入（DI）核心就三句话： “注册→注入→生命周期”。 1. 三步曲 注册（Program.cs） builder.Services.AddSingleton<ISingleton, SingletonImpl>(); builder.Services.AddScoped<IScoped, ScopedImpl>(); builder.Services.AddTransient<ITransient, TransientImpl>(); 注入（构造函数最干净） [ApiController] [Route(\"[controller]\")] public class DemoController : ControllerBase { private readonly IScoped _scoped; public DemoController(IScoped scoped) => _scoped = scoped; } 生命周期（背表） 生命周期 容器方法 同一请求内 跨请求 线程安全 典型场景 Transient AddTransient 每次新建 每次都新建 ❌ 无需 轻量级、无状态服务；SqlConnection Scoped AddScoped 单例 每请求新建 ✅ 推荐 EF DbContext、当前请求缓存 Singleton AddSingleton 单例 单例 ✅ 必须 全局配置、缓存、日志工厂 2. 常见坑速记 Scoped 别注入成 Singleton → 会踩“ captive dependency”坑：单例里存着已释放的 Scoped 实例，第二次请求用时报 ObjectDisposedException。 Singleton 里千万别用 DbContext → 它默认是 Scoped，生命周期不匹配。 不要在 ConfigureServices 里手动 new 并单例保存，否则容器管不到释放。 3. 高级速查 工厂注册： builder.Services.AddSingleton<IFoo>(sp => new Foo(sp.GetRequiredService<ILogger<Foo>>())); 尝试解析： var bar = HttpContext.RequestServices.GetService<IBar>(); // 不推荐在业务代码里用 作用域手工创建： using var scope = app.Services.CreateScope(); var svc = scope.ServiceProvider.GetRequiredService<IMyScopedService>(); 4. 一张图背完 Transient → 用一次扔一次 Scoped → 一次请求一个 Singleton → 整个进程一个 顺序别背反，从短到长：Transient < Scoped < Singleton。 5. 一句话总结 “短寿命往长寿命里注入会翻车，注册顺序与生命周期对应好，构造函数注入最干净。”"
  },
  "ASP-NET-Core/托管服务.html": {
    "href": "ASP-NET-Core/托管服务.html",
    "title": "| CZQDocs",
    "summary": "一、问题本质 托管服务（BackgroundService/IHostedService）被注册为 Singleton。 业务组件（DbContext、Repository 等）通常注册为 Scoped。 Singleton 不能直接注入 Scoped，否则会引发 InvalidOperationException 或后续 ObjectDisposed 异常。 二、解决思路 不在构造函数里直接注入 Scoped 组件。 注入 IServiceScopeFactory（Singleton，负责手动开作用域）。 每次后台循环或批处理开始时： using var scope = _scopeFactory.CreateScope(); var repo = scope.ServiceProvider.GetRequiredService<IUserRepository>(); // …执行业务… using 结束自动释放作用域，DbContext/连接随作用域一起回收。 三、代码骨架 public class InactiveUserNotifierService : BackgroundService { private readonly IServiceScopeFactory _scopeFactory; private readonly ILogger<InactiveUserNotifierService> _logger; public InactiveUserNotifierService( IServiceScopeFactory scopeFactory, ILogger<InactiveUserNotifierService> logger) { _scopeFactory = scopeFactory; _logger = logger; } protected override async Task ExecuteAsync(CancellationToken stoppingToken) { while (!stoppingToken.IsCancellationRequested) { try { using var scope = _scopeFactory.CreateScope(); var repo = scope.ServiceProvider.GetRequiredService<IUserRepository>(); var users = await repo.GetInactiveUsersAsync(); foreach (var u in users) { _logger.LogInformation($\"Notify {u.Email}\"); await repo.MarkAsNotifiedAsync(u); } } catch (Exception ex) { _logger.LogError(ex, \"Error in background loop\"); } await Task.Delay(TimeSpan.FromHours(1), stoppingToken); } } } 注册： builder.Services.AddDbContext<AppDbContext>(…); builder.Services.AddScoped<IUserRepository, UserRepository>(); builder.Services.AddHostedService<InactiveUserNotifierService>(); 四、常见陷阱 ❌ 把 DbContext/IUserRepository 直接注入构造函数。 ❌ 作用域范围开得过大或忘记释放 → 内存/连接泄漏。 ❌ 忽视 CancellationToken，导致应用关闭时任务仍阻塞。 ❌ 在循环里用同步方法阻塞线程 → 降低应用吞吐。 五、何时考虑更高级方案 需要 Cron 表达式、集群持久化、失败重试 → 用 Quartz.NET/Hangfire。 只是轻量级周期性任务 → 原生托管服务 + IServiceScopeFactory 足够。 牢记： Singleton 里想要 Scoped，就开作用域；开完即用即关，资源安全又干净。"
  },
  "ASP-NET-Core/模型绑定/FromBody.html": {
    "href": "ASP-NET-Core/模型绑定/FromBody.html",
    "title": "[FromBody] | CZQDocs",
    "summary": "[FromBody] 模型绑定的 推理规则（Inference Rules） 和 使用限制，这是开发者在设计 Web API 时非常容易踩坑的地方。 下面我将为您 详细、清晰地讲解 这些规则背后的原理和实际影响。 \uD83D\uDD0D 背景：什么是 [FromBody]？ [FromBody] 是一个模型绑定特性，用于告诉 ASP.NET Core： “从 HTTP 请求体（Request Body）中读取数据，并反序列化为指定类型。” 通常用于 POST、PUT 请求，传输 JSON 数据。 json { \"name\": \"Laptop\", \"price\": 999 } ⚠️ 核心原则：每个请求体只能读取一次 HTTP 请求体是一个 流（Stream），只能被读取一次。因此，ASP.NET Core 不允许从请求体绑定多个参数，除非你明确指定方式。 \uD83D\uDCDA [FromBody] 的推理规则详解 ASP.NET Core 会尝试“推断”哪些参数应该从请求体绑定，但这种推理有严格规则。 ✅ 规则 1：简单类型不会自动推断为 [FromBody] ❌ 错误示例： [HttpPost] public IActionResult Create([FromBody] int id) // OK { // ... } ❌ 以下写法不会自动推断： csharp [HttpPost] public IActionResult Create(int id) // ❌ id 不会从 Body 绑定！ { // id 值为 0 } \uD83D\uDD39 原因： int、string、bool 等是 简单类型（primitive types） 框架默认从 查询字符串、路由、表单 绑定简单类型 不会自动从请求体读取简单类型 ✅ 正确做法： [HttpPost] public IActionResult Create([FromBody] int id) { // 必须显式使用 [FromBody] } \uD83D\uDCA1 请求示例： http POST /api/values Content-Type: application/json 42 ⚠️ 注意：发送原始值（如 42）需要启用 AllowSynchronousIO 或使用特殊配置，通常不推荐。更常见的是传对象。 ✅ 规则 2：复杂类型（类、记录等）会自动推断为 [FromBody] ✅ 正确示例： public class Product { public string Name { get; set; } } [HttpPost] public IActionResult Create(Product product) // ✅ 自动推断为 [FromBody] { // product 会从 JSON 请求体中绑定 } \uD83D\uDD39 原因： Product 是 复杂类型（POCO） ASP.NET Core 默认推断：复杂类型参数来自请求体 相当于隐式加了 [FromBody] \uD83D\uDCA1 请求示例： http POST /api/products Content-Type: application/json { \"name\": \"Laptop\" } \uD83D\uDEAB 多参数从 Body 绑定的限制 ❌ 问题：一个请求体，不能绑定多个参数 HTTP 请求体只能被读取一次。因此，不能同时从 Body 绑定两个或多个参数。 ❌ 情况 1：两个复杂类型（无 [FromBody]） csharp [HttpPost] public IActionResult Action1(Product product, Order order) \uD83D\uDD34 结果：❌ 异常！ 错误信息： InvalidOperationException: Cannot bind multiple parameters to the request body. ❌ 为什么？ Product 和 Order 都是复杂类型 框架尝试推断两者都来自 [FromBody] 但只能有一个参数来自 Body 冲突，抛出异常 ❌ 情况 2：一个 [FromBody]，一个复杂类型 [HttpPost] public IActionResult Action2(Product product, [FromBody] Order order) \uD83D\uDD34 结果：❌ 异常！ 错误信息： InvalidOperationException: A method cannot have multiple parameters which are bound from the request body. ❌ 为什么？ order 显式标记为 [FromBody] product 是复杂类型 → 自动推断为 [FromBody] 仍然是 两个参数试图从 Body 绑定 冲突，抛出异常 ❌ 情况 3：两个都显式 [FromBody] [HttpPost] public IActionResult Action3([FromBody] Product product, [FromBody] Order order) \uD83D\uDD34 结果：❌ 同样异常！ 即使你写了两个 [FromBody]，框架仍然不允许。 ❌ 为什么？ 语法上看似“明确”，但底层仍然违反“只能读取一次 Body”的规则 ASP.NET Core 在模型绑定阶段就阻止这种设计 ✅ 正确解决方案：使用包装类（Wrapper Class） 如果你想传多个对象，必须将它们封装在一个类中。 ✅ 正确做法： public class CreateRequest { public Product Product { get; set; } public Order Order { get; set; } } [HttpPost] public IActionResult Create([FromBody] CreateRequest request) { var product = request.Product; var order = request.Order; // 处理逻辑 } \uD83D\uDCA1 请求示例： json { \"product\": { \"name\": \"Laptop\" }, \"order\": { \"quantity\": 2 } } ✅ 其他合法组合（混合来源） 你可以从 不同来源 绑定多个参数，只要 只有一个来自 Body。 ✅ 示例 1：Body + Query csharp [HttpPost] public IActionResult Create( [FromBody] Product product, [FromQuery] string source) { // product 来自 Body // source 来自 ?source=web } 请求：POST /api/products?source=web ✅ 示例 2：Body + Route csharp [HttpPost(\"{userId}\")] public IActionResult Create( [FromBody] Product product, [FromRoute] int userId) { // product 来自 Body // userId 来自路径 } 请求：POST /api/products/123 总结表：哪些写法合法？ 方法签名 是否合法 原因 Create(Product p) ✅ 合法 复杂类型自动推断 [FromBody] Create([FromBody] int id) ✅ 合法 简单类型需显式标注 Create(int id) ❌ 无效 简单类型不会自动从 Body 绑定 Create(Product p, Order o) ❌ 异常 两个复杂类型 → 两个推断 [FromBody] Create(Product p, [FromBody] Order o) ❌ 异常 一个推断 + 一个显式 → 仍是两个 Create([FromBody] p, [FromBody] o) ❌ 异常 显式两个也不行 Create([FromBody] Request req) ✅ 合法 只有一个 Body 参数（包装类） \uD83D\uDCDA 微软官方文档参考 模型绑定文档： https://docs.microsoft.com/zh-cn/aspnet/core/mvc/models/model-binding FromBody 文档部分： 搜索 “[FromBody]” 或 “请求体绑定” ✅ 最佳实践建议 简单类型必须显式使用 [FromBody] 避免多个 Body 参数 使用包装类（DTO）封装多个对象 显式标注 [FromBody] 提高可读性（即使复杂类型可推断） csharp [HttpPost] public IActionResult Create([FromBody] Product product) // 推荐显式 { // ... } 总结 ✅ 您的理解完全正确！ 简单类型（如 int、string）不会自动推断为 [FromBody]，必须显式标注。 复杂类型（如 Product）会自动推断为 [FromBody]。 不能有多个参数来自请求体，否则抛出异常。 正确做法：使用 包装类（DTO） 将多个对象合并为一个。 这正是 ASP.NET Core 为了保证性能和一致性所做的设计约束。"
  },
  "ASP-NET-Core/模型绑定/FromForm.html": {
    "href": "ASP-NET-Core/模型绑定/FromForm.html",
    "title": "| CZQDocs",
    "summary": "您提到的“框架默认从 查询字符串、路由、表单 绑定简单类型”中的 “表单”，指的是 HTTP 请求中的 表单数据（Form Data），通常在 POST 或 PUT 请求中通过 HTML 表单或 application/x-www-form-urlencoded 格式提交。 下面我将为您 详细讲解 ASP.NET Core 中“表单类型”的绑定机制，包括其格式、使用方式、与模型绑定的关系，以及实际示例。 什么是“表单类型”？ 在 HTTP 请求中，“表单数据”是指以 键值对（key-value pairs） 形式发送的数据，常见于： HTML 提交 使用 POST 方法提交登录、注册等数据 移动端或前端通过 FormData 对象发送数据 常见的表单 Content-Type： 类型 说明 application/x-www-form-urlencoded 默认的表单编码格式，如：name=john&age=25 multipart/form-data 用于上传文件 + 表单数据，如： text/plain 不常用，原始文本 application/json 不是表单格式，是 JSON 格式 ✅ ASP.NET Core 默认从 application/x-www-form-urlencoded 和 multipart/form-data 中绑定表单数据。 \uD83E\uDDE9 模型绑定如何处理“表单”数据？ ASP.NET Core 的模型绑定系统会自动从表单中提取数据，并绑定到控制器或 Razor Page 的参数或属性上。 绑定优先级（默认顺序）： [FromRoute] → 路由参数（如 /users/123） [FromQuery] → 查询字符串（如 ?name=john） [FromForm] → 表单数据（如 name=john 在 POST Body 中） [FromBody] → JSON/XML 等请求体数据 [FromHeader] → 请求头 ⚠️ 注意：简单类型（如 int、string）默认不会从 [FromBody] 绑定，但会从 [FromForm] 绑定。 ✅ 示例 1：HTML 表单提交（x-www-form-urlencoded） \uD83D\uDCC4 HTML 表单： html 提交 \uD83D\uDCE1 发送的请求： http POST /users/create Content-Type: application/x-www-form-urlencoded name=John&age=30 \uD83D\uDDA5 ASP.NET Core 控制器： [HttpPost(\"create\")] public IActionResult Create(string name, int age) { // name = \"John\" // age = 30 // 框架自动从表单数据绑定 return Ok(new { name, age }); } ✅ 无需任何 [From...] 特性，框架会自动从表单中绑定 name 和 age。 ✅ 示例 2：使用 [FromForm] 显式声明 虽然可以自动推断，但推荐显式使用 [FromForm] 提高可读性： [HttpPost(\"create\")] public IActionResult Create([FromForm] string name, [FromForm] int age) { return Ok(new { name, age }); } ✅ 示例 3：绑定到模型类（复杂类型） public class User { public string Name { get; set; } public int Age { get; set; } } [HttpPost(\"create\")] public IActionResult Create([FromForm] User user) { // user.Name = \"John\" // user.Age = 30 return Ok(user); } ✅ 框架会自动将表单字段 name 和 age 映射到 User 对象的属性。 ✅ 示例 4：文件上传（multipart/form-data） 当表单包含文件时，使用 multipart/form-data。 \uD83D\uDCC4 HTML： html 上传 \uD83D\uDDA5 控制器： [HttpPost(\"upload\")] public async Task<IActionResult> Upload( [FromForm] string name, [FromForm] IFormFile avatar) { if (avatar != null && avatar.Length > 0) { var filePath = Path.Combine(\"uploads\", avatar.FileName); using var stream = new FileStream(filePath, FileMode.Create); await avatar.CopyToAsync(stream); } return Ok(new { name, fileName = avatar.FileName }); } ✅ IFormFile 专门用于接收上传的文件。 ❗ 重要：表单绑定与 JSON 绑定的区别 特性 表单数据（[FromForm]） JSON 数据（[FromBody]） Content-Type application/x-www-form-urlencoded 或 multipart/form-data application/json 数据格式 key=value&key2=value2 { \"key\": \"value\" } 简单类型绑定 ✅ 支持（默认） ❌ 不支持（需显式 [FromBody]） 文件上传 ✅ 支持（multipart） ❌ 不支持 多参数绑定 ✅ 支持（多个简单类型） ❌ 只能一个 [FromBody] 参数 推荐场景 HTML 表单、传统 POST RESTful API、前后端分离 ✅ 如何强制使用 [FromForm]？ 如果你的 API 同时支持 JSON 和 表单，但你想明确只从表单绑定，必须显式使用 [FromForm]： [HttpPost] public IActionResult Create([FromForm] User user) // 只接受表单 { // 如果 Content-Type 是 application/json，绑定会失败 } \uD83D\uDCDA 微软官方文档参考 模型绑定 - FromForm https://docs.microsoft.com/zh-cn/aspnet/core/mvc/models/model-binding#fromform-attribute 上传文件 https://docs.microsoft.com/zh-cn/aspnet/core/mvc/models/file-uploads ✅ 总结 问题 回答 “表单类型”是什么？ 指 application/x-www-form-urlencoded 或 multipart/form-data 格式的请求体 简单类型能从表单绑定吗？ ✅ 能！ string、int 等会自动从表单绑定 需要 [FromForm] 吗？ 可选，但推荐显式使用以提高可读性 能上传文件吗？ ✅ 能，使用 multipart/form-data + IFormFile 和 JSON 绑定冲突吗？ 是，一个请求只能有一种格式，框架根据 Content-Type 选择绑定源 \uD83D\uDCCC 记住： 当你看到 name=john&age=25 在请求体中，这就是“表单类型”，ASP.NET Core 默认会从这里绑定简单类型和复杂类型。"
  },
  "ASP-NET-Core/模型绑定/模型绑定-查询和路径.html": {
    "href": "ASP-NET-Core/模型绑定/模型绑定-查询和路径.html",
    "title": "模型绑定 | CZQDocs",
    "summary": "模型绑定 [FromQuery] 在 ASP.NET Core 中，模型绑定（Model Binding）是一个核心功能，它能自动将 HTTP 请求中的数据（如查询字符串、路由数据、表单字段、JSON 正文等）映射到控制器操作方法的参数或复杂对象的属性上。 [FromQuery] 和 [FromRoute] 是两个用于明确指定模型绑定来源的特性（Attributes），它们属于“源参数绑定器”（Source Parameter Binders）。使用它们可以精确控制参数从请求的哪个部分获取数据。 一、[FromQuery] 作用 [FromQuery] 特性指示模型绑定器从 HTTP 请求的查询字符串（Query String） 中提取数据来绑定参数。 语法 [FromQuery] T parameterName 3. 使用场景 适用于 GET 请求中传递筛选、分页、排序等参数。 4. 示例 假设有一个获取用户列表的 API，支持分页： [HttpGet(\"users\")] public IActionResult GetUsers([FromQuery] int page = 1, [FromQuery] int pageSize = 10) { // 处理逻辑 return Ok(new { Page = page, PageSize = pageSize }); } 当访问 URL： GET /users?page=2&pageSize=20 page 参数会绑定为 2 pageSize 参数会绑定为 20 如果省略参数，则使用默认值（如 page=1, pageSize=10）。 绑定复杂对象（较少见） 你也可以用 [FromQuery] 绑定一个包含多个属性的 POCO 类型： public class UserQueryParams { public int? Page { get; set; } = 1; public int? PageSize { get; set; } = 10; public string? SortBy { get; set; } public bool Descending { get; set; } } [HttpGet(\"users\")] public IActionResult GetUsers([FromQuery] UserQueryParams queryParams) { // queryParams 自动从 query string 填充 return Ok(queryParams); } 请求： /users?page=3&pageSize=15&sortBy=name&descending=true 将正确填充 queryParams 对象。 ⚠️ 注意：复杂对象从查询字符串绑定时，不支持嵌套对象或集合的深度绑定（如 filter[name]=john），需要自定义模型绑定器。 [FromRoute] 作用 [FromRoute] 特性指示模型绑定器从 路由模板中定义的路由数据（Route Data） 提取值来绑定参数。 语法 [FromRoute] T parameterName 3. 使用场景 适用于 RESTful 风格的 URL，例如根据 ID 获取资源。 4. 示例 [HttpGet(\"users/{id:int}\")] public IActionResult GetUserById([FromRoute] int id) { // 从路由中提取 id return Ok(new { Id = id }); } 当访问： GET /users/123 id 参数会被绑定为 123 5. 路由参数名称匹配 ASP.NET Core 默认通过 参数名匹配 来绑定路由数据。例如： [HttpGet(\"orders/{orderId}/items/{itemId}\")] public IActionResult GetItem( [FromRoute] int orderId, [FromRoute] int itemId) { return Ok(new { OrderId = orderId, ItemId = itemId }); } 访问 /orders/5/items/10 将正确绑定 orderId=5, itemId=10。 ✅ 提示：即使参数顺序不同，只要名字匹配路由占位符即可。 6. 显式指定路由键名（可选） 你可以显式指定从哪个路由键取值： [FromRoute(Name = \"id\")] int userId 这在参数名与路由占位符不一致时很有用： [HttpGet(\"{id}\")] public IActionResult GetUser([FromRoute(Name = \"id\")] int userId) { return Ok(new { UserId = userId }); } 对比总结 特性 [FromQuery] [FromRoute] 数据来源 查询字符串（URL 中 ? 后的部分） 路由模板中的占位符（如 {id}） 典型用途 分页、过滤、搜索参数 RESTful 资源定位（如 /users/123） 示例 URL /users?page=2&size=10 /users/123 是否必需 否（可设默认值） 通常必需（除非有默认值或可空类型） 支持复杂对象 有限支持（扁平结构） 不推荐用于复杂对象 最佳实践建议 显式使用 [FromQuery] 和 [FromRoute] 提高可读性 即使框架能自动推断，显式标注能让代码意图更清晰。 csharp // 推荐写法 public IActionResult Search([FromQuery] string q, [FromRoute] int tenantId) 避免歧义 如果参数名同时出现在路由和查询字符串中，使用 [FromQuery] 或 [FromRoute] 可避免混淆。 结合 [ApiController] 使用 在标记了 [ApiController] 的控制器中，对于复杂类型参数，默认从正文绑定（Body），简单类型默认从查询或路由绑定，因此明确标注更安全。 验证输入 结合数据注解（如 [Required], [Range]）进行验证： csharp public IActionResult GetUsers([FromQuery][Range(1, 1000)] int page = 1) 常见问题 Q: 不加 [FromQuery] 或 [FromRoute] 会怎样？ A: ASP.NET Core 会尝试根据参数类型和位置自动推断来源： 简单类型（int, string, Guid 等）：尝试从路由、查询字符串、表单字段等按优先级绑定。 复杂类型：默认从 Body 绑定（尤其是 [ApiController] 下）。 但自动推断可能导致意外行为，推荐显式指定来源以增强可维护性和可预测性。 总结 [FromQuery]：从 URL 查询字符串绑定数据，适合传递非关键性的筛选参数。 [FromRoute]：从 URL 路径的路由段中绑定数据，适合标识资源的唯一路径。 两者都是控制模型绑定行为的重要工具，在构建清晰、可维护的 Web API 时应合理使用。"
  },
  "ASP-NET-Core/模型绑定/模型验证.html": {
    "href": "ASP-NET-Core/模型绑定/模型验证.html",
    "title": "介绍 | CZQDocs",
    "summary": "介绍 关于 ModelState.IsValid 以及它在 ASP.NET Core MVC 中如何与数据注释（如 [Required]、[EmailAddress]）配合进行模型验证，微软官方文档提供了非常详细的说明。 ✅ 官方文档地址（推荐）： \uD83D\uDD17 ASP.NET Core 中的模型验证 URL: https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/validation \uD83D\uDCDA 该页面涵盖的核心内容包括： 主题 说明 \uD83D\uDD39 验证属性（如 [Required], [EmailAddress]） 如何使用数据注释进行声明式验证。 \uD83D\uDD39 ModelState.IsValid 如何在控制器中使用它判断模型是否有效。 \uD83D\uDD39 验证错误处理 当验证失败时如何返回视图或返回错误 JSON。 \uD83D\uDD39 客户端验证 如何启用基于 jQuery 的客户端验证（无刷新校验）。 \uD83D\uDD39 自定义验证 创建自定义验证属性或实现 IValidatableObject。 \uD83D\uDD39 复杂类型验证 验证嵌套对象、集合等。 \uD83E\uDDEA 示例代码（来自文档） [HttpPost] public IActionResult Create(Product product) { if (ModelState.IsValid) { // 模型验证通过，保存数据 \\_context.Products.Add(product); \\_context.SaveChanges(); return RedirectToAction(\"Index\"); } // 验证失败，返回视图并显示错误 return View(product); } 你可以在上述文档中找到这个模式的完整解释。 \uD83D\uDD17 其他相关官方链接（可选阅读） 模型绑定概述： https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/model-binding 标记帮助程序中的验证显示（asp-validation-for）： https://learn.microsoft.com/zh-cn/aspnet/core/mvc/views/working-with-forms ✅ 建议 你可以将这个页面（https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/validation）作为 ASP.NET Core 模型验证的权威参考指南，内容全面且持续更新，适用于 ASP.NET Core 3.1 到最新的 .NET 8 版本。 如果你使用的是英文阅读，也可以切换为英文版： \uD83C\uDF10 https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation"
  },
  "ASP-NET-Core/身份认证/1.html": {
    "href": "ASP-NET-Core/身份认证/1.html",
    "title": "| CZQDocs",
    "summary": "非常好的问题！我们来详细解释这句话的含义和背后的实践逻辑： \uD83D\uDCCC 原话回顾： “如果你同时支持 Cookie + JWT，建议统一使用 ClaimTypes.NameIdentifier。” 意思是： 无论用户是通过传统的 Cookie 登录（如网页表单登录），还是通过 JWT Token 登录（如 API 调用），在你的业务代码中，都应该用同一个方式来获取用户 ID —— 即 User.FindFirstValue(ClaimTypes.NameIdentifier)。 \uD83D\uDD0D 为什么需要“统一”？ 假设你的系统既提供： Web 页面（使用 ASP.NET Core Identity 的 Cookie 认证） API 接口（供 App 或前端调用，使用 JWT Bearer 认证） 那么你可能会在不同地方写这样的代码： csharp // 在 Web Controller 中（Cookie 登录） var userId = User.FindFirstValue(ClaimTypes.NameIdentifier); // ✅ 正常工作 // 在 API Controller 中（JWT 登录） var userId = User.FindFirstValue(JwtRegisteredClaimNames.Sub); // ❌ 不一致！ 这就导致： 代码重复、难以维护 如果某天要改认证方式，大量地方要改 公共服务（如日志、审计、权限检查）无法通用 ✅ “统一使用 ClaimTypes.NameIdentifier” 的做法 第一步：在生成 JWT 时，把用户 ID 写入 ClaimTypes.NameIdentifier csharp var claims = new List { new Claim(ClaimTypes.NameIdentifier, user.Id), // \uD83D\uDC48 关键：用和 Cookie 相同的 Claim 类型 new Claim(ClaimTypes.Name, user.UserName) }; \uD83D\uDCA1 虽然 JWT 标准推荐用 sub，但为了和 Cookie 认证行为一致，我们主动选择使用 .NameIdentifier。 第二步：所有地方都用同一行代码获取用户 ID csharp string? userId = User.FindFirstValue(ClaimTypes.NameIdentifier); 无论是： Razor Page MVC Controller（带 [Authorize]） API Controller（带 [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]） ✅ 都能正确拿到 AspNetUsers.Id！ \uD83E\uDDE9 技术细节：ClaimTypes.NameIdentifier 是什么？ 它是一个常量字符串： csharp public const string NameIdentifier = \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\"; ASP.NET Core Identity 的 Cookie 登录默认会添加这个 Claim JWT 默认不会添加它（除非你手动加） 但它只是一个普通的 Claim 名称，完全可以在 JWT 中使用 所以你在 JWT 里加它，是合法且安全的。 \uD83C\uDD9A 对比：不统一 vs 统一 场景 不统一的做法 统一的做法 获取用户 ID if (cookie) use NameIdentifier; else if (jwt) use Sub 始终用 NameIdentifier 公共服务（如审计日志） 需判断认证类型 一行代码搞定 未来迁移（如全切 JWT） 大量代码要改 几乎不用改 ✅ 最佳实践示例 JWT 生成（Login API） csharp var tokenDescriptor = new SecurityTokenDescriptor { Subject = new ClaimsIdentity(new[] { new Claim(ClaimTypes.NameIdentifier, user.Id), // ← 统一关键 new Claim(ClaimTypes.Name, user.UserName) }), Expires = DateTime.UtcNow.AddDays(7), SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256) }; 任意控制器中获取用户 ID csharp [Authorize] public class AnyController : ControllerBase { public IActionResult GetUserData() { string? userId = User.FindFirstValue(ClaimTypes.NameIdentifier); // 无论 Cookie 还是 JWT，都能拿到！ return Ok(new { UserId = userId }); } } ⚠️ 注意事项 不要混用 sub 和 NameIdentifier：选一个，坚持到底。 确保 JWT 配置正确：AddJwtBearer 不会自动映射 sub 到 NameIdentifier，除非你配置了 TokenValidationParameters 的 NameClaimType。 csharp // 可选：让 JWT 的 \"sub\" 自动变成 NameIdentifier services.AddAuthentication(...) .AddJwtBearer(options => { options.TokenValidationParameters = new TokenValidationParameters { NameClaimType = ClaimTypes.NameIdentifier // ← 这样 JWT 的 \"sub\" 会被当作 NameIdentifier }; }); 但这种方式稍复杂，直接在 Token 里写 NameIdentifier 更直观。 ✅ 总结 “统一使用 ClaimTypes.NameIdentifier” = 让 Cookie 和 JWT 在应用层表现一致，简化代码，提高可维护性。 只要你在生成 JWT 时显式加入 new Claim(ClaimTypes.NameIdentifier, user.Id)，后续所有代码就可以无差别地使用： csharp User.FindFirstValue(ClaimTypes.NameIdentifier) 来获取当前用户的 AspNetUsers.Id，无论认证方式是什么。 这正是企业级应用中“关注点分离”和“一致性设计”的体现。"
  },
  "ASP-NET-Core/身份认证/2.html": {
    "href": "ASP-NET-Core/身份认证/2.html",
    "title": "| CZQDocs",
    "summary": "是的！✅ 完全正确。 \uD83D\uDD0D User.FindFirstValue(ClaimTypes.NameIdentifier) 的本质： 它 直接从当前 HTTP 请求的认证票据（Authentication Ticket）中读取 Claim，而这个票据来源取决于你使用的认证方式： 认证方式 票据存储位置 User 数据来源 Cookie 认证（Identity 默认） 浏览器 Cookie（如 .AspNetCore.Identity.Application） 解密 Cookie 后得到的 Claims JWT Bearer 认证 HTTP Header Authorization: Bearer 解码并验证 JWT 后提取的 Claims \uD83D\uDCCC User（即 HttpContext.User）是一个 ClaimsPrincipal 对象，它在请求进入时由 ASP.NET Core 的认证中间件（Authentication Middleware）自动填充。 所以： csharp string? userId = User.FindFirstValue(ClaimTypes.NameIdentifier); 这行代码： 不访问数据库 不调用 UserManager 只是从内存中已解析的 Claims 里找一个值 性能极高（O(1) 或 O(n) 遍历少量 Claims） \uD83E\uDDEA 举个例子 场景 1：Cookie 登录 用户登录后，服务器生成加密 Cookie，里面包含： json { \"claims\": [ { \"type\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\", \"value\": \"64b4ef52-...\" }, { \"type\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\", \"value\": \"123\" } ] } 下次请求时，浏览器自动带上 Cookie ASP.NET Core 解密 Cookie → 构造 ClaimsPrincipal → 赋值给 HttpContext.User 你的代码调用 FindFirstValue(...) → 直接返回 \"64b4ef52-...\" 场景 2：JWT 登录 客户端在 Header 中发送： http Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.xxxxx JWT Payload（解码后）包含： json { \"nameid\": \"64b4ef52-...\", \"unique_name\": \"123\", \"exp\": 1730000000 } （其中 nameid 是 ClaimTypes.NameIdentifier 的简写形式） ASP.NET Core 验证 JWT → 提取 Claims → 构造 ClaimsPrincipal 你的代码同样通过 FindFirstValue(...) 拿到 \"64b4ef52-...\" ✅ 总结一句话： User.FindFirstValue(ClaimTypes.NameIdentifier) 就是从当前请求的认证凭证（Cookie 或 JWT）中直接读取用户 ID，不查库、不计算、零开销。 \uD83D\uDCA1 使用建议： 优先使用这种方式获取用户 ID，而不是 _userManager.GetUserAsync(User)（后者会查数据库） 确保在生成认证凭证时正确写入了该 Claim： Cookie：Identity 自动处理 ✅ JWT：你必须手动添加 new Claim(ClaimTypes.NameIdentifier, user.Id) ✅ 这样你的系统就能高效、一致地工作在混合认证环境下。"
  },
  "ASP-NET-Core/身份认证/JWT.html": {
    "href": "ASP-NET-Core/身份认证/JWT.html",
    "title": "| CZQDocs",
    "summary": "非常好的问题！理解 JWT 签名（Signature） 是掌握 JWT 安全机制的核心。我们来用通俗易懂的方式，结合技术细节，彻底讲清楚它的工作原理。 \uD83D\uDD10 一句话解释 JWT 签名 签名 = 用密钥对 Header + Payload 做“指纹计算”，确保内容未被篡改。 即使别人能看懂 Token 内容，也无法伪造或修改而不被发现。 \uD83E\uDDE9 JWT 的三段结构回顾 一个 JWT 长这样： xxxxx.yyyyy.zzzzz 部分 说明 xxxxx Header（Base64Url 编码）→ 描述算法和类型 yyyyy Payload（Base64Url 编码）→ 用户数据（Claims） zzzzz Signature（签名）→ 由服务端生成，用于验证完整性 \uD83D\uDD0D 签名是如何生成的？（以 HS256 为例） 假设你使用的是 HMAC-SHA256 算法（最常见于对称密钥场景）： 步骤 1：准备原始数据 text base64UrlEncode(header) + \".\" + base64UrlEncode(payload) 例如： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjMiLCJuYW1lIjoiQWxpY2UifQ 步骤 2：用服务端密钥（secret） 对上述字符串做 HMAC-SHA256 运算 csharp // 伪代码 string signature = HMACSHA256( data: \"eyJhbGci...Alice\", key: \"your-super-secret-key\" // ← 只有你的服务器知道！ ); 步骤 3：将结果 Base64Url 编码 → 得到 Signature 部分 最终 Token： Header.Payload.Signature ✅ 为什么签名能防篡改？ 场景：攻击者想把用户 ID 从 \"123\" 改成 \"456\" 他解码 Payload，改成： json { \"sub\": \"456\", \"name\": \"Alice\" } 重新编码为 new_payload 拼接新字符串：header + \".\" + new_payload 但他不知道你的 secret 密钥！ 他随便生成一个签名（比如乱写一通），发给你的服务器 服务器收到后怎么做？ 用同样的 secret 对 header + \".\" + new_payload 重新计算签名 比较计算出的签名 vs Token 中的签名 不一致！→ 直接拒绝请求（401 Unauthorized） \uD83D\uDD12 只要 secret 不泄露，攻击者永远无法生成合法签名。 \uD83D\uDD11 签名算法类型 类型 全称 特点 适用场景 HS256 HMAC-SHA256 对称加密：签发和验证用同一个密钥 单体应用、内部系统 RS256 RSA-SHA256 非对称加密：私钥签名，公钥验证 分布式系统、OAuth 2.0（如 Auth0、Google） 举例：ASP.NET Core 常用 HS256 csharp var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(\"my_secret_123!\")); var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256); ⚠️ 签名不能做什么？ 能力 说明 ✅ 防篡改 内容一旦被改，签名失效 ✅ 验证来源 只有用正确 secret 才能签出合法 Token ❌ 不加密内容 Payload 仍是明文（Base64 可轻松解码） ❌ 不防重放 攻击者可原样转发 Token（需配合 exp、jti 等缓解） \uD83D\uDCCC 所以：敏感数据不要放 Payload！用 HTTPS 防窃听！ \uD83D\uDEE1 实际安全建议 密钥（secret）必须保密 不要硬编码在代码中 使用环境变量、Azure Key Vault、AWS Secrets Manager 等 始终用 HTTPS 防止 Token 在传输中被截获（即使内容不敏感，Token 本身是“钥匙”） 设置合理过期时间（exp） 减少 Token 泄露后的风险窗口 不要依赖“隐藏 ID”做安全 即使别人知道用户 ID，也要靠权限校验（如“只能操作自己的数据”） \uD83C\uDF30 举个生活化例子 想象 JWT 是一封带防伪印章的介绍信： Header：信纸抬头（“本信使用红色印章”） Payload：内容（“兹证明张三，ID:123，可进入机房”）→ 谁都能看 Signature：只有公司有这枚印章，盖在信上 小偷可以复印这封信，甚至把“张三”改成“李四”， 但他没有真印章，保安一看印章不对 → 直接拒之门外！ ✅ 总结 关键点 说明 签名目的 确保 Token 内容未被篡改 如何工作 用密钥对 Header+Payload 做哈希，生成唯一“指纹” 安全性依赖 密钥（secret）的保密性 不能替代 加密（用 JWE）或权限控制 \uD83D\uDCA1 记住：JWT 签名 = 防伪标签，不是保险箱。 只要你保管好 secret，并配合 HTTPS 和权限校验，JWT 就是非常安全的身份传递机制。 是的！你提出了一个极其关键的安全问题，这正是 JWT（或任何认证令牌）使用中最常见的风险之一： ✅ 虽然 JWT 无法被篡改（thanks to 签名），但如果攻击者窃取了你的 Token，他就可以“冒充你”执行所有你能执行的操作——直到 Token 过期。 这就是所谓的：Token 被盗用（Token Theft / Replay Attack）。 \uD83D\uDD25 举个真实场景 假设： 你登录系统后，拿到一个 JWT Token 这个 Token 有效期 7 天 攻击者通过以下方式获取了你的 Token： 你在一个不安全的 Wi-Fi 下访问网站（未用 HTTPS） 前端代码不小心把 Token 打印到控制台或日志 XSS 漏洞让恶意脚本读取了 localStorage 中的 Token 服务器日志意外记录了 Authorization Header 那么攻击者就可以： http GET /api/my-license HTTP/1.1 Authorization: Bearer <你的Token> → 成功获取你的许可证信息 → 甚至可以： 修改你的资料 删除你的数据 以你的身份下单、转账（如果权限允许） \uD83D\uDEA8 这不是“非客户的操作”，而是“完全冒充你”的操作！ ❌ 为什么说“无法篡改 ≠ 安全”？ 特性 说明 ✅ 防篡改 攻击者不能把 \"sub\":\"userA\" 改成 \"sub\":\"admin\" ❌ 不防重放 攻击者可以原封不动地重复使用你的合法 Token \uD83D\uDD10 签名保证的是“完整性”，不是“机密性”或“不可重用性”。 ✅ 如何防御 Token 被盗用？（最佳实践） 强制使用 HTTPS 防止 Token 在传输中被中间人窃听 这是最基本、最重要的防线！ 缩短 Token 有效期（exp） csharp // 例如：只给 15 分钟 expires: DateTime.UtcNow.AddMinutes(15) 即使被盗，攻击窗口很短 配合 Refresh Token 机制 实现“静默续期” \uD83D\uDCA1 用户无感知，但安全性大幅提升。 敏感操作要求二次验证 修改密码、大额支付 → 要求重新输入密码或短信验证码 即使有 Token，也不能直接操作 绑定 Token 到客户端特征（可选，高级） 在签发 Token 时加入额外 Claim： csharp new Claim(\"ip\", userIpAddress), new Claim(\"ua\", userAgentHash) 验证时检查当前请求的 IP/User-Agent 是否匹配。 ⚠️ 缺点：用户换网络或升级浏览器就会失效，体验差。一般用于银行级应用。 实现 Token 黑名单（用于提前吊销） 用户点击“退出登录”时，将 Token 加入 Redis 黑名单（直到过期） 每次请求检查是否在黑名单中 \uD83D\uDCCC 注意：这违背了 JWT “无状态” 的初衷，但在高安全场景下值得。 前端安全存储 Token 存储方式 风险 建议 localStorage 易受 XSS 攻击 ❌ 不推荐 sessionStorage 同上 ❌ HttpOnly Cookie XSS 无法读取 ✅ 推荐（配合 CSRF 防护） \uD83C\uDF10 如果是纯 API（如 App 调用），App 可安全存储 Token；如果是 Web，优先考虑 Cookie + SameSite。 最小权限原则 Token 中的用户权限应尽可能小 例如：普通用户 Token 不应包含 admin 角色 即使被盗，危害有限 \uD83D\uDEE1 总结：JWT 安全的核心思想 风险 防御措施 Token 被窃听 ✅ 强制 HTTPS Token 长期有效 ✅ 短有效期 + Refresh Token 被盗后无限使用 ✅ 黑名单 / 绑定设备（按需） XSS 导致泄露 ✅ HttpOnly Cookie 存储 越权操作 ✅ 严格的权限校验 + 敏感操作二次验证 \uD83D\uDCA1 最后强调 JWT 本身是安全的，但“持有 Token = 拥有身份”。 你的系统安全不仅取决于 JWT 的签名机制，更取决于： 如何保护 Token 不被泄露 如何限制 Token 的权限和生命周期 如何在业务层做细粒度权限控制 所以你说得完全正确：“虽然无法篡改，但可以利用该 Token 进行（冒充用户的）操作” —— 这正是所有基于 Token 的认证系统必须面对的核心挑战。 只要做好上述防护，就能在可用性和安全性之间取得良好平衡。\uD83D\uDD12"
  },
  "ASP-NET-Core/身份认证/身份认证.html": {
    "href": "ASP-NET-Core/身份认证/身份认证.html",
    "title": "| CZQDocs",
    "summary": "# \uD83D\uDD27 ASP.NET Core Identity + JWT 登录失败问题总结与修复方案 ## ❗ 问题核心 你的应用同时启用了 **Cookie 身份认证（ASP.NET Core Identity）** 和 **JWT Bearer 认证**，但登录成功后浏览器未收到 `.AspNetCore.Identity.Application` Cookie，导致 `User.Identity.IsAuthenticated == false`。 --- ## \uD83E\uDDE8 根本原因 ```csharp builder.Services.AddAuthentication(options => { options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme; }) 默认认证方案被设置为 JWT Bearer，而非 Cookie。 Identity 的登录机制依赖 Cookie，但认证中间件不会处理 Cookie 登录状态。 ✅ 正确做法：支持多种认证方案 ✅ 第一步：修改 AddAuthentication，保留 Cookie 为默认方案 builder.Services.AddAuthentication(options => { options.DefaultScheme = IdentityConstants.ApplicationScheme; // Cookie options.DefaultSignInScheme = IdentityConstants.ApplicationScheme; options.DefaultChallengeScheme = IdentityConstants.ApplicationScheme; }) .AddJwtBearer(options => { options.TokenValidationParameters = new TokenValidationParameters { ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)) }; }); ✅ 第二步：在 API 控制器中显式指定 JWT 认证 [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)] public class MyApiController : ControllerBase { // 只接受 JWT } 或使用策略： builder.Services.AddAuthorization(options => { options.AddPolicy(\"RequireJwt\", policy => { policy.AuthenticationSchemes.Add(JwtBearerDefaults.AuthenticationScheme); policy.RequireAuthenticatedUser(); }); }); [Authorize(Policy = \"RequireJwt\")] ✅ 第三步（推荐）：确保 Identity UI 使用 Cookie 登录 Identity 的登录、注册等页面必须使用 Cookie 认证。 不要让 JWT 成为全局默认方案，除非你完全不用 Cookie 登录。 ✅ 验证修复效果 清除浏览器所有 Cookie。 访问 /Identity/Account/Login，输入账号密码登录。 登录后应跳转到首页，顶部显示用户名 + “登出”。 打开开发者工具 → Application → Cookies，确认存在： 名称：.AspNetCore.Identity.Application 值：非空 同时，API 仍可通过 Authorization: Bearer xxx 正常访问（只要加了 [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]）。 \uD83D\uDD12 补充建议 场景 建议 只做 Web 应用（无 API） 移除 JWT 配置 混合使用 Web + API 按上述方式配置多方案认证 ✅ 总结 问题原因 解决方案 DefaultScheme = JwtBearer 导致 Cookie 登录无效 改为 DefaultScheme = IdentityConstants.ApplicationScheme Identity 登录后无 Cookie 确保认证中间件能处理 Cookie 页面不显示用户信息 因为 User 实际未认证 完成上述修改后，你的登录功能应该就能正常显示用户名了！ 如需进一步帮助（比如如何保护特定 API 路由），欢迎继续提问。"
  },
  "CSharp/Debug/反编译可执行性文件.html": {
    "href": "CSharp/Debug/反编译可执行性文件.html",
    "title": "最省事的\"一键办法\"：VS 2022 现场反编译调试无 PDB 的 WPF 程序 | CZQDocs",
    "summary": "最省事的\"一键办法\"：VS 2022 现场反编译调试无 PDB 的 WPF 程序 直接让 Visual Studio 现场反编译并生成临时 PDB，然后就能像正常调试一样下断点、看调用堆栈、监视变量，不再需要自己算地址、手敲 RVA。 整个过程不超过 30 秒，完全在 VS 里完成，适用于无 PDB 的任意 .NET WPF 可执行文件（只要代码是托管的）。 一、前置条件（只两条） VS 2022 17.6 及以上（低版本没有内置反编译） 代码未被混淆（变量名可能被优化掉，但方法体还能反编译出来） 二、5 步\"傻瓜式\"流程 启动 VS → 继续但无需代码 → 菜单 Debug → Attach to Process… 在列表里找到你的 WPF 进程（xxx.exe） → Attach to 选： Managed (.NET Core/.NET 5+) 或 Managed (.NET 4.x) 点 Attach 若弹出 \"No symbols\" 警告 → 直接 忽略；随后 Debug → Windows → Modules 在 Modules 窗口里找到你的 xxx.exe（或引用的问题 DLL）→ 右键 → Load Symbols with Source Link → Generate and Load Symbols 注意：老版本按钮叫 \"Decompile and Load Symbols\" ，功能相同 VS 会 现场反编译 IL → 生成临时 PDB → 自动加载，几秒后 Symbols 状态变成 \"Symbols loaded\" 立即打开： Call Stack 窗口 → 双击最上面的帧 → VS 弹出 反编译的 C# 源码 标签页，崩溃行已高亮 想下断点就 直接点左侧灰边，断点变成 实心红点（再也不需要地址） Locals/Watch 也能用，局部变量可能被优化成 \"optimized away\" ，但调用堆栈、this、参数都能看到 三、想提前下断点（还没崩） Debug → New → Breakpoint → Function Breakpoint → 直接输 中文方法名 也行： Xqg统计输出ViewModel.Xqg生成表格() 只要反编译完成，VS 就能解析出来，不需要行号。 四、如果 Attach 时进程已经崩了 File → Open → Project/Solution → 选 xxx.exe → VS 会把它当\"项目\"打开 → F5 直接启动并 Attach → 崩的一瞬间 Call Stack 里就能 双击→看源码。 一句话总结 VS 2022 自带 \"Generate and Load Symbols\" 一键反编译 + 临时 PDB，无 PDB 的 WPF exe 也能像正常项目一样下断点、看调用堆栈，30 秒搞定，再不用手算地址。"
  },
  "CSharp/EditorConfig.html": {
    "href": "CSharp/EditorConfig.html",
    "title": "| CZQDocs",
    "summary": "代码样式规则选项"
  },
  "CSharp/Http/HttpClient.html": {
    "href": "CSharp/Http/HttpClient.html",
    "title": "IHttpClientFactory 优点一览 | CZQDocs",
    "summary": "HttpClient 类 使用 IHttpClientFactory 的最佳实践（.NET） 下面给出两段最常用、可直接复制到 VS 跑起来的 WPF 最小实例，任选其一即可。 方案 A：「DI 容器 + 构造函数注入」——推荐做法 装包 Install-Package Microsoft.Extensions.Http Install-Package Microsoft.Extensions.DependencyInjection App.xaml.cs public partial class App : Application { public static IServiceProvider Services { get; private set; } protected override void OnStartup(StartupEventArgs e) { var services = new ServiceCollection(); ConfigureServices(services); Services = services.BuildServiceProvider(); // 把主窗口交给 DI 解析 var mainWindow = Services.GetRequiredService<MainWindow>(); mainWindow.Show(); base.OnStartup(e); } private void ConfigureServices(IServiceCollection services) { // 1. 注册 IHttpClientFactory services.AddHttpClient(\"GitHub\", c => { c.BaseAddress = new Uri(\"https://api.github.com/\"); c.DefaultRequestHeaders.UserAgent.ParseAdd(\"WpfDemo\"); }); // 2. 注册自己需要的服务 / VM / 窗口 services.AddTransient<MainViewModel>(); services.AddTransient<MainWindow>(); } } MainViewModel.cs public class MainViewModel { private readonly IHttpClientFactory _httpClientFactory; public string Result { get; set; } = \"等待点击…\"; public ICommand LoadCmd { get; } public MainViewModel(IHttpClientFactory httpClientFactory) { _httpClientFactory = httpClientFactory; LoadCmd = new RelayCommand(async () => await LoadAsync()); } private async Task LoadAsync() { var http = _httpClientFactory.CreateClient(\"GitHub\"); Result = await http.GetStringAsync(\"repos/microsoft/dotnet\"); } } MainWindow.xaml（仅放核心） <StackPanel> <Button Content=\"获取 GitHub 仓库信息\" Command=\"{Binding LoadCmd}\" HorizontalAlignment=\"Center\" Padding=\"20,5\"/> <TextBox Text=\"{Binding Result}\" TextWrapping=\"Wrap\" IsReadOnly=\"True\" Margin=\"10\"/> </StackPanel> MainWindow.xaml.cs public partial class MainWindow : Window { public MainWindow(MainViewModel vm) { InitializeComponent(); DataContext = vm; // 通过构造函数注入 VM } } 运行效果：点击按钮 → 用 IHttpClientFactory 创建的客户端去调 GitHub API → 结果直接显示在 TextBox。 小结 WPF 没有内置的通用主机，但只要手动 new ServiceCollection() → AddHttpClient() → BuildServiceProvider()，就能完整享用 ASP.NET Core 那套 IHttpClientFactory 的全部能力。 官方文档同样适用于桌面程序，无需任何额外适配。 IHttpClientFactory 优点一览 > 适用于 WPF、WinForms、MAUI 等桌面客户端，亦适用于 ASP.NET Core。 优点类别 具体说明 对 WPF/桌面开发的意义 1. 连接池与套接字复用 每个命名/类型客户端共享 HttpMessageHandler，自动复用 TCP 连接，避免“套接字耗尽”异常。 长生命周期的桌面应用反复调用 API 时，不会把本地端口占光。 2. 生命周期自动管理 工厂按策略（默认 2 min）回收 Handler，解决 DNS 刷新与连接老化问题；开发者无需手动 Dispose 客户端。 避免“改完 DNS 必须重启程序”的尴尬。 3. 出站策略集中配置 在 AddHttpClient(\"name\") 里统一写 BaseAddress、Header、超时、代理、证书等；换环境只需改一处。 桌面应用同样有测试/生产多环境需求，配置集中好维护。 4. Polly 弹性策略一键集成 与 Microsoft.Extensions.Http.Polly 结合，可链式声明重试、熔断、超时、回退： AddPolicyHandler(...)。 网络抖动常见，桌面端也能“自动重试 3 次再弹错误框”。 5. 日志与遥测开箱即用 内置 ILogger 事件（请求、耗时、状态码），与 Serilog/NLog 等对接即可在本地文件或调试窗口看日志。 排查用户现场问题时有现成的 HTTP 轨迹。 6. 模拟与单元测试友好 注册 HttpMessageHandler 的 Mock 实现即可伪造响应，无需改业务代码；支持 Typed Client 接口注入。 ViewModel 单元测试可脱离真实网络，CI 跑得更快。 7. Typed Client 强类型 把 HttpClient 封装到业务类构造函数，DI 直接注入 MyTypedClient，告别到处写原始 URL。 桌面 MVVM 里 Service/Repository 层同样享受强类型。 8. 性能更高 官方基准：复用 Handler 比每次 new HttpClient() 减少约 60% 内存分配，提升 2~3 倍吞吐。 后台同步任务多、UI 要保持流畅时尤其明显。 9. 与 ASP.NET Core 同一套生态 学习一次，全平台通用；代码可从 Web 项目几乎零改动搬到 WPF/WinForms/Xamarin/MAUI。 团队技能栈统一，减少上下文切换。 一句话总结 IHttpClientFactory = “会复用、易配置、能重试、好测试、省端口、写一次全平台通用”， 在桌面端同样值得第一时间用上。 概念 一句话定义 在 AddHttpClient 里的常见写法（片段） 桌面/WPF 场景举例 地址 (BaseAddress) 把“共同前缀”抽出来，业务代码只写剩余路径。 c.BaseAddress = new Uri(\"https://api.github.com/\"); 测试环境 http://localhost:5000，生产 https://api.company.com——只改配置文件。 Header 每次请求都要带的“元数据”：User-Agent、Authorization、Accept 等。 c.DefaultRequestHeaders.UserAgent.ParseAdd(\"WpfDemo\"); 调用 GitHub 必须带 User-Agent；调用自家 API 带 Authorization: Bearer <token>。 超时 (Timeout) 从发起请求到读完响应的最大等待时间，防“卡死”。 c.Timeout = TimeSpan.FromSeconds(30); 公司内网 API 设 10 秒，外网服务设 30 秒；用户可接受时再弹“网络异常”。 代理 (Proxy) 请求先经过的中间服务器；常用于抓包、翻墙、公司防火墙。 c.Proxy = new WebProxy(\"http://127.0.0.1:8888\"); Fiddler/Charles 抓包调试；企业内网需通过代理出网。 证书 (Certificate) TLS 客户端证书或自定义服务器证书验证逻辑。 c.ClientCertificates.Add(new X509Certificate2(\"client.pfx\", \"pwd\")); 银行 UKey、政府网关要求双向 TLS；测试环境用自签证书需自定义验证回调。 Polly 策略 失败自动重试、熔断、超时、回退等“弹性”组合。 services.AddHttpClient(\"demo\").AddPolicyHandler(retryPolicy); 笔记本休眠恢复后网络瞬断，自动重试 3 次再弹错误框，避免用户立刻看到“请求失败”。 在 .NET 中，HttpClient 的工厂模式（通常指 IHttpClientFactory）的核心作用是解决传统 HttpClient 使用方式带来的资源浪费、Socket 耗尽、DNS 更新不生效等问题，同时提供集中配置、日志集成、生命周期管理、策略扩展（如重试、熔断）等能力。 ✅ 传统 HttpClient 的痛点 // 常见错误用法 var client = new HttpClient(); Socket 耗尽：HttpClient 实现了 IDisposable，但频繁创建/销毁会导致端口占用不释放（TIME_WAIT）。 DNS 不更新：HttpClient 默认复用连接，DNS 变更后不会刷新（长期运行的服务）。 无法集中配置：每个实例需重复设置 BaseAddress、Header、超时等。 难以单元测试：直接依赖具体实现，无法 mock。 ✅ 工厂模式（IHttpClientFactory）的解决方案 池化 Handler，避免 Socket 耗尽 工厂内部复用 HttpMessageHandler（如 SocketsHttpHandler），共享连接池，避免频繁创建连接。 生命周期由工厂管理，不会无限增长。 DNS 定期刷新 通过 HandlerLifetime（默认 2 分钟）定期轮换 Handler，强制重新解析 DNS。 集中配置命名客户端 services.AddHttpClient(\"GitHub\", client => { client.BaseAddress = new Uri(\"https://api.github.com/\"); client.DefaultRequestHeaders.Add(\"User-Agent\", \"MyApp\"); }); 通过名称区分不同配置（如 GitHub API、微信 API），避免重复代码。 集成 Polly 策略（重试、熔断、超时） services.AddHttpClient(\"GitHub\") .AddPolicyHandler(PollyPolicies.RetryAsync()); 通过扩展方法链式配置策略，与业务代码解耦。 日志与诊断 自动集成 ILogger，记录请求耗时、状态码、异常等（通过 HttpClient 的 LoggingScope）。 支持 Typed Client（强类型） public class GitHubService { private readonly HttpClient _client; public GitHubService(HttpClient client) => _client = client; } services.AddHttpClient<GitHubService>(); 通过依赖注入直接注入 HttpClient，无需关心工厂，便于单元测试（mock HttpClient）。 ✅ 总结：工厂模式的 5 大作用 问题工厂模式解决方案 Socket 耗尽池化 Handler，共享连接 DNS 不更新定期轮换 Handler 重复配置命名客户端集中配置 策略扩展集成 Polly（重试、熔断） 测试困难Typed Client + 依赖注入 ❗注意 不要在 AddHttpClient 中直接 new HttpClient()，否则会失去工厂的所有优势。 不要手动管理 HttpClient 的生命周期（由工厂自动处理）。 一句话区别： | 写法 | 拿到的是什么 | 生命周期 | 给谁用 | 典型场景 | |---|---|---|---|---| | services.AddHttpClient(); | IHttpClientFactory | 单例 | 你自己 factory.CreateClient() | 手动创建、随意命名 | | services.AddHttpClient(\"WPF_API\", …) | 命名实例 | 单例 | 你自己 factory.CreateClient(\"WPF_API\") | 一个业务一个配置 | | services.AddHttpClient<LogViewModel>() | Typed Client | 每次 new LogViewModel 时注入专属 HttpClient | 直接注入到 LogViewModel 构造函数 | MVVM、一个类一个客户端 | 1. 第一种：AddHttpClient() 只把 IHttpClientFactory 注册到容器 你在构造函数里注入 IHttpClientFactory，然后 var client = _factory.CreateClient(); // 默认配置 var named = _factory.CreateClient(\"WPF_API\"); // 用命名配置 手动管理 client 的名字、配置、BaseAddress 适合“我要写很多不同地址/不同超时”的场景 2. 第二种：AddHttpClient(\"WPF_API\", …) 仍然是 IHttpClientFactory 模式，只是提前帮你放好一个“命名配置” 使用时： var client = _factory.CreateClient(\"WPF_API\"); 一个名字对应一套 BaseAddress、超时、Header、Handler 等 适合“同一个后端多个业务模块”时给每个模块起个名字 3. 第三种：AddHttpClient<LogViewModel>() 叫做 Typed Client（强类型客户端） 不会给你 IHttpClientFactory，而是直接在你 new LogViewModel 时，把已经配置好的 HttpClient 注入到它的构造函数 public LogViewModel(HttpClient http) // 这里收到的就是专属实例 { _http = http; } 生命周期跟随 LogViewModel（默认 Transient） 配置写法： services.AddHttpClient<LogViewModel>(c => { c.BaseAddress = new Uri(\"https://localhost:7058/\"); c.Timeout = TimeSpan.FromSeconds(10); }) .AddHttpMessageHandler<GlobalHttpExceptionHandler>(); 最适合 MVVM：一个 ViewModel 对应一个 HttpClient，配置、异常处理、重试策略全部封装好，不需要管名字，也不需要手动 CreateClient 一张表记住 调用方式 得到的对象 需不需要名字 推荐场景 AddHttpClient() IHttpClientFactory 需要 手动灵活创建 AddHttpClient(\"xxx\") 同上，只是预配了命名实例 需要 多后端/多配置 AddHttpClient<T>() 直接注入 HttpClient 到 T 的构造函数 不需要 一个 ViewModel/Service 对应一个客户端，最干净 你该选哪个？ WPF + MVVM → 直接 AddHttpClient<LogViewModel>()，** typed client 最省心** 还想共享同一个配置给多个 VM → 先 AddHttpClient(\"WPF_API\",…)，再在 VM 里 factory.CreateClient(\"WPF_API\") 不需要 DI，只想手动创建 → 第一种 把 AddHttpClient<LogViewModel>() 换成你原来的命名写法也行，只是要多写一行 CreateClient(\"WPF_API\")，看你喜欢哪种风格。"
  },
  "CSharp/Http/HttpResponseMessage.html": {
    "href": "CSharp/Http/HttpResponseMessage.html",
    "title": "| CZQDocs",
    "summary": "HttpResponseMessage 类 HttpStatusCode 枚举 HttpResponseMessage.StatusCode 是服务器返回的 HTTP 状态码，类型为枚举 System.Net.HttpStatusCode，告诉你请求“成功还是失败、哪种失败”。 1. 常用值一览（背住这几个就够） 枚举值 数字 含义 OK 200 成功 Created 201 创建成功（POST） NoContent 204 成功但无返回体 BadRequest 400 请求参数错误 Unauthorized 401 未登录/令牌失效 Forbidden 403 登录了但无权限 NotFound 404 资源不存在 Conflict 409 冲突（如重复键） InternalServerError 500 服务器内部错误 BadGateway 502 网关/代理错误 ServiceUnavailable 503 服务器暂不可用 2. 代码里怎么用 var resp = await client.PostAsync(\"/api/log\", content); // 方法 1：直接判断 if (resp.StatusCode == HttpStatusCode.OK) { ... } // 方法 2：快速“成功”判定（2xx 都算） resp.EnsureSuccessStatusCode(); // 非 2xx 会抛 HttpRequestException // 方法 3：switch 精细化处理 switch (resp.StatusCode) { case HttpStatusCode.OK: var dto = await resp.Content.ReadFromJsonAsync<LogDto>(); break; case HttpStatusCode.BadRequest: var bad = await resp.Content.ReadAsStringAsync(); MessageBox.Show($\"参数错误：{bad}\"); break; case HttpStatusCode.Unauthorized: // 跳登录 break; default: // 其他统一处理 break; } 3. 数字 ↔ 枚举互转 HttpStatusCode code = resp.StatusCode; int numeric = (int)code; // 200 HttpStatusCode back = (HttpStatusCode)numeric; 4. 小结 StatusCode 是 第一手可判断依据； EnsureSuccessStatusCode() 图省事，但 不会给你细节； 对 4xx/5xx 做 分支处理，才能给出友好提示。 下面把 HttpResponseMessage.IsSuccessStatusCode 补进去，并给出它与 EnsureSuccessStatusCode() 的核心区别，方便你“一眼选型”。 5. 更方便的“成功”判定——IsSuccessStatusCode 成员 返回值 抛异常 说明 IsSuccessStatusCode bool ❌ 只判断，不抛；2xx 返回 true，其余 false EnsureSuccessStatusCode() void ✅（HttpRequestException） 非 2xx 直接抛，拿不到响应体 var resp = await client.PostAsync(\"/api/log\", content); // 写法 1：IsSuccessStatusCode —— 想自己掌控流程 if (resp.IsSuccessStatusCode) // 2xx { var dto = await resp.Content.ReadFromJsonAsync<LogDto>(); } else // 4xx / 5xx { var err = await resp.Content.ReadAsStringAsync(); _logger.LogError(\"服务端返回 {Status}：{Error}\", resp.StatusCode, err); } // 写法 2：EnsureSuccessStatusCode —— 图省事，异常即失败 try { resp.EnsureSuccessStatusCode(); // 2xx 直接过 var dto = await resp.Content.ReadFromJsonAsync<LogDto>(); } catch (HttpRequestException ex) // 非 2xx { // 这里已经读不到响应体，只能看 ex.Message _logger.LogError(ex, \"请求失败\"); } 小结（更新版） 只想知道“成没成功”——用 IsSuccessStatusCode； 想“失败就抛”——用 EnsureSuccessStatusCode()，但丢了响应体； 要精细提示——switch (resp.StatusCode) 或 if (IsSuccessStatusCode) 后再分支。"
  },
  "CSharp/Null.html": {
    "href": "CSharp/Null.html",
    "title": "#nullable enable 和 #nullable disable 详解 | CZQDocs",
    "summary": "#nullable enable 和 #nullable disable 详解 这两个是 C# 8.0 引入的预处理指令，用于**局部控制可空引用类型（Nullable Reference Types）**的编译器检查行为。 核心作用 指令 作用 #nullable enable 为后续代码开启可空引用类型检查（启用警告） #nullable disable 为后续代码关闭可空引用类型检查（禁用警告） 代码示例对比 #nullable disable string name = null; // ✔️ 不警告（检查已关闭） name.Length; // ✔️ 不警告（运行时可能崩溃） #nullable enable string title = null; // ⚠️ 警告 CS8600：不能将 null 转换为非空类型 title?.Length; // ✔️ 正确：使用空条件运算符 string? description = null; // ✔️ 正确：显式声明为可空 description.Length; // ⚠️ 警告 CS8602：可能解引用 null 使用场景 1. 渐进式迁移旧项目 // 新代码启用严格检查 #nullable enable public class NewService { public string Name { get; set; } = null!; // 初始化警告用 null! 抑制 } // 遗留代码保持原样 #nullable disable public class LegacyCode { public string Data { get; set; } // 不检查 } 2. 临时禁用特定代码块 #nullable enable public void Process() { // 复杂逻辑中需要临时关闭 #nullable disable var temp = SomeLegacyMethod(); // 可能返回 null temp.ToString(); // 不警告 #nullable restore // 恢复之前的设置 string result = temp ?? \"default\"; // 重新启用检查 } 相关指令 #nullable enable // 开启检查 #nullable disable // 关闭检查 #nullable restore // 恢复为项目级设置（.csproj 中的配置） #nullable enable warnings // 仅开启警告（不开启注解） #nullable enable annotations // 仅开启注解 .csproj 项目级配置 <PropertyGroup> <Nullable>enable</Nullable> <!-- 全局启用 --> </PropertyGroup> 优先级：文件指令 > 项目配置 最佳实践 ✅ 推荐： 新项目全程启用 #nullable enable 旧项目逐步迁移，逐个文件启用 禁用范围尽可能小，用完立即 restore ❌ 避免： 在整个文件中随意禁用 长期保持混合状态 用 #nullable disable 逃避问题而非解决 总结 这两个指令是精细控制工具，核心目的是帮助开发者在不改变项目整体设置的情况下，灵活处理不同代码段的空引用安全策略。 EF Core 中 DbSet<TodoItem> TodoItems { get; set; } = null!; 详解 这是 EF Core 与 C# 可空引用类型（NRT）结合使用的经典模式。你引用的文档已经说明了核心原因，下面我来深度拆解这个设计背后的逻辑和最佳实践。 一、问题根源：编译器的\"静态盲区\" public class TodoContext : DbContext { public DbSet<TodoItem> TodoItems { get; set; } // ⚠️ CS8618 警告 } 为什么编译器警告？ DbSet<TodoItem> 是非空类型（没有 ?） 属性未在构造函数中初始化 编译器的静态分析看不到基类 DbContext 会通过反射在运行时初始化它 二、null! 解决方案的本质 public DbSet<TodoItem> TodoItems { get; set; } = null!; 这是什么操作？ 组成部分 作用 = null 将属性初始化为 null ! Null 包容运算符：告诉编译器\"别警告，我保证这不会是 null\" 为什么安全？ public class DbContext { public DbContext() { // EF Core 在构造函数中通过反射自动初始化所有 DbSet 属性 foreach (var property in GetType().GetProperties()) { if (property.PropertyType.IsGenericType && property.PropertyType.GetGenericTypeDefinition() == typeof(DbSet<>)) { var dbSet = Set(property.PropertyType.GetGenericArguments()[0]); property.SetValue(this, dbSet); // 这里真正赋值 } } } } 关键点：null! 只是编译期标记，运行时被 EF Core 的真实初始化覆盖，永远不会被观测到 null。 三、四种消除警告的方法详解 文档提到的四种方法，适用场景完全不同： 方法 1：构造函数初始化（推荐用于实体类） public class Customer { public string Name { get; set; } // 非空属性 public Customer(string name) // 构造函数强制初始化 { Name = name ?? throw new ArgumentNullException(nameof(name)); } } 适用场景： ✅ 实体类的非空属性 ✅ 必须确保新创建的对象实例有有效值 ❌ 不适用于 DbSet：无法手动创建 DbSet 实例 方法 2：改为可空类型（不推荐用于 DbSet） public DbSet<TodoItem>? TodoItems { get; set; } // 加上 ? 为什么不推荐？ 每次访问都要 context.TodoItems?.Where(...) 实际上 EF Core 保证它永远不会为 null 增加无意义的安全检查代码 方法 3：使用 Required/NotNull 特性（C# 11+ 推荐） public class TodoContext : DbContext { [SetsRequiredMembers] // 告诉编译器构造函数会初始化所有必需成员 public TodoContext(DbContextOptions<TodoContext> options) : base(options) { } public required DbSet<TodoItem> TodoItems { get; set; } // required 关键字 } 优点： 语义清晰：明确表示\"这是必需的\" 编译器强制：调用者必须初始化（但 EF Core 会自动处理） 方法 4：null! 模式（EF Core 专属最佳实践） public DbSet<TodoItem> TodoItems { get; set; } = null!; 为什么是 DbSet 的最佳选择？ EF Core 7.0+ 已自动抑制此警告，无需手动写 null! 旧版本 EF Core 中，这是最简洁的表达方式 零运行时开销：不生成任何额外代码 符合 EF Core 设计哲学：框架负责初始化 四、EF Core 版本演进 EF Core 版本 行为 推荐写法 6.0 及更早 产生 CS8618 警告 = null!; 或 => Set<TodoItem>(); 7.0+ 自动抑制警告 public DbSet<TodoItem> TodoItems { get; set; } EF Core 7.0+ 的魔法： // 源代码中添加了 [MemberNotNull] 注解 public class DbContext { // 编译器知道构造函数会初始化 DbSet 属性 } 五、完整最佳实践示例 #nullable enable public class TodoItem { public long Id { get; set; } // 实体类：用 required（C# 11+） public required string Name { get; set; } // 或者构造函数初始化（旧版 C#） // public string Name { get; set; } = null!; public bool IsComplete { get; set; } } public class TodoContext : DbContext { // ✅ 现代写法（EF Core 7.0+） public DbSet<TodoItem> TodoItems { get; set; } // ✅ 兼容写法（所有版本） // public DbSet<TodoItem> TodoItems { get; set; } = null!; // ✅ 表达式主体（替代方案） // public DbSet<TodoItem> TodoItems => Set<TodoItem>(); public TodoContext(DbContextOptions<TodoContext> options) : base(options) { } } 六、何时使用 null! 的总结 ✅ 推荐使用 null! 的场景： EF Core 6.0 及更早版本的 DbSet 属性 单元测试中故意设置的\"假装已初始化\"状态 框架通过反射初始化的任何属性（如 ASP.NET Core 的 Controller 属性） ❌ 避免使用 null! 的场景： 实体类的业务属性（用 required 或构造函数） 手动创建的服务类（用依赖注入或构造函数） 任何\"可能真为 null\"的情况（用 ? 或空检查） 核心原则：null! 是框架专属模式，不是业务代码的通用解决方案。它意味着\"框架保证，编译器别管\"。 required 和“可空”是两个正交的概念： 一个解决“必须赋值”的问题，一个解决“能不能存 null”的问题。 下面用一句话+一张表+一段代码彻底分清。 \uD83D\uDD11 一句话 required ＝ “调用者必须给我赋值”（编译器检查是否写了 new X { … }）。 T? ＝ “我里面可以存 null”（编译器检查你是否把 null 当非空用了）。 \uD83D\uDCCA 对照表 写法 能否为 null 调用者是否必须写 编译器是否报警 适用场景 string Name ❌ 不可 null ❌ 不强制 若没赋值→无 旧代码兼容 string? Name ✅ 可 null ❌ 不强制 解引用时报警 可选字段 required string Name ❌ 不可 null ✅ 强制 没写→CS9035 必须给的非空值 required string? Name ✅ 可 null ✅ 强制 解引用时报警 必须给，但可以给 null \uD83E\uDDEA 代码体验 #nullable enable public record Person { public required string Id { get; init; } // 必须给，且不能是 null public required string? Bio { get; init; } // 必须给，但允许显式给 null } // ✅ OK var p1 = new Person { Id = \"123\", Bio = null }; // ❌ CS9035 没给 Id var p2 = new Person { Bio = \"hello\" }; // ❌ CS9035 没给 Bio var p3 = new Person { Id = \"123\" }; // ❌ CS8625 试图把 null 给不可 null 的 Id var p4 = new Person { Id = null!, Bio = \"hi\" }; ✅ 记忆口诀 required → “有没有写” ? → “能不能是 null” 在 引用类型 场景下，is not null 和 != null 几乎等价，但： 值类型/可空值类型 只有 is not null 能编译通过； 运算符重载场景下，is not null 永远只比较引用，不会踩到重载的 != 陷阱； 模式匹配 语法统一，可读性更高。 ✅ 推荐 统一写 is not null / is null —— 语法清晰、不会踩坑、对值类型也通用。 if (obj is not null) { ... } // 推荐 != null 只保留在 旧代码 或 你需要显式调用重载的 != 运算符 的极特殊场景。"
  },
  "CSharp/依赖注入.html": {
    "href": "CSharp/依赖注入.html",
    "title": "| CZQDocs",
    "summary": "单例 A 里保存的是 “当时构造函数里拿到的那一个 B”，但那个 B 本身是 瞬态（Transient），容器不会在 A 的整个生命周期里一直给它同一个 B。 结果： A 永远只有一个（单例）。 A 里用到的 B 只有一次（构造函数那一次），所以 A 看来“始终是一个 B”； 如果后面别的组件再去 _serviceProvider.GetService<B>()，容器会再 new 一个新的 B——这与 A 里保存的那个 不是同一个对象。 \uD83C\uDFAF 一句话总结 单例里引用的瞬态，只在单例构造那一刻被创建一次，因此单例自己看来“B 没变”； 但从容器视角看，B 依旧是瞬态，每次请求都可能给新实例。 ⚠ 副作用（极易踩坑） 瞬态 B 本意为“短生命周期”，却被单例 A 长期引用 → 内存泄漏 / 状态不一致。 如果 B 实现了 IDisposable，容器永远不会调用它的 Dispose，因为单例持有它，直到进程结束。 ✅ 正确做法 让 A 不要直接依赖 B，而是依赖 IServiceProvider 或 IServiceScopeFactory，在每次方法调用时临时解析： public class A : IA { private readonly IServiceScopeFactory _scopeFactory; public A(IServiceScopeFactory scopeFactory) { _scopeFactory = scopeFactory; } public void Do() { using var scope = _scopeFactory.CreateScope(); var b = scope.ServiceProvider.GetRequiredService<B>(); b.Work(); } } 或者把 B 也注册成 Scoped / Singleton（只要生命周期 ≥ A 即可）。 \uD83D\uDD16 官方规则 “不要让生命周期长的组件引用生命周期短的组件”—— 违反这条，DI 容器不会报错，但会带来 隐藏 Bug 和 资源泄漏。"
  },
  "CSharp/关键字/Init.html": {
    "href": "CSharp/关键字/Init.html",
    "title": "| CZQDocs",
    "summary": "关键字 init 你给出的这段文字基本准确地描述了 C# 9 引入的 init 访问器的主要用途和效果。不过，为了让它更严谨、更易读，下面给出一份稍作润色的版本，并补充几个常见注意点，方便你日后查阅或写文档时直接使用。 init 访问器（C# 9+） 用途 在属性或索引器中，init 用来定义“仅初始化”访问器。 它允许调用方在对象构造阶段（即对象初始值设定符或构造函数内部）为属性赋值，一旦构造完成，该属性就变成只读，外部代码再也无法修改。 语法示例 public class Person { public string FirstName { get; init; } public string LastName { get; init; } } // 合法：对象初始值设定符 var p = new Person { FirstName = \"Mads\", LastName = \"Torgersen\" }; // 非法：构造完成后赋值 // p.FirstName = \"Anders\"; // 编译期错误 CS8852 与 private set 的区别 private set：构造后仍可在类内部任意修改。 init：构造后任何地方（包括类内部）都不能再写，除非使用反射或其它非常规手段。 与构造函数的对比 传统写法必须显式定义带参构造函数： public Person(string first, string last) { FirstName = first; LastName = last; } 使用 init 后，调用方可继续享受对象初始值设定符的简洁语法，同时获得不可变性保证。 限制与注意 init 访问器只能出现在实例属性/索引器中，不能用于静态成员。 它兼容记录（record） 类型：编译器会自动为 record 的所有 init 属性生成 with 表达式支持。 在构造函数内部，可以多次给 init 属性赋值；但一旦构造函数返回，属性即“冻结”。 一句话总结 init 让你在不牺牲不可变性的前提下，继续用对象初始值设定符这种声明式、可读性高的语法来构造对象；而 private set 只保证“对外只读”，对内依旧可变。 是的，属性一多，record 的 positional 构造函数就会显得冗长，但你有几种方式可以平衡简洁性和不可变性： ✅ 方案 1：用 init 属性（推荐） 你可以把 record 写成“类风格”，保留初始化器语法，不强制用构造函数： public record ZmMessage : IZmMessage { public Code Code { get; init; } public string Message { get; init; } public HttpStatusCode StatusCode { get; init; } // ... 很多其他属性 } 这样你就可以像类一样写： var msg = new ZmMessage { Code = Code.Error, Message = message, StatusCode = statusCode }; ✅ 优点：写法灵活，适合属性多、可选参数多的场景 ⚠️ 缺点：失去了 positional record 的简洁性和解构支持，但仍然是不可变的（init） ✅ 方案 2：用 with 表达式（基于模板对象） 如果你有“默认模板”，可以用 with 快速创建变种： var template = new ZmMessage(Code.Ok, string.Empty, HttpStatusCode.OK); var error = template with { Code = Code.Error, Message = \"Something went wrong\", StatusCode = HttpStatusCode.BadRequest }; ✅ 方案 3：用 Builder 模式（属性特别多时） 如果属性非常多（比如 10+），你可以考虑加一个Builder： var msg = new ZmMessageBuilder() .WithCode(Code.Error) .WithMessage(\"Failed\") .WithStatusCode(HttpStatusCode.BadRequest) .Build(); 适合：属性多、可选参数多、构造逻辑复杂的情况 缺点：需要额外写 Builder 类 ✅ 总结：怎么选？ 属性数量 推荐方式 ≤5 positional record 构造函数 5–10 init 属性 + 初始化器 ≥10 Builder 或 init + with 你可以不强制用 positional 构造函数，record 不是非得写成一行那种。用 init 属性写法和类一样清晰，但仍然是不可变的。"
  },
  "CSharp/关键字/record-with.html": {
    "href": "CSharp/关键字/record-with.html",
    "title": "| CZQDocs",
    "summary": "下面把 with 表达式的行为一次说透，并给出可直接运行的代码片段，方便验证。 作用范围 with 可以“改”两类属性： 位置属性（主构造函数参数） 手动写的标准属性 前提：该属性必须可见且可写（即拥有 init 或 set 访问器）。 只读字段/只 get 属性不会被 with 复制，也不会被修改。 复制深度 with 做的是浅拷贝（shallow copy）。 如果属性是引用类型，原记录和新记录将指向同一个子对象；修改子对象的内容对两边都可见。 代码验证 // 引用类型子对象 public record Address(string City); // 记录包含值类型位置属性 + 引用类型属性 public record Person(string FirstName, string LastName) { public Address Addr { get; init; } // 需要 init 才能出现在 with 里 public int Age { get; set; } // 普通 set 也可以 } var ada = new Person(\"Ada\", \"Lovelace\") { Addr = new Address(\"London\"), Age = 36 }; // with 修改位置属性 + 引用属性 + 普通属性 var alan = ada with { FirstName = \"Alan\", Addr = new Address(\"New York\"), Age = 40 }; // 验证浅拷贝：如果共享引用，修改原对象会影响副本 ada.Addr.City = \"Paris\"; Console.WriteLine($\"ada.Addr.City = {ada.Addr.City}\"); // Paris Console.WriteLine($\"alan.Addr.City = {alan.Addr.City}\"); // New York （已替换为新实例，未受影响） // 验证值类型字段默认复制 Console.WriteLine($\"ada.Age = {ada.Age}, alan.Age = {alan.Age}\"); // 36 vs 40 一句话总结 with 表达式可以同时针对位置属性和显式属性做非破坏性修改，但只复制对象本身一层；引用型子对象默认共享，需要手动在 with 里替换成新实例才能实现“深度不可变”。"
  },
  "CSharp/关键字/record.html": {
    "href": "CSharp/关键字/record.html",
    "title": "| CZQDocs",
    "summary": "Record record 是 C# 9 引入的一个 上下文关键字（contextual keyword），用于声明一种特殊的引用类型，称为 记录类型（record type）。它本质上是一种不可变的、值语义的类或结构体，主要用于表示简单的数据载体（data carrier），比如 DTO、配置对象、消息等。 \uD83D\uDD0D 什么是“上下文关键字”？ record 是 上下文关键字，这意味着： 它 只在特定上下文中被视为关键字（即声明类型时）。 在其他地方，你可以用 record 作为变量名、方法名等（不推荐，但合法）。 int record = 42; // 合法，但不推荐 ✅ 基本语法 public record Person(string FirstName, string LastName); 这行代码等价于： public class Person { public string FirstName { get; init; } public string LastName { get; init; } public Person(string firstName, string lastName) { FirstName = firstName; LastName = lastName; } // 自动生成 Equals, GetHashCode, ToString, Deconstruct, Clone, PrintMembers 等 } \uD83E\uDDE0 核心特性详解 特性 描述 不可变性 属性默认是 init 只读的，只能在构造或初始化器中设置。 值相等性 基于属性值比较，而不是引用地址。 自动解构 支持解构语法，如 var (f, l) = person; with 表达式 支持非破坏性修改：var newPerson = person with { FirstName = \"John\" }; ToString() 自动生成，输出所有属性值，便于调试。 继承支持 record 支持继承，但有一些限制（如不能继承 class）。 \uD83E\uDDEA 示例详解 1. 定义与使用 public record Point(int X, int Y); var p1 = new Point(1, 2); var p2 = new Point(1, 2); Console.WriteLine(p1 == p2); // True，值相等 Console.WriteLine(p1.ToString()); // Point { X = 1, Y = 2 } 2. 使用 with 表达式（非破坏性修改） var p3 = p1 with { X = 5 }; Console.WriteLine(p3); // Point { X = 5, Y = 2 } 3. 解构 var (x, y) = p1; Console.WriteLine($\"x={x}, y={y}\"); \uD83E\uDDF1 record class vs record struct 从 C# 10 开始，支持 record struct： 类型 描述 record 或 record class 引用类型，继承自 System.Object record struct 值类型，继承自 System.ValueType public record struct Point(int X, int Y); ⚠️ 注意事项 record 类型默认是 不可变 的，但你可以手动添加可变属性（不推荐）。 record 类型支持继承，但 record 只能继承自另一个 record，不能继承自普通 class。 record 类型 不能被 class 继承（只能被 record 继承）。 ✅ 总结一句话 record 是 C# 为不可变数据模型提供的语法糖，它让你用一行代码写出值语义、不可变、可解构、可比较、可克隆的“完美 DTO”。 如果你有具体的使用场景（比如：Web API 返回模型、DDD 值对象、消息队列模型等），我可以给你更贴合的示例。 你说得非常准确，这段话已经触及了 record 的一个隐藏陷阱： 计算属性（computed property）在 with 表达式里不会“重新计算”，除非你把它们写成**真正“每次访问都重新计算”**的形式。 \uD83D\uDD0D 举个例子说明问题 public record Sale(decimal UnitPrice, int Quantity) { // ❌ 错误示范：在构造阶段就“算好”总价 public decimal Total { get; init; } = UnitPrice * Quantity; } var s1 = new Sale(10m, 2); var s2 = s1 with { Quantity = 5 }; Console.WriteLine(s2.Total); // 输出 20，而不是 50！ Total 在 构造 s1 时就算好了，with 只复制字段/自动属性，不会重新跑 init 逻辑。 结果 s2.Total 仍然是旧值 20，显然数据不一致。 ✅ 正确做法：让属性每次访问时重新计算 public record Sale(decimal UnitPrice, int Quantity) { // ✅ 真正的计算属性，无状态，每次都算 public decimal Total => UnitPrice * Quantity; } 现在： var s2 = s1 with { Quantity = 5 }; Console.WriteLine(s2.Total); // 输出 50，正确 ✅ 小结（官方文档原意浓缩） 场景 建议 属性值依赖其他成员，且希望 with 后自动反映新值 用 表达式体属性（=>），不要 init 或 set。 属性必须在构造时一次性求值，且后续不再变化 考虑改用 class 并自己管理克隆逻辑，或接受 with 不会重新求值。 \uD83E\uDDE0 一句话记住 在 record 里，只有“每次访问都重新计算”的属性才能保证 with 复制后仍然正确； 一旦你把计算结果“固化”到字段或 init 属性里，with 就不会帮你再算一遍。 如果你有更复杂的计算逻辑（依赖外部服务、缓存等），我们可以一起设计一个线程安全且可克隆的方案。 是的，record 就是 C# 最近几年里“最香”的语法糖之一—— 不可变、值语义、线程安全 写 DTO、消息、配置、领域值对象时几乎零样板代码 with 表达式让你一行代码完成“非破坏性修改”，比手写 Clone+手动赋值舒服太多 从 C# 9 到 12，微软还在持续给它加餐： 版本 新增能力 C# 10 record struct（值类型 record） C# 11 required 成员、字段关键字 file、自动缓存的 record 主构造函数参数 C# 12 主构造函数（record 语法下沉到 class/struct） 一句话：用了就回不去。 下次写 DTO，直接 record 起手，准没错！"
  },
  "CSharp/关键字/record浅的不可变性.html": {
    "href": "CSharp/关键字/record浅的不可变性.html",
    "title": "| CZQDocs",
    "summary": "你说得非常准确，init-only 属性确实只提供“浅不可变性” —— 无论是通过 record 的位置参数，还是手动写的 init 访问器，都只冻结了属性本身的赋值行为，而不会递归冻结引用对象的内容。 ✅ 一句话总结： init-only 冻结的是“绑定”，不是“内容”。 ✅ 示例验证（你提到的数组场景）： var person = new Person(new[] { \"Alice\", \"Bob\" }); // ✅ 合法：修改数组内容 person.Names[0] = \"Charlie\"; // ❌ 非法：不能重新赋值数组 // person.Names = new[] { \"Dave\" }; record Person(string[] Names); ✅ 图解记忆： 类型 能否重新赋值 能否修改内容 string[]（引用类型） ❌ init 后不能 ✅ 可以改元素 int（值类型） ❌ init 后不能 N/A List<string> ❌ init 后不能 ✅ 可以 Add/Clear ImmutableArray<string> ❌ init 后不能 ❌ 内容也不可变（真正的深不可变） ✅ 面试追问准备： 面试官： “如果我想让整个对象图都不可变，怎么办？” 你答： 用 ImmutableArray<T>、ImmutableList<T> 等 System.Collections.Immutable 类型。 或者把属性声明为 record + init + 只读值类型字段，层层嵌套。 终极方案：使用源生成器或 F# 的“真不可变”类型。 需要我给你一个**“深不可变”的代码模板**吗？"
  },
  "CSharp/关键字/required.html": {
    "href": "CSharp/关键字/required.html",
    "title": "| CZQDocs",
    "summary": "required 修饰符 下面把官方文档里散落在各处的“required 成员”规则，汇总成一份一页式速查表。 直接拿来写代码、做 Code Review 或给同事科普都够用。示例用 C# 11 / .NET 7+ 语法。 required 成员（C# 11+）一句话定位 “必须在对象初始值设定项或构造函数里显式赋值（可赋 null），否则编译失败；同时仍保留对象初始值设定符的简洁语法。” 能贴在哪 字段、属性、索引器 class、struct、record、record struct 不能贴在 interface 成员、显式接口实现、位置 record 参数上。 可见性要求 成员的可访问性 ≥ 所在类型的可访问性。 public class Foo { protected required string Bar; // ❌ CS9039 } required 属性必须至少有一个 set 或 init 访问器，且该访问器可见性同样 ≥ 类型可见性。 初始化规则 任何创建实例的表达式（new、with、反射的 Activator.CreateInstance）都必须给所有 required 成员赋值；否则 编译期错误（CS9035）。 可以显式赋 null；对不可为 null 的引用类型会给出 警告（CS8618、CS9036）。 构造函数内部不必再次赋值——只要最终被初始化即可。 继承/重写 派生类 不能用 new 隐藏基类 required 成员。 重写基类 required 属性时，必须保留 required 关键字； 可以在重写时追加 required（基类不是 required，派生类改成 required 是允许的），但不能拿掉。 public class Base { public virtual string Name { get; init; } } public class Derived : Base { public override required string Name { get; init; } // ✅ } 泛型约束死角 如果类型参数有 where T : new() 约束，则 不能 把带 required 成员的类型实参传进去——编译器无法保证泛型代码里会初始化那些成员（CS9034）。 解决：改用 where T : new() => T.Create() 工厂模式，或删掉 new() 约束。 与 record 位置参数的关系 位置参数天生自带“必传”语义，因此 不允许再贴 required。 如果既想要位置语法又想加 required，可手动声明属性： public record Person(string FirstName, string LastName) { public required string MiddleName { get; init; } } 常见错误码速览 | 错误码 | 含义 | | ------ | --------------------------------------------------- | | CS9035 | 忘记在对象初始值设定项里给 required 成员赋值 | | CS9036 | 把不可为 null 的 required 成员显式设成 null | | CS9039 | required 成员可见性比类型低 | | CS9034 | 带 new() 约束的泛型参数使用了含 required 成员的类型 | 一张图记心里 “required = 编译期强制初始化 + 仍享对象初始值设定符； 看不见、去不掉、泛型 new() 要绕开。” 把两个问题拆开说： 一、required 成员 vs“传统构造函数必填参数” 维度 required 成员 构造函数必填参数 调用语法 保留对象初始值设定符的“键值对”风格 new Person { Name = \"Mads\" } 必须走构造函数实参列表 new Person(\"Mads\") 参数顺序 无顺序要求，可只填一部分，可混用默认值 顺序固定，全必填时必须一次给齐 向后兼容 新增字段/属性时老代码无需改动 新增参数会导致所有已有调用点编译失败 可组合性 与 with 表达式天然友好 需要手写 Copy 构造或工厂方法 反射/序列化 需要无参构造+ 赋值路径 需要匹配签名的构造 性能 多一次赋值（先 0 再写值） 直接进字段，理论少一次写 一句话： “required 成员把‘语法糖’留给你，把‘必填’留给编译器； 构造函数参数把‘必填’和‘语法’都硬编码在方法签名里。” 二、与 JSON 反序列化共舞（System.Text.Json） 必备前提 必须有无参构造函数——无论 public 还是 internal，否则反序列化器连对象都造不出来。 版本要求 .NET 7 起：内置支持 required 成员（JsonSerializer.Deserialize 会检查 required 并抛 JsonException）。 .NET 6 及以前：不认 required，漏字段不会报错，需要自定义 JsonConverter 或迁移到 .NET 7+。 典型代码 public class Person { public required string Name { get; init; } public int Age { get; init; } = 0; // 非 required，可缺 } string json = \"\"\"{\"Age\":29}\"\"\"; try { var p = JsonSerializer.Deserialize<Person>(json); // .NET 7 会抛 } catch (JsonException ex) when (ex.Message.Contains(\"required\")) { Console.WriteLine(\"缺少 required 字段\"); } 与构造函数参数方案对比 若用“全参构造”： public Person(string name, int age = 0) { ... } 必须写自定义 JsonConstructor 告诉反序列化器把 JSON 属性映射到构造参数： [JsonConstructor] public Person(string name, int age) : this(name) { Age = age; } 每新增一个参数就要改构造，对版本演进不友好。 最佳实践速记 对外 DTO：用 required + 无参构造 → 保持序列化兼容，编译期检查必填。 对内领域对象：若追求极致不可变，可保留“全参构造”+ 私有 init，再写工厂或 JsonConstructor。 升级路径：老项目先补无参构造，再贴 required，最后把 .NET SDK 升到 7+，就能同时得到 ① 编译期检查 ② 反序列化期检查 ③ 对象初始值设定符的清爽语法。 一句话收工 “required 让‘编译器 + 序列化器’帮你一起把关必填字段，而构造函数必填参数只能让‘编译器’把关，还把序列化器拒之门外。” with 表达式（C# 9 起）的底层逻辑是： 先调用当前实例的“无参构造函数”（编译器生成的 protected 拷贝构造）。 再把所有需要改变的属性按名字逐个赋值（普通赋值，不是 init 也不是 set）。 返回一个新实例。 因此，只要属性具备 init 访问器，with 就能写； 而 required 只约束“构造阶段必须赋值”，不限制后续 with 再次赋值—— 因为 with 是在新实例的构造流程里完成写入，正好落在 init 允许的“构造期”时间窗口内。 看代码最直观 public record Person // record 自动给所有 init 属性生成 with 支持 { public required string Name { get; init; } // 必须初始化 public int Age { get; init; } } var p1 = new Person { Name = \"Mads\", Age = 50 }; // 构造阶段满足 required var p2 = p1 with { Age = 51 }; // ✅ 合法 // 编译器生成的大致 IL： // var tmp = new Person(); // 1. 无参构造 // tmp.Name = p1.Name; // 2. 拷贝旧值 // tmp.Age = 51; // 3. 把 Age 改掉 // return tmp; // 4. 构造完成，required 检查通过 对比普通 class（非 record） 即使不是 record，只要属性是 init，你就可以手动写扩展方法或自己调用构造函数 + 对象初始值设定符，但 with 语法糖仅限 record 和 struct 自动享受。 要点不变：init 允许在“构造期”写入，with 正好处于这一时间段，所以两者“天然友好”。"
  },
  "CSharp/关键字/with.html": {
    "href": "CSharp/关键字/with.html",
    "title": "| CZQDocs",
    "summary": "表达式 with - 非破坏性突变创建具有修改属性的新对象 你贴出的示例已经把“with 表达式保持运行时类型”这一核心规则演示得很清楚了—— 无论左侧变量是什么静态类型，with 都会拷贝实际对象的运行时类型，再按对象初始值设定符里的名单改写属性，然后原样返回那个运行时类型的新实例。 一句话记忆： “静态类型只管编译期；with 之后，骨子里（运行时）还是原来的那个‘种’。” 把示例拆开再看一眼： Point p1 = new NamedPoint(\"A\", 0, 0); // 静态类型 Point，运行时类型 NamedPoint Point p2 = p1 with { X = 5, Y = 3 }; // with 克隆的是 NamedPoint Console.WriteLine(p2 is NamedPoint); // True Console.WriteLine(p2); // NamedPoint { X = 5, Y = 3, Name = A } 规则小结（官方一句话版） 左侧操作数可以是 任何 record（class 或 struct） 任何 struct（含元组） 匿名类型 返回的新实例 运行时类型 ≡ 左侧操作数的实际运行时类型（不会向上转成静态类型）。 静态类型 ≡ 左侧操作数的声明类型（编译期推断）。 赋值过程 先调用该运行时类型的受保护拷贝构造函数。 再把 with 里出现的每个属性按名逐个赋值（init-only 属性也可写，因为仍处于构造期）。 边缘情况速记 如果将来在派生层里新增属性，而 with 里写了新增属性，但左侧实际对象是基类实例，会编译失败（CS8857：找不到该成员）。 结构体（record struct 或普通 struct）同样遵守“保持运行时类型”规则，不过值类型没有继承层次，所以运行时类型就是本身。 p1 丝毫没变。 with 表达式做的是不可变快照： 先克隆出一份 新实例（运行时类型与 p1 相同，即 NamedPoint）。 把克隆体的 X、Y 改成 5、3。 返回这份克隆体并赋给 p2。 原对象 p1 的所有字段/属性仍然是 Name = \"A\", X = 0, Y = 0，内存地址、哈希值、只读状态统统保持不变。 一句话： “with 是‘复制-改-返回新’，绝非‘就地改’； 在 record 的世界里，旧值永远冻住。”"
  },
  "CSharp/关键字/常用运算符.html": {
    "href": "CSharp/关键字/常用运算符.html",
    "title": "| CZQDocs",
    "summary": "?? 和 ??= 运算符 - Null 合并操作符 运算符 名称 作用 示例 结果 ?? Null 合并运算符 左值非 null 则返回左值，否则返回右值 a ?? b 若 a == null 则得 b，否则得 a ??= Null 合并赋值运算符 仅当左值为 null 时才把右值赋给左变量 a ??= b 若 a == null 则执行 a = b 一句话记忆： ?? 取默认值；??= 只在 null 时才赋值。"
  },
  "CSharp/关键字/扩展.html": {
    "href": "CSharp/关键字/扩展.html",
    "title": "| CZQDocs",
    "summary": "很高兴听到你通过对 record 关键字的学习，扩展了很多知识点！\uD83C\uDF89 record 虽然只是一个看似简单的语法糖，但它背后其实串联了一系列重要的编程思想和实践： ✅ 你大概率已经接触到的延伸知识 主题 说明 不可变性（Immutability） 理解值类型 vs 引用类型、线程安全、副作用控制 With 表达式 & 非破坏性修改 体验函数式编程风格，避免直接改状态 值相等（Value Equality） 深入 GetHashCode、Equals、IEquatable 的实现 解构（Deconstruct） 熟悉模式匹配、元组、解构赋值 建造者模式 解决多参数构造的整洁性、可读性、可维护性 隐式转换、Fluent API 学习如何设计流畅接口，提升开发体验 模式匹配（Pattern Matching） 与 record 搭配使用，写出更声明式的代码 性能优化 record 的编译期代码生成、内存分配、struct record 的栈上分配等 ✅ 推荐继续深入的方向 struct record vs class record 了解值类型 record 的内存布局、复制成本、何时选用。 record 与 DDD 值对象 在领域驱动设计中，用 record 快速实现值对象（Value Object），天然支持相等比较。 record 与 With 表达式的性能陷阱 深层嵌套对象时，with 是浅拷贝，理解其边界。 record 与 Source Generator 结合 .NET 的源代码生成器，自动生成 DTO、Builder、Mapper 等模板代码。 record 与函数式编程 探索 F# 的 Discriminated Union、C# 的 Discriminated Union（即将推出）与 record 的关系。 ✅ 总结一句话 record 不仅是一个关键字，它是你深入现代 C#、不可变设计、函数式思想、架构整洁性的“钥匙”。 如果你愿意，我可以帮你整理一份**“record 学习路线图”**（分阶段 + 推荐资料），让你继续系统性地深入。需要吗？"
  },
  "CSharp/关键字/扩展1.html": {
    "href": "CSharp/关键字/扩展1.html",
    "title": "| CZQDocs",
    "summary": "下面给你一份**“record 学习路线图”**，分 4 个阶段，每阶段都给出： 目标 必学要点 推荐官方/权威链接（全部来自 Microsoft Docs、GitHub、.NET Blog，可放心点） 配套动手练习 你可以按顺序“打卡”，也可按需跳读。 \uD83D\uDD17 均为 英文原文，如需中文可让浏览器自动翻译。 \uD83D\uDFE2 阶段 1 语法入门（1 天） 目标 把 record 当成“超级结构体”用起来 要点 1. 声明位置记录 / 主构造函数 2. with 表达式 3. 值相等、ToString() 自动生成 官方链接 record types - Microsoft Docs 练习 用 record 重写你项目里任何一个 DTO，然后写单元测试断言相等、with 修改。 \uD83D\uDFE2 阶段 2 不可变 & 模式匹配（1-2 天） 目标 理解不可变语义，结合模式匹配写出声明式代码 要点 1. init-only 属性 2. Deconstruct 解构 3. 位置模式、属性模式、switch 表达式 官方链接 1. Pattern matching - Microsoft Docs 2. Init-only setters 练习 把一段多层 if-else 判断重构成 record + switch 表达式，代码行数减半。 \uD83D\uDFE2 阶段 3 性能与高级场景（2-3 天） 目标 知道 record 背后生成的代码，避开性能坑 要点 1. class vs struct record 2. 浅拷贝与深层嵌套 3. 编译器生成的 IEquatable 、GetHashCode 官方链接 1. Struct record performance 2. Record internals - .NET Blog 练习 用 BenchmarkDotNet 对比 class record / struct record / class 手动实现，看内存分配差异。 \uD83D\uDFE2 阶段 4 架构级实战（持续迭代） 目标 在真实系统里把 record 用“对” 要点 1. DDD 值对象 2. 建造者模式（你已掌握） 3. 与 Source Generator 结合生成 DTO/Mapper 4. 与 Discriminated Union（C# 11 起）配合 官方链接 1. DDD value objects with record 2. Source Generators 3. Discriminated Unions preview 练习 1. 把微服务中所有 Value Object 改成 record，并写单元测试保证相等性。 2. 用 Source Generator 为 record 自动生成 Builder & Mapper。 \uD83C\uDFAF 额外资源（随时查阅） 类型 链接 语言规范 C# 11 draft - Records 性能深潜 Performance in .NET 7 - Struct records 视频（BUILD 2021） C# 10: Records in Action ✅ 打卡模板（可复制到备忘录） [ ] 阶段 1 读完官方文档并写完 DTO 替换 [ ] 阶段 2 用 switch 表达式重构 if-else [ ] 阶段 3 BenchmarkDotNet 跑分并写总结 [ ] 阶段 4 把项目 Value Object 全改成 record + Builder 完成每一行后打勾，你就能系统地把 record 从语法 → 性能 → 架构 全链路吃透。 遇到任何步骤需要代码示例或中文讲解，随时 @ 我！"
  },
  "CSharp/关键字/概述.html": {
    "href": "CSharp/关键字/概述.html",
    "title": "| CZQDocs",
    "summary": "C# 关键字"
  },
  "CSharp/字符串/JSON.html": {
    "href": "CSharp/字符串/JSON.html",
    "title": "| CZQDocs",
    "summary": "在 .NET 中，JSON 序列化是将 .NET 对象转换为 JSON 字符串，以及将 JSON 字符串转换为 .NET 对象的过程。.NET 提供了多种 JSON 序列化库，最常用的是 System.Text.Json 和 Newtonsoft.Json（也称为 Json.NET）。 以下是关于这两种主流库的简要介绍和使用示例： System.Text.Json（推荐，现代 .NET 的首选） 这是 .NET Core 3.0+ 内置的高性能 JSON 库，位于 System.Text.Json 命名空间中。它是跨平台的，性能优秀，且与 .NET 生态深度集成。 基本用法 using System; using System.Text.Json; public class Person { public string Name { get; set; } public int Age { get; set; } } class Program { static void Main() { // 序列化对象为 JSON var person = new Person { Name = \"Alice\", Age = 30 }; string json = JsonSerializer.Serialize(person); Console.WriteLine(json); // 输出: {\"Name\":\"Alice\",\"Age\":30} // 反序列化 JSON 为对象 string jsonInput = \"{\\\"Name\\\":\\\"Bob\\\",\\\"Age\\\":25}\"; Person person2 = JsonSerializer.Deserialize<Person>(jsonInput); Console.WriteLine(person2.Name); // 输出: Bob } } 高级选项 你可以通过 JsonSerializerOptions 控制序列化行为： var options = new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase, // 属性名转为 camelCase WriteIndented = true // 格式化输出 }; string json = JsonSerializer.Serialize(person, options); 属性映射 使用 [JsonPropertyName] 特性指定 JSON 属性名： csharp public class Person { [JsonPropertyName(\"full_name\")] public string Name { get; set; } } Newtonsoft.Json（Json.NET，广泛使用） 这是最流行的第三方 JSON 库，功能非常强大，支持更复杂的场景（如动态对象、LINQ to JSON 等）。 安装 通过 NuGet 安装： bash Install-Package Newtonsoft.Json 基本用法 using Newtonsoft.Json; // 序列化 string json = JsonConvert.SerializeObject(person); // 反序列化 Person person = JsonConvert.DeserializeObject<Person>(json); 高级功能 支持 JsonProperty 特性 支持 JsonObject、JObject 等动态解析 更灵活的日期格式、空值处理等 public class Person { [JsonProperty(\"full_name\")] public string Name { get; set; } } `` 如何选择？ 特性 System.Text.Json Newtonsoft.Json ------ --------------------- ------------------- 性能 更快 稍慢 内置 .NET 3.0+ 需要 NuGet 包 功能丰富度 基础功能完善 功能更全面 兼容性 推荐新项目 旧项目或复杂需求 建议：新项目优先使用 System.Text.Json，除非需要 Newtonsoft.Json 的特定功能（如 ShouldSerializeXxx 方法、部分动态特性等）。 注意事项 确保类的属性有 public 的 getter 和 setter。 处理循环引用时需配置选项。 注意日期、枚举、空值的序列化行为。 如果你有具体的序列化需求（如日期格式、忽略属性、自定义转换器等），可以进一步说明，我可以提供更详细的代码示例。"
  },
  "CSharp/字符串/Jobject.html": {
    "href": "CSharp/字符串/Jobject.html",
    "title": "| CZQDocs",
    "summary": "在 C# 中，当你使用 JSON.NET（也就是 Newtonsoft.Json 这个库）来处理 JSON 数据时，JObject 是一个非常核心的类。它代表了一个 JSON 对象，也就是键值对的集合，类似于 JavaScript 中的对象或 C# 中的 Dictionary<string, object>。 ✅ 什么是 JObject？ JObject 是 Newtonsoft.Json.Linq 命名空间下的一个类，属于 LINQ to JSON 的一部分。它允许你动态地创建、修改和查询 JSON 数据，而不需要事先定义对应的 C# 类。 ✅ 常见用途 用途 示例说明 解析 JSON 字符串 JObject.Parse(jsonString) 创建 JSON 对象 new JObject { [\"name\"] = \"Alice\" } 读取字段值 jo[\"name\"].ToString() 修改字段值 jo[\"age\"] = 30; 嵌套对象 jo[\"address\"] = new JObject { [\"city\"] = \"Beijing\" }; 转换为字符串 jo.ToString() 或 jo.ToString(Formatting.Indented) ✅ 示例代码 using Newtonsoft.Json.Linq; string json = @\"{ 'name': 'Alice', 'age': 25, 'skills': ['C#', 'JSON'] }\"; // 解析 JSON 字符串 JObject jo = JObject.Parse(json); // 读取数据 string name = jo[\"name\"].ToString(); // Alice int age = (int)jo[\"age\"]; // 25 // 修改数据 jo[\"age\"] = 26; // 添加新字段 jo[\"email\"] = \"alice@example.com\"; // 嵌套对象 jo[\"address\"] = new JObject { [\"city\"] = \"Shanghai\", [\"zip\"] = \"200000\" }; // 输出格式化后的 JSON Console.WriteLine(jo.ToString(Newtonsoft.Json.Formatting.Indented)); ✅ 输出结果 { \"name\": \"Alice\", \"age\": 26, \"skills\": [ \"C#\", \"JSON\" ], \"email\": \"alice@example.com\", \"address\": { \"city\": \"Shanghai\", \"zip\": \"200000\" } } ✅ 总结一句话 JObject 是 C# 中处理动态 JSON 的利器，适合在你不想或不方便定义强类型类的时候使用。 如果你有具体的使用场景（比如读取 API 返回、修改配置、生成 JSON 文件等），我可以给你更贴合的示例。"
  },
  "CSharp/字符串/Newtonsoft.Json.html": {
    "href": "CSharp/字符串/Newtonsoft.Json.html",
    "title": "| CZQDocs",
    "summary": "Newtonsoft.Json（Json.NET）库的详细讲解，涵盖 日期格式、忽略属性 和 自定义转换器（Custom Converter） 的用法。 日期格式 (Date Formatting) 在 Newtonsoft.Json 中，有多种方式可以控制 DateTime 类型的序列化格式。 方法一：使用 JsonSerializerSettings 全局设置（推荐） using Newtonsoft.Json; var settings = new JsonSerializerSettings { Formatting = Formatting.Indented, // 美化输出 DateFormatString = \"yyyy-MM-dd HH:mm:ss\", // 自定义日期格式 DateTimeZoneHandling = DateTimeZoneHandling.Unspecified, // 保持原始时区信息 NullValueHandling = NullValueHandling.Ignore // 忽略 null 值 }; // 序列化 string json = JsonConvert.SerializeObject(yourObject, settings); ✅ 优点：全局统一，代码简洁。 方法二：使用 [JsonConverter] 特性（属性级别） using Newtonsoft.Json; using Newtonsoft.Json.Converters; public class Event { public string Name { get; set; } [JsonConverter(typeof(DateFormatConverter), \"dd/MM/yyyy\")] public DateTime StartDate { get; set; } } ⚠️ 注意：DateFormatConverter 是 Newtonsoft.Json 内置的转换器，但仅适用于 DateTime，且不支持 DateTime?。 方法三：自定义 DateTime 转换器（最灵活） using Newtonsoft.Json; using System; public class CustomDateTimeConverter : JsonConverter<DateTime> { private const string Format = \"yyyy年MM月dd日 HH:mm\"; public override void WriteJson(JsonWriter writer, DateTime value, JsonSerializer serializer) { writer.WriteValue(value.ToString(Format)); } public override DateTime ReadJson(JsonReader reader, Type objectType, DateTime existingValue, bool hasExistingValue, JsonSerializer serializer) { var value = reader.Value?.ToString(); return DateTime.ParseExact(value, Format, null); } } public class Event { public string Name { get; set; } [JsonConverter(typeof(CustomDateTimeConverter))] public DateTime StartDate { get; set; } } 忽略属性 (Ignoring Properties) 方法一：[JsonIgnore] —— 无条件忽略 csharp public class User { public string Name { get; set; } [JsonIgnore] // 永远不会序列化 public string Password { get; set; } public int Age { get; set; } } 方法二：[JsonProperty] + NullValueHandling public class Product { public string Name { get; set; } [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public string Description { get; set; } [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public int Stock { get; set; } = 0; } NullValueHandling.Ignore：当值为 null 时忽略该属性。 DefaultValueHandling.Ignore：当值为默认值（如 0, false）时忽略。 方法三：条件性忽略方法（ShouldSerializeXxx） public class Person { public string Name { get; set; } public string Email { get; set; } // 只有当 Email 不为 null 时才序列化 public bool ShouldSerializeEmail() { return !string.IsNullOrEmpty(Email); } } ✅ 这是 Newtonsoft.Json 特有的强大功能，System.Text.Json 不支持。 方法四：使用 JsonProperty 控制序列化行为 public class Order { [JsonProperty(Required = Required.Always)] // 反序列化时必须存在 public string OrderId { get; set; } [JsonProperty(Required = Required.AllowNull)] // 允许为 null public string Status { get; set; } } 自定义转换器（Custom Converter） Newtonsoft.Json 的自定义转换器非常灵活，适用于复杂类型、枚举、集合等。 示例：将枚举序列化为字符串名称 步骤 1：定义枚举 public enum Status { Pending, Approved, Rejected } public class Order { public string Id { get; set; } public Status Status { get; set; } } 步骤 2：创建自定义转换器 using Newtonsoft.Json; using System; public class EnumToStringConverter : JsonConverter { public override bool CanConvert(Type objectType) { return objectType.IsEnum; } public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) { writer.WriteValue(value.ToString()); } public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) { var value = reader.Value?.ToString(); return Enum.Parse(objectType, value, true); // 忽略大小写 } } ⚠️ 注意：JsonConverter（无泛型）需要重写 CanConvert 方法。 步骤 3：使用方式 方式 A：在属性上使用 public class Order { public string Id { get; set; } [JsonConverter(typeof(EnumToStringConverter))] public Status Status { get; set; } } 方式 B：在 JsonSerializerSettings 中注册 var settings = new JsonSerializerSettings(); settings.Converters.Add(new EnumToStringConverter()); settings.Formatting = Formatting.Indented; string json = JsonConvert.SerializeObject(order, settings); 更复杂示例：处理 TimeSpan public class TimeSpanConverter : JsonConverter<TimeSpan> { public override void WriteJson(JsonWriter writer, TimeSpan value, JsonSerializer serializer) { writer.WriteValue(value.ToString(@\"hh\\:mm\\:ss\")); } public override TimeSpan ReadJson(JsonReader reader, Type objectType, TimeSpan existingValue, JsonSerializer serializer) { return TimeSpan.Parse(reader.Value.ToString()); } } 总结：Newtonsoft.Json vs System.Text.Json 功能 Newtonsoft.Json System.Text.Json 自定义日期格式 DateFormatString 或 [JsonConverter] 必须自定义 JsonConverter 忽略属性 [JsonIgnore], [JsonProperty], ShouldSerializeXxx [JsonIgnore], DefaultIgnoreCondition 条件忽略 ✅ ShouldSerializeXxx() 方法 ❌ 不支持 自定义转换器 灵活，支持泛型和非泛型 仅支持泛型 JsonConverter 性能 较慢 更快 功能丰富度 极其丰富 基础功能完善 推荐实践 如果你已经使用 Newtonsoft.Json，可以继续使用它，特别是需要 ShouldSerializeXxx 或复杂转换逻辑时。 如果是新项目，建议优先尝试 System.Text.Json，性能更好，集成更紧密。 混合使用也是可行的（例如在 ASP.NET Core 中全局用 System.Text.Json，局部用 Newtonsoft.Json 处理复杂类型）。 如果你有具体的类型或格式需求（如 Guid 转小写、decimal 格式化等），我可以提供对应的 Newtonsoft.Json 自定义转换器示例。"
  },
  "CSharp/字符串/System.Text.Json.html": {
    "href": "CSharp/字符串/System.Text.Json.html",
    "title": "| CZQDocs",
    "summary": "日期格式 (Date Formatting) 默认情况下，System.Text.Json 会使用 ISO 8601 格式（如 \"2025-10-31T16:46:00Z\"）来序列化 DateTime 类型。但很多时候我们希望使用更易读或符合特定规范的格式。 方法一：通过 JsonSerializerOptions 全局设置 using System; using System.Text.Json; var options = new JsonSerializerOptions { WriteIndented = true, // 设置日期格式为 \"yyyy-MM-dd HH:mm:ss\" Converters = { new DateTimeConverter() } }; // 示例类 public class Event { public string Title { get; set; } public DateTime OccurredAt { get; set; } } // 使用 var evt = new Event { Title = \"会议\", OccurredAt = DateTime.Now }; string json = JsonSerializer.Serialize(evt, options); Console.WriteLine(json); // 输出: {\"Title\":\"会议\",\"OccurredAt\":\"2025-10-31 16:46:00\"} 方法二：创建自定义 DateTime 转换器 using System; using System.Text.Json; using System.Text.Json.Serialization; public class DateTimeConverter : JsonConverter<DateTime> { private const string Format = \"yyyy-MM-dd HH:mm:ss\"; public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) { return DateTime.ParseExact(reader.GetString(), Format, null); } public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options) { writer.WriteStringValue(value.ToString(Format)); } } ⚠️ 注意：如果 JSON 中的日期字符串格式不匹配，Read 方法会抛出异常。建议在生产环境中添加异常处理。 忽略属性 (Ignoring Properties) 有时我们不希望某些属性被序列化到 JSON 中，比如敏感信息或临时状态。 方法一：使用 [JsonIgnore] 特性 using System.Text.Json.Serialization; public class User { public string Name { get; set; } [JsonIgnore] // 序列化时忽略此属性 public string Password { get; set; } public int Age { get; set; } } var user = new User { Name = \"Alice\", Password = \"secret123\", Age = 30 }; string json = JsonSerializer.Serialize(user); Console.WriteLine(json); // 输出: {\"Name\":\"Alice\",\"Age\":30} —— Password 被忽略 方法二：条件性忽略（[JsonIgnore(Condition = ...)]） 使用 JsonIgnoreCondition 可以根据值是否为 null、默认值或相等来决定是否忽略。 using System.Text.Json.Serialization; public class Product { public string Name { get; set; } [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)] public string Description { get; set; } [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)] public int? Stock { get; set; } // null 时忽略 } 可用条件： Always：总是忽略 Never：从不忽略 WhenWritingNull：当值为 null 时忽略 WhenWritingDefault：当值为默认值（如 0, null, false）时忽略 方法三：全局忽略 null 值 var options = new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull }; 这会全局忽略所有 null 值的属性。 自定义转换器 (Custom Converter) 当默认的序列化行为无法满足需求时（如枚举转字符串、特殊类型处理、兼容旧格式等），可以编写自定义转换器。 示例：将枚举序列化为字符串而不是数字 默认情况下，枚举会被序列化为整数。我们希望它输出为字符串名称。 步骤 1：定义枚举 public enum Status { Pending, Approved, Rejected } public class Order { public string Id { get; set; } public Status Status { get; set; } } 步骤 2：创建自定义转换器 using System; using System.Text.Json; using System.Text.Json.Serialization; public class EnumToStringConverter<T> : JsonConverter<T> where T : struct, Enum { public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) { var value = reader.GetString(); return (T)Enum.Parse(typeof(T), value, true); // 忽略大小写 } public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options) { writer.WriteStringValue(value.ToString()); } } 步骤 3：使用转换器 方式 A：在属性上使用特性 public class Order { public string Id { get; set; } [JsonConverter(typeof(EnumToStringConverter<Status>))] public Status Status { get; set; } } 方式 B：在 JsonSerializerOptions 中注册 csharp var options = new JsonSerializerOptions(); options.Converters.Add(new EnumToStringConverter<Status>()); var order = new Order { Id = \"O001\", Status = Status.Approved }; string json = JsonSerializer.Serialize(order, options); Console.WriteLine(json); // 输出: {\"Id\":\"O001\",\"Status\":\"Approved\"} 更复杂的自定义转换器示例：处理 TimeSpan public class TimeSpanConverter : JsonConverter<TimeSpan> { public override TimeSpan Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) { return TimeSpan.Parse(reader.GetString()); } public override void Write(Utf8JsonWriter writer, TimeSpan value, JsonSerializerOptions options) { writer.WriteStringValue(value.ToString(@\"hh\\:mm\\:ss\")); } } 然后在属性上使用 [JsonConverter(typeof(TimeSpanConverter))]。 总结 需求 推荐方式 日期格式 创建 JsonConverter 并注册到 options.Converters 忽略属性 使用 [JsonIgnore] 或 [JsonIgnore(Condition = ...)] 自定义逻辑 继承 JsonConverter 实现 Read 和 Write 方法 这些技巧可以让你更灵活地控制 JSON 的输入输出，满足 API 兼容性、可读性或性能需求。如果你有具体的类型或格式需求，我可以提供更针对性的转换器代码。"
  },
  "CSharp/字符串/基本操作.html": {
    "href": "CSharp/字符串/基本操作.html",
    "title": "| CZQDocs",
    "summary": "特殊字符 C# 字符串处理三剑客：@、$ 和 \"\"\" 逐字字符串 (Verbatim Strings) - @ 语法：以 @ 符号开头，后跟双引号包围的字符串。 string path = @\"C:\\Users\\John\\Documents\\file.txt\"; string multiLine = @\"第一行 第二行 第三行\"; 功能： 忽略转义序列：字符串中的反斜杠 \\ 被视为普通字符，不需要转义。这在处理文件路径、正则表达式时非常方便。 支持多行：可以直接换行，换行符会成为字符串的一部分。 限制： 双引号需要转义：如果字符串内部需要包含双引号 \"，必须用两个双引号 \"\" 来表示。 string quote = @\"She said, \"\"Hello!\"\"\"; 格式受限：虽然支持多行，但格式（如缩进）会原样保留，有时不够灵活。 内插字符串 (Interpolated Strings) - $ 语法：以 $ 符号开头，后跟双引号包围的字符串，字符串中使用 {} 包围表达式。 string name = \"Alice\"; int age = 30; string greeting = $\"Hello, {name}! You are {age} years old.\"; // 结果: \"Hello, Alice! You are 30 years old.\" 功能： 嵌入表达式：可以直接在字符串中嵌入变量、属性、方法调用甚至复杂的表达式。 格式化：支持格式说明符。 double price = 123.456; string formatted = $\"Price: {price:C2}\"; // 货币格式，保留两位小数 优势：比 string.Format 或 + 拼接更直观、更易读。 、 原始字符串字面量 (Raw String Literals) - \"\"\" (C# 11+) 如前所述，使用三个双引号 \"\"\" 定界，提供最强大的多行和无转义体验。 组合使用：@、$ 和 \"\"\" 的协同效应 这三种特性可以按特定顺序组合，发挥最大威力。 组合 1: $ + @ (内插 + 逐字) 这是 C# 11 之前的经典组合，用于在逐字字符串中进行内插。 语法：\\(@\"...\" (注意顺序：\\) 在 @ 前) 示例： string directory = \"MyProject\"; string filePath = $@\"C:\\Projects\\{directory}\\config.json\"; // 结果: \"C:\\Projects\\MyProject\\config.json\" string name = \"Bob\"; string sql = $@\" SELECT FROM Users WHERE Name = '{name}' AND Status = 'Active'; \"; 注意：双引号仍需用 \"\" 转义。 组合 2: $ + \"\"\" (内插 + 原始) - 推荐！ C# 11 引入原始字符串后，这是处理复杂内插文本的最佳方式。 语法：\\(\"\"\"...\"\"\" (注意顺序：\\) 在 \"\"\" 前) 优势： 无需转义双引号和反斜杠。 支持多行。 支持内插。 支持修剪。 示例： string userName = \"Alice\"; int minAge = 18; string complexQuery = $\"\"\" SELECT u.Name, u.Email, o.OrderTotal FROM Users u LEFT JOIN Orders o ON u.Id = o.UserId WHERE u.Name LIKE '%{userName}%' AND u.Age >= {minAge} AND u.Status IN ('Active', 'Verified') ORDER BY o.OrderTotal DESC; \"\"\"; // JSON 内插 string status = \"Online\"; string userJson = $\"\"\" {{ \"name\": \"Charlie\", \"status\": \"{status}\", \"lastSeen\": \"{DateTime.UtcNow:O}\" }} \"\"\"; 注意： 修剪：原始字符串会自动移除首尾空白字符。 组合 3: $ + @ + \"\"\" 虽然语法上允许 $@\"\"\"...\"\"\"，但 @ 在原始字符串中是冗余的，因为原始字符串本身就具备逐字特性。直接使用 $\"\"\"...\"\"\" 即可。 对比总结表 特性 语法 多行 无需转义 \\ 无需转义 \" 内插 修剪 推荐场景 :--- :--- :--- :--- :--- :--- :--- :--- 普通字符串 \"...\" ❌ (需 \\n) ❌ ❌ ❌ ❌ 简单单行文本 逐字字符串 @\"...\" ✅ ✅ ❌ (\"\") ❌ ❌ 文件路径、简单多行 内插字符串 $\"...\" ❌ (需 \\n) ❌ ❌ ✅ ❌ 简单内插 逐字内插 $@\"...\" ✅ ✅ ❌ (\"\") ✅ ❌ C# 11 前的复杂内插 原始字符串 \"\"\"...\"\"\" ✅ ✅ ✅ ❌ ✅ 复杂多行文本 (无内插) 原始内插 $\"\"\"...\"\"\" ✅ ✅ ✅ ✅ ✅ C# 11+ 的首选方式 最佳实践建议 C# 11 及以上项目： 对于任何复杂的、多行的、包含引号或反斜杠的字符串（尤其是 JSON、SQL、HTML、正则表达式），优先使用 $\"\"\"...\"\"\"。 它结合了所有优点，代码最清晰。 旧版 C# 项目： 使用 $@\"...\" 作为替代方案。 记住双引号需要用 \"\" 转义。 简单场景： 单行简单文本用 \"...\"。 单行路径用 @\"...\"。 避免混合 @ 和 \"\"\"： $@\"\"\"...\"\"\" 虽然合法，但 @ 是多余的，直接用 $\"\"\"...\"\"\" 更简洁。 总结：$\"\"\"...\"\"\" 是现代 C# 中处理复杂字符串的终极武器。它让你可以像写纯文本一样编写字符串，同时享受内插和格式化的便利，是提升代码可读性和开发效率的利器。 好的，这是关于 C# 原始字符串字面量（Raw String Literals）的详细介绍。 C# 原始字符串字面量 (Raw String Literals) 全面介绍 从 C# 11 开始，C# 引入了原始字符串字面量 (Raw String Literals)。这是一个强大的新特性，旨在解决传统字符串在处理多行文本、包含大量引号或转义字符时的繁琐和易错问题。 什么是原始字符串字面量？ 原始字符串字面量允许你以最接近其最终形式的方式来定义字符串。它使用三个双引号 \"\"\" 作为定界符，字符串的内容被原封不动地包含在这些定界符之间。 核心特点： 多行支持：可以自然地跨越多行。 无需转义：字符串内部的引号 \"、反斜杠 \\、换行符等都不需要使用反斜杠进行转义。 保留格式：字符串的格式（包括缩进和空格）会被精确地保留。 2. 基本语法 string myString = \"\"\" 包含字符串内容的文本 可以跨越多行 \"\"\"; 开始定界符：\"\"\" (三个双引号)。 结束定界符：\"\"\" (三个双引号)，必须独占一行，并且其前面不能有任何空格或制表符（除非使用修剪功能，见下文）。 内容：开始和结束定界符之间的所有字符，包括换行符和空格，都会成为字符串的一部分。 3. 主要优势与应用场景 ✅ 优势 1：简化多行字符串 无需使用 + 拼接或 \\n 换行符。 // C# 11 之前 string poem = \"春风又绿江南岸，\\n\" + \"明月何时照我还？\\n\" + \"举头望明月，\\n\" + \"低头思故乡。\"; // C# 11 使用原始字符串 string poem = \"\"\" 春风又绿江南岸， 明月何时照我还？ 举头望明月， 低头思故乡。 \"\"\"; ✅ 优势 2：无需转义引号 在 JSON、SQL 或包含引号的文本中，再也不用写 \" 了。 // C# 11 之前 - 需要转义引号 string json = \"{\\\"name\\\": \\\"John\\\", \\\"age\\\": 30, \\\"city\\\": \\\"New York\\\"}\"; // C# 11 使用原始字符串 - 引号无需转义 string json = \"\"\"{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}\"\"\"; // 更复杂的 JSON 示例 string complexJson = \"\"\" { \"users\": [ { \"id\": 1, \"name\": \"Alice\", \"preferences\": { \"theme\": \"dark\", \"notifications\": true } } ] } \"\"\"; ✅ 优势 3：简化正则表达式 正则表达式中反斜杠 \\ 非常常见，传统字符串需要写成 \\。 // C# 11 之前 - 每个反斜杠都需要转义 string regexPattern = \"^\\\\d{3}-\\\\d{2}-\\\\d{4}$\"; // 匹配 Social Security Number // C# 11 使用原始字符串 - 反斜杠无需转义 string regexPattern = \"\"\"^\\d{3}-\\d{2}-\\d{4}$\"\"\"; ✅ 优势 4：编写清晰的 SQL 查询 string query = \"\"\" SELECT u.Name, o.OrderDate, o.Total FROM Users u JOIN Orders o ON u.Id = o.UserId WHERE u.Status = 'Active' AND o.OrderDate >= '2023-01-01' ORDER BY o.OrderDate DESC; \"\"\"; 高级功能：修剪 (Trimming) 和控制结束定界符位置 原始字符串字面量支持一个非常实用的功能：通过在结束定界符 \"\"\" 前添加空格或制表符来修剪字符串开头的空白。 规则：编译器会找到所有行（包括结束定界符所在行）开头的公共空白前缀，然后将其从每行中移除。 // 示例 1：修剪左侧空白 string text = \"\"\" 这行有 4 个空格的缩进。 这行有 8 个空格的缩进。 \"\"\"; // 结果字符串： // \"这行有 4 个空格的缩进。\\n 这行有 8 个空格的缩进。\\n\" // 示例 2：将结束定界符与内容对齐（常用） string aligned = \"\"\" SELECT FROM Users WHERE Active = 1 ORDER BY Name; \"\"\"; // 结果字符串： // \"这行有 4 个空格的缩进。\\n 这行有 8 个空格的缩进。\\n\" // 示例 2：将结束定界符与内容对齐（常用） string aligned = \"\"\" SELECT FROM Users WHERE Active = 1 ORDER BY Name; \"\"\"; // 结果字符串： // \"SELECT FROM Users\\nWHERE Active = 1\\nORDER BY Name;\\n\" // （左侧的 16 个空格被修剪掉了） // 示例 3：混合空格和制表符（不推荐，行为可能复杂） // 最好统一使用空格或制表符。 5. 插值 (Interpolation) 支持 原始字符串字面量完全支持字符串插值 $。 string name = \"Alice\"; int age = 30; string message = $\"\"\" Hello, my name is {name}. I am {age} years old. \"\"\"; // 结果: \"Hello, my name is Alice.\\nI am 30 years old.\\n\" 注意：插值表达式 {} 内部仍然遵循正常的 C# 语法，如果需要在插值表达式中使用 \"\"\"，可能需要额外的处理。 6. 注意事项与最佳实践 C# 11 及以上：确保你的项目目标框架支持 C# 11 (.NET 7 或更高版本，或配置了 C# 11)。 结束定界符：结束的 \"\"\" 必须独占一行。如果它和其他字符在同一行，编译器会报错。 修剪行为：理解修剪规则，合理利用它来保持代码美观而不影响字符串内容。 性能：与普通字符串字面量一样，原始字符串字面量也是在编译时确定的，没有运行时性能开销。 可读性：对于简单的单行字符串，传统字符串可能更简洁。原始字符串最适合复杂的多行、高转义需求的场景。 7. 总结 C# 的原始字符串字面量 (\"\"\"...\"\"\") 是一个革命性的特性，它： 极大地提升了处理 JSON、SQL、正则表达式、模板等多行或高转义文本的代码可读性和可维护性。 消除了繁琐的引号和反斜杠转义。 简化了多行字符串的编写。 它是现代 C# 开发中处理复杂字符串文本的首选工具。一旦你开始使用它，就很难再回到传统的字符串拼接和转义方式了。"
  },
  "CSharp/字符串/比较.html": {
    "href": "CSharp/字符串/比较.html",
    "title": "| CZQDocs",
    "summary": "首选 StringComparison 枚举 这是最重要、最核心的实践。在调用任何涉及字符串比较的方法时（如 string.Equals, string.Compare, string.StartsWith, string.Contains, string.IndexOf 等），应使用接受 StringComparison 枚举作为参数的重载。 为什么？ 避免歧义：默认的字符串比较行为（通常是区分大小写的序号比较）可能不符合你的业务逻辑。 提高性能：某些比较类型（如 Ordinal）比文化感知比较更快。 增强可读性：代码明确表达了你的意图。 防止错误：尤其是在处理用户输入或跨区域环境时，不正确的比较可能导致安全漏洞或逻辑错误。 常用 StringComparison 成员： 枚举值 含义 推荐场景 :--- :--- :--- Ordinal 区分大小写的序号比较（基于字符的 Unicode 码点）。 首选！ 用于技术性比较，如文件名、URL、GUID、XML 标签、哈希值、字典键等。性能最高。 OrdinalIgnoreCase 不区分大小写的序号比较。 当需要忽略大小写进行技术性比较时（如比较 HTTP 头名称 \"Content-Type\" 和 \"content-type\"）。性能高。 CurrentCulture 基于当前线程的文化设置进行区分大小写的语言学比较。 当需要根据用户的本地化规则对用户可见的字符串进行排序或显示时。 CurrentCultureIgnoreCase 基于当前线程的文化设置进行不区分大小写的语言学比较。 同上，但忽略大小写。 InvariantCulture 基于固定不变的文化（invariant culture）进行区分大小写的语言学比较。 当需要一种与区域无关、稳定一致的比较结果时（例如，在持久化数据或网络协议中）。 InvariantCultureIgnoreCase 基于固定不变的文化进行不区分大小写的语言学比较。 同上，但忽略大小写。 默认选择：Ordinal 或 OrdinalIgnoreCase 微软强烈建议： 对于大多数编程场景，尤其是那些不面向最终用户的、基于技术标识符的比较，请使用 Ordinal 或 OrdinalIgnoreCase。 原因： 性能：序号比较是最快的，因为它直接比较字符的二进制值。 稳定性：结果不会因用户的区域设置而改变。 安全性：避免了因文化差异导致的意外行为。 示例： // ✅ 推荐：使用 StringComparison 明确指定 bool isEqual = string.Equals(str1, str2, StringComparison.Ordinal); bool startsWith = fileName.StartsWith(\"log\\_\", StringComparison.OrdinalIgnoreCase); int index = text.IndexOf(\"ERROR\", StringComparison.OrdinalIgnoreCase); // ❌ 不推荐：依赖默认行为（通常是 Ordinal，但不明确） bool isEqual = str1 == str2; bool startsWith = fileName.StartsWith(\"log\\_\"); // 可能不是你想要的！ 文化感知比较 (CurrentCulture) 的适用场景 仅在以下情况使用 CurrentCulture 或 CurrentCultureIgnoreCase： 比较或排序面向最终用户的文本。 结果将显示给用户，并且需要符合用户的语言习惯。 例如：联系人列表按姓名排序、文档标题搜索等。 // 示例：对用户姓名进行排序 Array.Sort(names, StringComparer.CurrentCulture); 避免使用不带 StringComparison 参数的重载 许多字符串方法有多个重载。应优先选择接受 StringComparison 参数的那个。 // ❌ 避免 if (input.ToLower() == \"yes\") { ... } // ToLower 分配内存，且行为不明确 // ✅ 推荐 if (string.Equals(input, \"yes\", StringComparison.OrdinalIgnoreCase)) { ... } // ❌ 避免 if (path.EndsWith(\".txt\")) { ... } // ✅ 推荐 if (path.EndsWith(\".txt\", StringComparison.OrdinalIgnoreCase)) { ... } 使用 StringComparer 类进行集合操作 当创建基于字符串的集合（如 Dictionary<string, T> 或 HashSet ）时，使用 StringComparer 来指定比较方式。 // 创建一个不区分大小写的字典 var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase) { { \"Key1\", \"Value1\" }, { \"KEY2\", \"Value2\" } }; // 这样可以通过 \"key1\" 或 \"KEY1\" 来访问 Console.WriteLine(dict[\"key1\"]); // 输出 \"Value1\" 6. 注意 == 操作符的行为 string 类型重载了 == 操作符，它执行的是区分大小写的序号比较（相当于 StringComparison.Ordinal）。 可以安全使用 == 进行简单的、区分大小写的相等判断。 但如果有忽略大小写的需求，必须使用 Equals 方法并指定 StringComparison.OrdinalIgnoreCase。 string a = \"Hello\"; string b = \"HELLO\"; Console.WriteLine(a == b); // False (Ordinal) Console.WriteLine(string.Equals(a, b, StringComparison.OrdinalIgnoreCase)); // True 7. 跨平台一致性考虑 在 .NET Framework 和 .NET Core/.NET 5+ 之间，或在不同操作系统上，文化感知比较的结果可能略有差异。如果需要绝对一致的结果，优先使用 Ordinal、OrdinalIgnoreCase 或 InvariantCulture。 总结：微软推荐的检查清单 明确指定：在所有字符串比较操作中，使用 StringComparison 枚举。 默认序号：除非有特定的语言学需求，否则优先选择 StringComparison.Ordinal 或 StringComparison.OrdinalIgnoreCase。 用户界面用文化：仅在向用户显示排序或比较结果时，使用 CurrentCulture。 集合用 StringComparer：为字符串集合指定合适的比较器。 避免旧式方法：不要依赖 ToLower()/ToUpper() 进行比较，这既低效又可能出错。 遵循这些实践，可以确保你的字符串比较代码是高效、正确、安全且可维护的。"
  },
  "CSharp/官网地址.html": {
    "href": "CSharp/官网地址.html",
    "title": "| CZQDocs",
    "summary": "C# 语言文档 解决可以为 null 的警告 运算符is 模式匹配"
  },
  "CSharp/异步/CancellationToken.html": {
    "href": "CSharp/异步/CancellationToken.html",
    "title": "| CZQDocs",
    "summary": "一句话区分： HttpClient.Timeout 管“整个请求”的最大时长（从发送请求到收到响应完成）。 CancellationToken 管“任意时刻”的取消信号（用户点取消、页面关闭、业务主动放弃等）。 两者同时存在时，谁先触发谁生效，并不冲突。 1. HttpClient.Timeout = 10 s 写在 命名/类型化客户端 配置里，全局默认。 从 SendAsync 开始计时 → 收到最后一个字节结束；超时就抛 TaskCanceledException（内部包 TimeoutException）。 只能给 整数秒，不能细粒度控制“连接阶段”“读写阶段”。 2. CancellationToken 由 调用方 传入，可随业务随时取消（用户点击“停止”、窗口关闭、VM 销毁）。 与超时无关，你可以设 30 s 超时，但 2 s 就取消。 取消后同样抛 TaskCanceledException，但 IsCancellationRequested = true，可区分是“用户取消”还是“超时”。 3. 同时用会怎样？ using var cts = new CancellationTokenSource(5000); // 5 秒取消 await client.PostAsync(\"/api/log\", content, cts.Token); 如果 HttpClient.Timeout = 10 s，5 s 的 CancellationToken 先触发 → 请求被取消，不会走到 10 s 超时。 若你把 HttpClient.Timeout 设成 无限（Timeout = Timeout.InfiniteTimeSpan），则完全由 CancellationToken 掌控。 4. 最佳实践建议 场景 推荐做法 一般 REST 调用 客户端配置 Timeout = 10/20 s 做兜底，调用时再传 CancellationToken（用户可取消） 长时间上传/下载 把 Timeout 设成 Infinite，用 CancellationToken 或自定义超时策略（Polly 更细） 可中断的 UI 操作 页面关闭、导航离开 → cts.Cancel() 即可，与 Timeout 无关 一句话总结 Timeout 是 客户端默认“最长能忍多久”。 CancellationToken 是 “随时喊停”的开关。 两者同时存在，谁先响谁买单，互不干扰，建议都留着：Timeout 兜底，Token 给用户控制权。"
  },
  "CSharp/异步/ConfigureAwait.html": {
    "href": "CSharp/异步/ConfigureAwait.html",
    "title": ".NET 中 ConfigureAwait 的最佳实践指南。 | CZQDocs",
    "summary": ".NET 中 ConfigureAwait 的最佳实践指南。 ConfigureAwait 是一个在异步编程中至关重要但又常常被误解或误用的方法。正确使用它可以避免死锁、提升性能，并确保代码的可移植性。 .NET 中 ConfigureAwait(false) 的最佳实践 核心概念：什么是 ConfigureAwait？ 当你 await 一个 Task 时，默认行为（即调用 ConfigureAwait(true) 或不调用）是： 在异步操作完成后，尝试捕获当前的 SynchronizationContext。 如果捕获到了上下文（例如 UI 线程的上下文），则回调（continuation）会在同一个上下文中执行。 如果没有捕获到上下文（例如在控制台应用或 ASP.NET Core 中），则回调会在线程池线程上执行。 ConfigureAwait(false) 的作用就是明确告诉运行时：不要捕获当前的上下文，回调可以在任何线程池线程上执行。 2. 为什么需要 ConfigureAwait(false)？—— 主要风险与收益 风险：UI 应用中的死锁 场景：在 WinForms/WPF/UWP 等 UI 应用中，主线程（UI 线程）有一个特殊的 SynchronizationContext，它负责将工作排队回 UI 线程。 问题：如果在 UI 线程上同步阻塞一个 async 方法（例如错误地使用 .Result 或 .Wait()），而该方法内部 await 了一个需要回到 UI 线程的任务，就会发生死锁。 UI 线程在等待任务完成。 任务完成后需要回到 UI 线程执行回调。 但 UI 线程正被阻塞，无法处理回调。 → 死锁。 解决：在库代码中使用 ConfigureAwait(false)，可以避免回调尝试回到 UI 线程，从而打破死锁循环。 收益：性能提升 捕获和恢复 SynchronizationContext 是有开销的。 在不需要特定上下文的场景下（如大多数非 UI 的逻辑处理），使用 ConfigureAwait(false) 可以避免不必要的上下文切换开销，让回调直接在完成工作的线程上继续执行，提高吞吐量。 3. 最佳实践：何时使用 ConfigureAwait(false)？ 以下是业界广泛接受的最佳实践： ✅ 应该使用 ConfigureAwait(false) 的场景 类库 (Library) 代码中的每一个 await： 这是最重要的规则。如果你编写的是一个通用类库（NuGet 包、共享组件等），你不知道你的代码将在何种上下文中被调用（可能是 ASP.NET Framework, WinForms, WPF, 控制台，还是 ASP.NET Core）。 为了安全性和性能，库代码中的每一个 await 都应使用 ConfigureAwait(false)。 目的： 防止死锁：避免因调用者在 UI 线程上同步阻塞而导致死锁。 提升性能：避免不必要的上下文调度。 保持中立性：不干扰调用者的上下文。 // MyLibrary.cs - 类库代码 public async Task<string> GetDataAsync() { // 即使是在 ASP.NET Core 中，也建议在库中使用 false var response = await httpClient.GetStringAsync(url).ConfigureAwait(false); var processed = await ProcessDataAsync(response).ConfigureAwait(false); return processed; } ASP.NET (Framework) 应用中的“后台”逻辑： 在传统的 ASP.NET (非 Core) 中，存在 AspNetSynchronizationContext，它会将 await 后的回调排回请求上下文队列，这可能影响吞吐量。 在非 UI 更新的业务逻辑层、数据访问层中，使用 ConfigureAwait(false) 可以释放 IIS 工作线程，提高服务器并发能力。 注意：在需要访问 HttpContext.Current 等请求特定状态的地方，可能仍需上下文，需谨慎评估。 ❌ 不应该使用 ConfigureAwait(false) 的场景 UI 应用 (WinForms, WPF, UWP, Blazor Server) 的事件处理程序或 ViewModel 中： 在这些场景中，你通常需要在 await 后更新 UI 控件。 UI 控件只能由创建它们的线程（通常是 UI 线程）访问。 使用 ConfigureAwait(true)（默认行为）可以确保回调回到 UI 线程，让你能安全地更新 UI。 // MainWindow.xaml.cs - WPF 应用 private async void Button_Click(object sender, RoutedEventArgs e) { // 默认行为会回到 UI 线程 var data = await myService.GetDataAsync(); // 假设库内部已用 ConfigureAwait(false) // 这行代码安全地在 UI 线程执行 textBox.Text = data; } 需要访问特定上下文状态的代码： 例如，在 ASP.NET Framework 中，某些操作可能依赖 HttpContext.Current，而它与 AspNetSynchronizationContext 绑定。使用 false 可能导致后续代码无法访问上下文。 已经处于无上下文环境的应用： ASP.NET Core：从设计上就没有 AspNetSynchronizationContext，await 后默认就在线程池线程上继续。因此，在 ASP.NET Core 应用中，ConfigureAwait(false) 不会带来性能提升，因为本来就不会捕获上下文。 控制台应用：通常也没有 SynchronizationContext。 结论：在这些应用中，使用 ConfigureAwait(false) 不是必需的，但也不有害。为了代码一致性或未来可移植性，一些团队仍会选择使用。 实践建议与工具 对库开发者：养成习惯，在写库时，所有 await 都加 .ConfigureAwait(false)。可以借助代码分析工具（如 Microsoft.VisualStudio.Threading.Analyzers）来检查遗漏。 对应用开发者： 如果你在写 UI 应用，关注那些不涉及 UI 更新的 await，考虑是否需要 false（但通常整个方法逻辑都与 UI 相关，所以很少用）。 如果你在写 ASP.NET Core 应用，知道 ConfigureAwait(false) 不是必须的，可以根据团队规范决定是否使用。 永远不要在公共 API 的返回值上使用 ConfigureAwait： ConfigureAwait 返回的是一个 ConfiguredTaskAwaitable，而不是 Task。这会破坏方法签名，让调用者无法正常使用 await 或 ContinueWith 等。ConfigureAwait 应该在 await 表达式内部使用。 5. 总结 场景 是否使用 ConfigureAwait(false) 理由 :--- :--- :--- 通用类库 (Library) ✅ 强烈推荐 防止死锁，提升性能，保持上下文中立 UI 应用 (WPF/WinForms) 的 UI 逻辑 ❌ 避免 需要回到 UI 线程更新控件 ASP.NET Framework 的后台逻辑 ✅ 推荐 提高服务器吞吐量 ASP.NET Core 应用 ⚠️ 可选/无影响 默认无上下文，使用与否无性能差异 控制台应用 ⚠️ 可选/无影响 通常无上下文 核心原则： “库用 false，应用看情况。” 类库为了安全和性能，应普遍使用 ConfigureAwait(false)；而应用程序则根据其类型和具体需求来决定。"
  },
  "CSharp/异步/ValueTask.html": {
    "href": "CSharp/异步/ValueTask.html",
    "title": ".NET 中 ValueTask 的全面指南。 | CZQDocs",
    "summary": ".NET 中 ValueTask 的全面指南。 ValueTask 全面指南：超越 Task 的高性能异步选择 在 .NET 的异步编程世界里，Task 和 Task 是长期以来的基石。然而，随着对性能要求的日益提高，特别是在高吞吐量、低延迟的场景下（如 Web 服务器、微服务、游戏服务器），Task 的内存分配开销逐渐成为瓶颈。为了解决这个问题，.NET 引入了 ValueTask 和 ValueTask ，作为 Task 的高性能补充。 本指南将深入探讨 ValueTask 的设计哲学、工作原理、优势、陷阱以及最佳实践。 为什么 (Why) 需要 ValueTask？—— Task 的痛点 Task 是一个引用类型（class）。每次创建一个未完成的 Task 对象（例如，通过 Task.Run 或异步方法中遇到 await 且操作未立即完成时），都会在托管堆 (heap) 上分配内存。 对于频繁执行、快速完成的异步操作，这种分配会带来显著的性能问题： 内存压力：大量的短期 Task 对象会迅速填满内存。 垃圾回收 (GC) 压力：这些短期对象会频繁触发 GC，尤其是 Gen0 垃圾回收，导致 CPU 时间被消耗在内存管理上，而不是业务逻辑上。 性能开销：内存分配和 GC 都是昂贵的操作。 ValueTask 的设计目标就是消除或减少这种高频、短时异步操作的内存分配。 2. 是什么 (What) —— ValueTask 的核心概念 ValueTask 和 ValueTask 是结构体 (struct)，因此是值类型。它们本身存储在栈上（或内联在调用者中），不会在堆上产生分配。 但 ValueTask 并不是凭空产生结果的。它内部通过一个巧妙的设计来实现零分配或低分配： 成功且同步完成的场景： 如果异步操作可以立即、同步地完成（例如，从内存缓存中读取数据，且数据存在），ValueTask 可以直接将结果（或一个表示成功的标记）内联存储在结构体内部。 这种情况下，完全不需要堆分配。 需要异步等待的场景： 如果操作不能立即完成（例如，需要从网络或磁盘读取数据），ValueTask 会包装一个真实的 Task 对象。 这个 Task 对象仍然会在堆上分配，但这是不可避免的，因为需要一个对象来协调异步操作的生命周期。 ValueTask 作为一个轻量级的“外壳”，持有对这个 Task 的引用。 关键点：ValueTask 本身是一个值类型外壳，它根据操作的完成方式，要么直接持有结果（零分配），要么引用一个 Task（一次分配，但这是必须的）。 3. 何时 (When) 使用 ValueTask？—— 最佳实践与场景 ValueTask 并非 Task 的通用替代品。它的使用有明确的适用场景和限制。 应该使用 ValueTask 的场景： 高频调用的 I/O 操作：尤其是那些有很大概率同步完成的操作。 示例：Stream.ReadAsync、Stream.WriteAsync。如果数据已经在缓冲区中，读取可以立即完成，返回一个零分配的 ValueTask 。如果数据不在缓冲区，需要等待 I/O 完成，则返回一个包装了 Task 的 ValueTask 。 自定义异步原语：当你在编写一个可能快速完成的异步方法时。 示例：一个异步缓存查找方法。如果缓存命中，可以立即返回结果，非常适合 ValueTask 。 性能关键路径：在对性能要求极高，且经过分析确认 Task 分配是瓶颈的代码中。 ❌ 不应该使用 ValueTask 的场景： 返回 ValueTask 的方法体中包含了 await： 这是最常见的陷阱！如果你在 async 方法中使用 await，编译器会强制创建一个状态机，这个状态机本身就是一个引用类型，会产生堆分配。此时使用 ValueTask 不会带来任何性能收益，反而增加了复杂性。 ValueTask 的优势在于避免创建 Task 对象，但如果状态机本身就在堆上，省一个 Task 的意义不大。 规则：只有当你能同步返回结果或直接返回一个已存在的 Task 时，ValueTask 才有意义。对于典型的 async/await 方法，坚持使用 Task。 需要多次 await 同一个返回值： ValueTask 不是设计来被多次 await 的。await 一个 ValueTask 会消耗它（内部状态可能改变）。多次 await 可能导致未定义行为或异常。 如果你需要多次检查或等待同一个操作，必须使用 Task，因为 Task 是可以安全地被多次 await 的。 传递给 Task.WhenAll 或 Task.WhenAny： 这些方法期望 Task 对象。虽然有 ValueTask 的重载，但通常不如直接使用 Task 高效或直观。如果需要组合多个操作，考虑是否值得为单个操作使用 ValueTask。 作为方法参数： 将 ValueTask 作为参数传递会迫使它被装箱（因为方法参数是引用），这违背了使用值类型的初衷。应优先使用 Task 作为参数。 ValueTask 的陷阱与注意事项 不可变性：ValueTask 在 await 后不应再被使用。 装箱风险：任何需要将 ValueTask 当作 object 或接口（如 IValueTaskSource）处理的场景都可能导致装箱，产生堆分配。 调试复杂性：由于 ValueTask 可能代表两种不同的内部状态（内联结果或引用 Task），调试时可能不如 Task 直观。 API 设计：公开的 API 是否返回 ValueTask 需要仔细权衡。它向调用者传达了“此方法可能快速完成”的信号，但也增加了调用者的使用复杂性。 5. 总结 Task 是默认选择：对于绝大多数异步方法，特别是包含 await 的 async 方法，始终使用 Task。它简单、安全、语义清晰。 ValueTask 是性能优化工具：它是一个高级工具，用于在特定场景下（高频、可能同步完成的 I/O 操作）减少内存分配和 GC 压力。 核心原则：ValueTask 的价值在于避免不必要的堆分配。如果使用它反而引入了状态机分配或使用上的复杂性，那么它就失去了意义。 简单记忆： “用 Task 写代码，用 ValueTask 优化 I/O。” 在决定使用 ValueTask 之前，务必进行性能分析，确认 Task 分配确实是瓶颈，并且你的使用方式符合最佳实践，避免陷入陷阱。"
  },
  "CSharp/异步/概念.html": {
    "href": "CSharp/异步/概念.html",
    "title": "| CZQDocs",
    "summary": "使用 async 和 await 进行异步编程 好的，我们来详细讲解 C# 中的异步编程。这是现代 C# 开发中一个至关重要且强大的特性，它能显著提升应用程序的响应性和可扩展性。 为什么需要异步编程？ 在传统的同步编程模型中，当一个方法执行一个耗时操作（如文件 I/O、网络请求、数据库查询、调用外部 API 等）时，调用线程会一直阻塞，直到该操作完成。 对于桌面应用 (WPF/WinForms)：如果在 UI 线程上执行耗时的同步操作，整个界面会“冻结”，用户无法进行任何交互，体验极差。 对于 Web 应用 (ASP.NET)：服务器处理每个请求通常使用一个线程。如果线程被阻塞在 I/O 操作上，它就无法处理其他请求，导致服务器资源浪费，吞吐量下降。 异步编程的核心目标就是：在等待耗时操作（尤其是 I/O 操作）完成时，不阻塞当前线程，让线程可以去执行其他任务，从而提高资源利用率和程序响应性。 C# 异步编程的核心：async 和 await C# 提供了非常简洁的语法来实现异步编程：async 和 await 关键字。它们是基于 任务 (Task) 模型构建的。 async 关键字 作用：用于修饰一个方法、lambda 表达式或匿名方法，表明该方法是异步的。 位置：放在返回类型之前。 返回类型： Task：用于没有返回值的异步方法（类似于 void）。 Task ：用于有返回值的异步方法，T 是返回值的类型。 ValueTask / ValueTask ：在某些高性能场景下替代 Task，以减少堆分配。 void：仅用于事件处理程序。返回 void 的异步方法很难被调用者跟踪其完成状态和异常，应尽量避免。 注意：async 本身不会使方法异步执行。它只是启用了 await 关键字，并改变了方法的编译方式。 2. await 关键字 作用：等待一个 Task 或 Task 完成。当遇到 await 时，如果任务尚未完成，控制权会立即返回给调用者，不会阻塞线程。一旦任务完成，方法的执行会从 await 之后的代码恢复。 位置：只能在标记为 async 的方法内部使用。 原理：await 实际上是一个“语法糖”。编译器会将 async 方法转换成一个状态机 (State Machine)。当 await 遇到未完成的任务时，状态机会保存当前的上下文（局部变量、执行位置等），然后注册一个回调（continuation），当任务完成后，这个回调会被调度执行，恢复方法的执行。 基本语法示例 using System; using System.Net.Http; using System.Threading.Tasks; class Program { // Main 方法也可以是异步的 (C# 7.1+) static async Task Main(string[] args) { Console.WriteLine(\"开始获取网页内容...\"); // 调用异步方法并等待其完成 string content = await GetWebContentAsync(\"https://www.example.com\"); Console.WriteLine($\"获取到的内容长度: {content.Length}\"); Console.WriteLine(\"程序结束。\"); } // 异步方法：返回 Task<string> static async Task<string> GetWebContentAsync(string url) { // HttpClient 用于发送 HTTP 请求 using var client = new HttpClient(); // await 关键字等待 GetStringAsync 完成 // GetStringAsync 是一个真正的异步 I/O 操作 string content = await client.GetStringAsync(url); // 当 GetStringAsync 完成后，执行会恢复到这里 return content; } } 执行流程分析： Main 开始执行，打印 \"开始获取网页内容...\"。 执行 await GetWebContentAsync(...)，进入 GetWebContentAsync 方法。 在 GetWebContentAsync 中，创建 HttpClient。 执行 await client.GetStringAsync(url)。GetStringAsync 发起一个网络请求，并立即返回一个 Task （表示未来的结果）。 因为 Task 尚未完成，await 操作导致 GetWebContentAsync 方法的执行被“挂起”，控制权返回给 Main 方法。 关键点：此时，执行 Main 的线程（比如主线程）没有被阻塞！它可以去处理其他事情（在控制台应用中可能只是空闲，但在 UI 或 Web 应用中可以处理其他请求或 UI 事件）。 当网络请求完成，GetStringAsync 返回的 Task 变为“已完成”状态，并携带了网页内容。 系统调度 GetWebContentAsync 方法中 await 之后的代码继续执行（即 return content;）。 GetWebContentAsync 方法返回一个已完成的 Task 给 Main。 Main 方法中 await 操作完成，content 变量被赋值，继续执行后续代码。 关键概念深入 线程与异步 误解：“异步 = 多线程”。 真相：异步 I/O 操作（如 HttpClient.GetStringAsync, FileStream.ReadAsync）通常不需要额外的线程来等待 I/O 完成。操作系统会处理底层的 I/O 请求，当数据准备好时，通过回调通知 .NET 运行时。.NET 运行时（通过 ThreadPool）负责调度这些回调。 线程池 (ThreadPool)：await 之后的代码（continuation）默认会在 ThreadPool 的某个线程上执行。这可能导致上下文切换。 ConfigureAwait(false)： 在类库中，为了性能和避免死锁，建议在 await 后使用 .ConfigureAwait(false)。 它告诉运行时：后续的 continuation 不需要回到原始的 SynchronizationContext（比如 UI 线程）。 在 UI 应用或 ASP.NET 的请求上下文中，如果不使用 ConfigureAwait(false)，continuation 会尝试回到原始上下文执行，这可能引起死锁（如果同步等待异步方法）。 // 在类库中推荐写法 string content = await client.GetStringAsync(url).ConfigureAwait(false); 2. 异常处理 异常在异步方法中通过 Task 的 Exception 属性传播。 使用 try-catch 块包裹 await 表达式，可以捕获异步方法中抛出的异常。 csharp static async Task<string> GetWebContentAsync(string url) { try { using var client = new HttpClient(); return await client.GetStringAsync(url); } catch (HttpRequestException ex) { Console.WriteLine($\"HTTP 请求失败: {ex.Message}\"); throw; // 可以选择重新抛出或处理 } catch (TaskCanceledException ex) { Console.WriteLine($\"请求超时: {ex.Message}\"); throw; } } 3. 并发执行多个异步操作 顺序执行：使用 await 一个接一个地调用。 csharp var content1 = await GetWebContentAsync(url1); var content2 = await GetWebContentAsync(url2); // 必须等第一个完成后才开始 并发执行：先启动所有任务，再 await 它们。这样多个 I/O 操作可以同时进行。 csharp // 启动所有任务 (不等待) var task1 = GetWebContentAsync(url1); var task2 = GetWebContentAsync(url2); var task3 = GetWebContentAsync(url3); // 等待所有任务完成 var results = await Task.WhenAll(task1, task2, task3); // results 是一个 string[] 数组 // 或者分别 await var content1 = await task1; var content2 = await task2; var content3 = await task3; Task.WhenAny：等待第一个完成的任务。 csharp var task1 = GetWebContentAsync(url1); var task2 = GetWebContentAsync(url2); var firstCompletedTask = await Task.WhenAny(task1, task2); var result = await firstCompletedTask; // 获取第一个完成的任务的结果 4. 取消异步操作 (CancellationToken) 长时间运行的操作应该支持取消。 csharp static async Task<string> GetWebContentAsync(string url, CancellationToken cancellationToken) { using var client = new HttpClient(); // 将 CancellationToken 传递给支持取消的异步方法 var response = await client.GetAsync(url, cancellationToken); response.EnsureSuccessStatusCode(); var content = await response.Content.ReadAsStringAsync(cancellationToken); return content; } // 调用 var cts = new CancellationTokenSource(); // 可以在某个条件满足时调用 cts.Cancel() 来取消操作 cts.CancelAfter(TimeSpan.FromSeconds(10)); // 10 秒后自动取消 try { string content = await GetWebContentAsync(\"https://slow-website.com\", cts.Token); } catch (OperationCanceledException) { Console.WriteLine(\"操作被取消。\"); } 最佳实践与注意事项 避免 async void：除非是事件处理程序，否则始终返回 Task 或 Task 。async void 无法被 await，异常处理困难。 不要阻塞异步代码：避免在异步方法中使用 .Result 或 .Wait()。这极易导致死锁，尤其是在有 SynchronizationContext 的环境中（如 UI 或 ASP.NET）。 错误做法： public string GetData() { return GetWebContentAsync(\"...\").Result; // 危险！可能导致死锁 } 使用 ConfigureAwait(false)：在编写类库时，为了性能和避免潜在的死锁，await 后应使用 .ConfigureAwait(false)。 正确处理异常：使用 try-catch 包裹 await。 支持取消：为长时间运行的操作提供 CancellationToken 参数。 理解返回类型：明确你的异步方法是返回 Task 还是 Task 。 并发与并行：Task.WhenAll 实现的是并发（concurrency），多个操作重叠执行，但不一定在多个 CPU 核心上并行（parallelism）运行。真正的并行计算通常使用 Parallel 类或 PLINQ。 总结 C# 的 async/await 提供了一种优雅、高效的方式来处理异步操作，特别是 I/O 密集型任务。它通过释放线程来等待 I/O 完成，极大地提高了应用程序的可伸缩性和响应性。理解其背后的 Task 模型、状态机原理以及 SynchronizationContext 的作用，是避免陷阱（如死锁）和编写高质量异步代码的关键。 掌握异步编程是成为一名合格的现代 C# 开发者的必备技能。"
  },
  "CSharp/模式匹配/1.html": {
    "href": "CSharp/模式匹配/1.html",
    "title": "| CZQDocs",
    "summary": "模式匹配 C# 模式匹配（Pattern Matching）从 C# 7 开始引入，经过 8、9、10、11 五个版本的迭代，已经发展成一套独立的“子语言”，几乎可以在任何需要“判断 + 提取”的场景里替代传统的 if/else + 强制转换 + 声明临时变量 三连击。 下面给一份“一页式全景图”： 先列语法，再给使用场景，最后写性能/陷阱速查。 一、语法总览（按出现时间排序） 名称 示例 最低版本 1. 常量模式 x is 42 C# 7 2. 类型模式 x is string s C# 7 3. var 模式 x is var v C# 7 4. 弃元模式 x is _ C# 7 5. 元组解构 (x, y) is (0, 0) C# 7 6. 属性模式 p is { X: 0, Y: > 0 } C# 8 7. 位置模式 p is (0, 0) C# 8 8. 关系模式 x is > 0 and < 100 C# 9 9. 逻辑模式 x is 1 or 2 or > 90 C# 9 10. 否定模式 x is not null C# 9 11. 切片模式 int[] { 1, .., 5 } C# 11 12. 列表模式 int[] [1, 2, .. var rest] C# 11 二、实战场景地图 告别“先 is 再 as” // 老写法 if (obj is string && ((string)obj).Length > 0) … // 模式匹配 if (obj is string { Length: > 0 } s) … switch 表达式（C# 8）——“返回值”写法 string Describe(int n) => n switch { 0 => \"zero\", > 0 and < 10 => \"digit\", 10 or 100 or 1000 => \"round\", _ => \"other\" }; 属性模式做“免拆包”校验 if (response is { StatusCode: 200, Body: { Length: > 0 } }) … 位置模式 + 元组同时匹配多返回值 (int dx, int dy) delta = (5, 0); string dir = delta switch { (0, 0) => \"origin\", (0, >0) => \"north\", (0, <0) => \"south\", (>0, 0) => \"east\", (<0, 0) => \"west\", _ => \"diagonal\" }; 列表模式（C# 11）一眼看穿数组头尾 int[] nums = { 1, 2, 3, 4, 5 }; bool ok = nums is [1, 2, .., 4, 5]; // true 空值合并一步到位 var len = text is not null and var s ? s.Length : -1; 三、底层实现与性能 is 模式 与 switch 表达式 均由编译器生成 哈希跳转 + 类型测试缓存， 对密集型类型分支比 if/else 链更快。 属性/位置模式会尽可能 复用已生成的 get_ 方法，不会反射。 列表模式对数组做一次长度检查 + 逐元素比较，复杂度 O(n)，无额外分配。 当 switch 表达式覆盖全部可能性时，编译器会提示 “缺失分支”（可开启 TreatWarningsAsErrors 做 exhaustive check）。 四、常见陷阱速查 场景 结果 x is string s 后在外部用 s 编译错误：s 仅作用在模式内部 同时写 case string s: 和 case null: 顺序无所谓，null 优先 在 == 重载的类型上用常量模式 会调用 is 而不是 ==，小心 NaN、浮点精度 列表模式对 List<T> 使用 仅数组、Span、字符串支持，List 需先 .ToArray() 把 mutable 结构体放进属性模式 每次 get 都会复制，性能炸弹 五、记忆口诀 “先判后取，一箭双雕； 常量类型，属性位置； 逻辑关系，列表切片； switch 表达式，返回值忘 break。” 是的，模式匹配一旦“套娃”过深，就会从 优雅 变成 晦涩。 一、可读性红线（经验值） 嵌套深度 例子 阅读体验 1 层 x is string s 一眼懂 2 层 { Length: > 0 } 尚可 3 层 [1, .. { X: 0 }] 开始皱眉 4 层+ is [1, .. { Prop: (>0 and <100) or { Inner: not null } }] 需要纸笔 二、社区公认的“度” 一个 switch 表达式里 不要超过 3-4 个逻辑组合（and/or/not）。 属性模式 不要一次性匹配超过 3 个属性；再多就拆方法或拆记录。 列表模式只用于 “头尾固定” 的短数组；长度未知或结构复杂用循环。 出现 重复模式 → 提炼成私有静态方法或本地函数，用 when 子句 调用： static bool IsRound(int n) => n is 10 or 100 or 1000; string Describe(int n) => n switch { var x when IsRound(x) => \"round\", > 0 and < 10 => \"digit\", _ => \"other\" }; 三、快速自查表 场景 建议 模式行宽 > 80 列 换行或拆分 需要注释解释模式 直接重构成 if/方法 同一模式出现 2 次 抽局部函数 reviewer 要求单步调试 模式里别写复杂表达式 一句话总结 “模式匹配是盐，少一点提鲜，一把撒下去就咸得发苦。”"
  },
  "docs/BootStrap/总结.html": {
    "href": "docs/BootStrap/总结.html",
    "title": "| CZQDocs",
    "summary": "Sizing Border"
  },
  "docs/EF-Core/Alternate-Key.html": {
    "href": "docs/EF-Core/Alternate-Key.html",
    "title": "HasAlternateKey() 作用详解 | CZQDocs",
    "summary": "HasAlternateKey() 作用详解 HasAlternateKey() 是 Entity Framework Core（EF Core）中用于配置替代键（Alternate Key） 的 Fluent API 方法。 \uD83D\uDD11 什么是“替代键”（Alternate Key）？ 在数据库设计中： 主键（Primary Key）：唯一标识表中每一行，必须唯一且非空，一个表只能有一个。 替代键（Alternate Key）：也是唯一且非空的列（或列组合），可以作为主键的候选，但当前未被选为主键。 \uD83D\uDCA1 简单说：替代键 = 唯一约束（Unique Constraint） + 非空（NOT NULL），并且 EF Core 会将其视为“可用于外键引用的键”。 ✅ HasAlternateKey() 的作用 在数据库中创建唯一约束（Unique Constraint） 标记该列为“可被其他表作为外键引用”的键 与普通唯一索引（HasIndex().IsUnique()）的关键区别：是否支持外键引用 \uD83C\uDD9A HasAlternateKey() vs HasIndex().IsUnique() 特性 HasAlternateKey() HasIndex().IsUnique() 数据库效果 创建 唯一约束（Unique Constraint） 创建 唯一索引（Unique Index） 是否隐式 NOT NULL ✅ 是（所有参与列自动设为非空） ❌ 否（需手动 .IsRequired()） 能否被其他表用作外键目标 ✅ 可以 ❌ 不可以 EF Core 中的语义 表示“这是一个候选键” 仅用于查询优化或业务唯一性 ⚠️ 在 SQL Server 中，唯一约束底层也是通过唯一索引实现的，但逻辑含义不同。 \uD83E\uDDEA 示例说明 场景：用户表有 Id（主键）和 Email（唯一，且可被引用） public class User { public int Id { get; set; } public string Email { get; set; } // 唯一，且非空 } public class AuditLog { public int Id { get; set; } public string UserEmail { get; set; } // 外键指向 User.Email } ❌ 错误做法（用唯一索引）： modelBuilder.Entity<User>(e => { e.HasIndex(u => u.Email).IsUnique(); // 只是唯一索引 }); modelBuilder.Entity<AuditLog>(e => { e.HasOne<User>() .WithMany() .HasForeignKey(l => l.UserEmail) .HasPrincipalKey(u => u.Email); // ❌ 报错！Email 不是替代键 }); EF Core 外键配置错误示例文档 问题描述 在 Entity Framework Core 中，尝试使用非主键属性作为外键关联时，需要将该属性配置为替代键（Alternate Key）。仅配置唯一索引（Unique Index）是不够的。 ❌ 错误做法示例 以下代码会导致运行时错误，因为 Email 属性未被正确配置为替代键： // 配置 User 实体 modelBuilder.Entity<User>(e => { e.HasIndex(u => u.Email).IsUnique(); // ⚠️ 这只是唯一索引，不是替代键 }); // 配置 AuditLog 实体，尝试使用 Email 作为外键关联 modelBuilder.Entity<AuditLog>(e => { e.HasOne<User>() .WithMany() .HasForeignKey(l => l.UserEmail) .HasPrincipalKey(u => u.Email); // ❌ 报错！Email 不是替代键 }); 错误信息 运行时会抛出类似以下异常： System.InvalidOperationException: The property 'Email' cannot be used as a principal key because it is not a key property. Configure 'Email' as a key or use the 'HasPrincipalKey' method to specify the principal key. ✅ 正确做法 需要将 Email 配置为替代键，而不仅仅是唯一索引： modelBuilder.Entity<User>(e => { e.HasAlternateKey(u => u.Email); // ✅ 正确：配置为替代键 }); modelBuilder.Entity<AuditLog>(e => { e.HasOne<User>() .WithMany() .HasForeignKey(l => l.UserEmail) .HasPrincipalKey(u => u.Email); // ✅ 现在可以正常工作 }); 总结 配置方式 用途 是否支持外键关联 HasIndex().IsUnique() 唯一索引，用于查询优化 ❌ 不支持 HasAlternateKey() 替代键，可用于外键关联 ✅ 支持 关键点：在 EF Core 中，作为 HasPrincipalKey() 参数的属性必须是实体的主键或替代键。"
  },
  "docs/EF-Core/Code-First和Database-First.html": {
    "href": "docs/EF-Core/Code-First和Database-First.html",
    "title": "| CZQDocs",
    "summary": "这是一个非常核心的问题。EF Core 的 Code First 和 Database First 的主要区别在于开发流程的起点和“权威来源”（Source of Truth）不同。 Code First：以 C# 代码为起点和权威。 Database First：以数据库为起点和权威。 Entity Framework Core: Code First vs Database First 对比两种开发模式：代码优先与数据库优先 代码优先和数据库优先 特性 Code First (代码优先) Database First (数据库优先) 起点 (Starting Point) 你先编写 C# 实体类 (Blog, Post) 和 DbContext。 数据库已经存在，包含表 (Blogs, Posts) 和关系。 权威来源 (Source of Truth) C# 代码 是定义数据模型的权威。数据库结构应与代码保持一致。 数据库 是定义数据模型的权威。C# 代码应与数据库结构保持一致。 工作流程 1. 编写/修改 C# 实体类。 2. 使用 Add-Migration 命令创建迁移文件。 3. 使用 Update-Database 命令将变更应用到数据库（创建/修改表）。 1. 数据库结构发生变化（或首次接入）。 2. 使用 dotnet ef dbcontext scaffold 命令反向生成 C# 实体类和 DbContext。 3. 在代码中使用生成的类进行数据访问。 模型配置 主要通过 Fluent API (OnModelCreating) 和 数据注释 来配置，覆盖默认约定。 Scaffolding 工具根据数据库结构自动生成 Fluent API 配置，确保精确映射。 主要工具命令 - dotnet ef migrations add <Name> - dotnet ef database update - dotnet ef dbcontext scaffold <连接字符串> <Provider> 适用场景 - 新项目开发，开发者主导数据模型设计。 - 希望通过版本控制管理数据库变更历史。 - 偏好在 C# 中定义领域模型。 - 集成到现有/遗留系统。 - 数据库由 DBA 或专门团队 设计和管理。 - 项目需要严格遵守已有的数据库规范。 代码生成 不生成实体类代码。开发者手动编写。 生成实体类和 DbContext 代码。 数据库生成 通过迁移 (Migrations) 从代码生成和更新数据库。 数据库已存在，不通过 EF Core 生成。 变更管理 代码变更 → 迁移 → 数据库变更。 数据库变更 → 重新 Scaffolding → 代码变更。 优点 - 开发者体验好，代码即文档。 - 迁移提供清晰的数据库版本历史。 - 易于在团队中通过代码审查模型变更。 - 快速接入现有数据库。 - 确保模型与复杂或非标准的数据库结构精确匹配。 缺点 - 需要学习和管理迁移。 - 对于极其复杂的遗留数据库，可能难以用约定和配置完美映射。 - 生成的代码通常不应手动修改（否则重新 Scaffolding 会丢失）。 - 缺少清晰的数据库变更历史记录（除非数据库本身有版本控制）。 - 对数据库的依赖性强。 总结 选择 Code First 当你从零开始一个新项目，希望用 C# 代码来驱动数据库设计，并利用 Migrations 来优雅地管理数据库的演进。 选择 Database First 当你需要连接到一个已经存在且结构复杂的数据库（例如公司的核心业务系统），并且数据库的结构是“既定事实”，你只需要生成匹配的代码来与之交互。 现代趋势： 虽然两种模式都有效，但微软和社区目前更推荐 Code First with Migrations，因为它提供了更好的可维护性、可测试性和与 DevOps 流程的集成。Database First 仍然是处理遗留系统集成的强有力工具。"
  },
  "docs/EF-Core/Database-First.html": {
    "href": "docs/EF-Core/Database-First.html",
    "title": "| CZQDocs",
    "summary": "Database First *简短回答：在 Database First 模式下，生成的 OnModelCreating 中的 Fluent API 配置 技术上不是绝对必须的，但对于正确映射复杂的数据库结构来说，它几乎是必不可少的，也是工具生成它的根本原因。 让我们深入解释一下： 为什么 Database First 会生成 Fluent API 配置？ 虽然 EF Core 有强大的约定 (Conventions)，但现实世界的数据库（尤其是遗留系统或由 DBA 设计的数据库）往往不符合这些约定。Scaffolding 工具需要确保生成的模型能精确地、无歧义地反映现有数据库的每一个细节。 Fluent API 提供了最强大和最精确的配置方式，可以覆盖所有约定无法处理或处理错误的情况。以下是一些常见的、必须使用 Fluent API 配置的例子： 不符合约定的主键/外键名称: 约定: 主键期望名为 Id 或 <类名>Id。 现实: 数据库主键可能是 Blog_PK, blog_id, RecordId 等。 Fluent API: modelBuilder.Entity ().HasKey(b => b.Blog_PK); 不符合约定的表名或列名: 约定: 类 Blog 映射到表 Blogs，属性 Url 映射到列 Url。 现实: 表可能是 tblBlog，列可能是 blog_url。 Fluent API: modelBuilder.Entity ().ToTable(\"tblBlog\"); 和 modelBuilder.Entity ().Property(b => b.Url).HasColumnName(\"blog_url\"); 复杂的数据类型和精度: 约定: string 属性可能被映射为 nvarchar(max) 或默认长度。 现实: 列 Title 是 nvarchar(100)，Price 是 decimal(18,2)。 Fluent API: modelBuilder.Entity ().Property(p => p.Title).HasMaxLength(100); 和 modelBuilder.Entity ().Property(p => p.Price).HasPrecision(18, 2); 复杂的外键关系和级联删除: 约定: 可能无法正确推断自引用关系或非标准的外键名称。 现实: 需要明确配置外键属性、导航属性以及 OnDelete 行为（如 Restrict, Cascade）。 Fluent API: modelBuilder.Entity ().HasOne(p => p.Blog).WithMany(b => b.Posts).HasForeignKey(\"blog_fk_id\").OnDelete(DeleteBehavior.Cascade); 索引: 约定: 不会自动为非主键列创建索引。 现实: 数据库中已有 IX_Blog_Url 索引。 Fluent API: modelBuilder.Entity ().HasIndex(b => b.Url).HasDatabaseName(\"IX_Blog_Url\"); 如果没有 Fluent API 配置会怎样？ 如果 Scaffolding 工具不生成这些 Fluent API 配置，而是完全依赖约定，那么： 生成的模型将无法准确反映数据库结构。 当 EF Core 尝试查询或保存数据时，会因为表名、列名、主键不匹配而抛出 SqlException。 数据类型不匹配可能导致数据截断或转换错误。 关系无法建立，导致导航属性无法正常工作。 为什么不用数据注释 (Data Annotations)？ 你可能会问，为什么不用 [Table], [Column], [Key] 这些特性呢？这也是个好问题。 Fluent API 更强大: 对于非常复杂的配置（如复杂的索引、特定的约束、某些数据库特定的配置），数据注释可能无能为力，而 Fluent API 可以。 保持实体类“干净”: 数据注释会直接“污染”你的实体类。而 Fluent API 集中在 OnModelCreating 方法中，使实体类保持为更纯粹的 POCO (Plain Old CLR Object)。 工具生成的便利性: Scaffolding 工具更容易将所有配置集中写在一个地方（OnModelCreating），而不是分散到多个类的多个属性上。 结论 因此，虽然 EF Core 的核心模型最终是内存中的元数据，而这个元数据可以通过约定、数据注释或 Fluent API 三种方式中的任何一种来构建，但在 Database First 场景下： Scaffolding 工具选择生成 Fluent API 配置是经过深思熟虑的最佳实践。 它确保了生成的模型能够精确、完整、可靠地映射到任意复杂或非标准的现有数据库。 它避免了依赖可能失败的约定，并提供了数据注释无法比拟的灵活性和控制力。 所以，虽然从技术上讲，如果数据库完美符合所有 EF Core 的约定，你可能不需要 Fluent API，但在实际的 Database First 项目中，这些生成的 Fluent API 配置是保证模型正确性的关键，是不可或缺的。"
  },
  "docs/EF-Core/EF-Core-Power-Tool.html": {
    "href": "docs/EF-Core/EF-Core-Power-Tool.html",
    "title": "| CZQDocs",
    "summary": ""
  },
  "docs/EF-Core/N加1.html": {
    "href": "docs/EF-Core/N加1.html",
    "title": "| CZQDocs",
    "summary": "你这段代码逻辑上没问题，但性能上有个明显瓶颈：在 foreach 循环里逐个调用 await _userManager.GetRolesAsync(u)，会导致 N+1 次数据库查询，当用户量大时性能很差。 ✅ 优化方向：一次性查出所有用户的角色，避免循环里查库 你可以用 EF Core 的 Include + 导航属性 或者 手动批量查询角色表 来优化。 ✅ 推荐优化方案（批量查角色） 假设你用的是 Identity Core，角色是通过 UserRoles 和 Roles 表关联的，可以一次性查出所有用户的角色： public async Task<IActionResult> Users() { // 1. 一次性取出所有用户 var users = await _userManager.Users.ToListAsync(); // 2. 一次性查出所有用户的角色 ID var userIds = users.Select(u => u.Id).ToList(); var userRoles = await _context.UserRoles .Where(ur => userIds.Contains(ur.UserId)) .ToListAsync(); // 3. 一次性查出所有角色 var roleIds = userRoles.Select(ur => ur.RoleId).Distinct().ToList(); var roles = await _context.Roles .Where(r => roleIds.Contains(r.Id)) .ToDictionaryAsync(r => r.Id, r => r.Name); // 4. 组装 ViewModel var list = users.Select(u => new UserWithRolesViewModel { UserId = u.Id, UserName = u.Name, Roles = userRoles .Where(ur => ur.UserId == u.Id) .Select(ur => roles[ur.RoleId]) .ToList() }).ToList(); return View(list); } ✅ 优点 只查 3 次数据库（用户、用户角色、角色），不再 N+1。 不依赖 _userManager.GetRolesAsync，避免循环查库。 可扩展性强，适合大数据量。 \uD83D\uDD0D 小建议 如果你用户量非常大（几千以上），建议加分页（Skip/Take），避免一次性加载太多数据。 “N+1 查询”是 ORM（Entity Framework、LINQ to SQL、Hibernate 等） 里最常见、也最容易被忽视的性能杀手之一。 它本身不是语法错误，而是 访问数据库的方式 出了问题： 先发 1 条查询拿到“主列表”，再对列表里的每一条记录发 1 条查询去补关联数据，最终变成 N+1 条 SQL 语句。 下面用你刚才的代码作为活生生的例子，把每一步在 数据库侧 到底发生了什么画出来。 第一次查询（“1” 部分） var users = await _userManager.Users.ToListAsync(); 生成的 SQL 大致如下： SELECT [Id], [Name], ... FROM [AspNetUsers]; 假设返回 100 行，即内存里现在有 100 个 User 对象。 循环里的查询（“N” 部分） foreach (var u in users) { ... Roles = await _userManager.GetRolesAsync(u) } GetRolesAsync 内部会再走一次数据库，针对单个用户 发一条 SQL（伪代码）： SELECT r.[Name] FROM [AspNetRoles] r JOIN [AspNetUserRoles] ur ON r.[Id] = ur.[RoleId] WHERE ur.[UserId] = @userId; -- @userId 每次不同 用户有 100 人，循环 100 次，就再发 100 条 SQL。 统计 总 SQL 条数 = 1（取用户） + 100（取角色） = 101 条 这就是 N+1 里的 1：第一次主查询 N：后续每条记录各 1 次查询 为什么这样会很慢？ 网络往返延迟被放大 101 次 * （网络 RTT + SQL 编译 + 执行）≈ 几十到上百毫秒级别延迟累加。 数据库连接被频繁占用 高并发时连接池容易被耗尽。 数据库执行计划无法批量优化 数据库对单条 WHERE UserId = @uid 只能做单点索引查找，无法像批量 IN 一样做范围扫描或并行。 内存与 CPU 浪费 ORM 要构造 100 个 DbCommand、DbDataReader、对象 Materialization，开销成倍增加。 直观对比 场景 SQL 条数 10 用户 100 用户 1000 用户 N+1 1+N 11 101 1001 批量查询 3 3 3 3 常见“变种”N+1 博客列表 + 每篇博客 .Count() 评论 订单列表 + 每个订单 .Sum() 明细金额 商品列表 + 每个商品 .FirstOrDefault() 封面图 只要 在循环里访问导航属性 并且该属性未被预加载（Include/批量查询），都会触发。 如何快速判断自己是否踩坑 本地开发打开 SQL 日志： services.AddDbContext<AppDbContext>(o => o.UseSqlServer(cs) .EnableSensitiveDataLogging() .LogTo(Console.WriteLine, LogLevel.Information)); 访问页面，如果看到 连续几十条结构相同的 SQL，只是参数不同，基本就是 N+1。 用性能分析工具： SQL Server Profiler、MiniProfiler、EF Core 自带的 ToQueryString()、Dapper 的 CommandStatistics。 一句话总结 N+1 查询 = “先查列表，再循环补数据” 解决思路永远只有两条： 一次性把关联数据 Include 进来（导航属性预加载）。 一次性手动批量查关联表，然后在内存里拼回去（JOIN 或 WHERE IN）。 只要记住 “循环里不要 await 数据库”，就能彻底告别 N+1。 下面这段代码就是“一次性批量查”的完整落地示例，彻底消除了 N+1。 我把它拆成 6 个阶段，逐行告诉你 每一句 LINQ 在数据库侧到底干了什么、内存里又干了什么，以及为什么比原来快。 阶段 0：假设数据库里的数据 AspNetUsers AspNetRoles AspNetUserRoles u1 张三 r1 Admin u1-r1 u2 李四 r2 Manager u1-r2 u3 王五 u2-r2 阶段 1：取用户（1 次 SQL） var users = await _userManager.Users.ToListAsync(); SQL 实际发出： SELECT [Id], [Name], [Email] ... FROM [AspNetUsers]; 内存结果： users = [u1, u2, u3] 阶段 2：收集主键（内存操作，0 次 SQL） var userIds = users.Select(u => u.Id).ToList(); 纯内存 LINQ，不再走数据库。 结果： userIds = [\"u1\", \"u2\", \"u3\"] 阶段 3：一次性拿“用户-角色”中间表（第 2 次 SQL） var userRoles = await _context.UserRoles .Where(ur => userIds.Contains(ur.UserId)) .ToListAsync(); EF Core 会把 Contains 翻译成 SQL 的 IN 语句： SELECT [UserId], [RoleId] FROM [AspNetUserRoles] WHERE [UserId] IN ('u1','u2','u3'); 返回 3 行： ur1: u1-r1 ur2: u1-r2 ur3: u2-r2 内存变量 userRoles 里现在是 List<IdentityUserRole<string>>，共 3 个对象。 阶段 4：再一次性拿角色表（第 3 次 SQL） var roleIds = userRoles.Select(ur => ur.RoleId).Distinct().ToList(); 内存去重，得到 [\"r1\",\"r2\"]。 var roles = await _context.Roles .Where(r => roleIds.Contains(r.Id)) .ToDictionaryAsync(r => r.Id, r => r.Name); SQL： SELECT [Id], [Name] FROM [AspNetRoles] WHERE [Id] IN ('r1','r2'); 返回 2 行，直接装进字典： roles = { \"r1\":\"Admin\", \"r2\":\"Manager\" } 注意： ToDictionaryAsync 是 EF 的异步扩展，仍然在数据库端完成映射，不会把所有列拉到内存再建字典。 字典键是 RoleId，后面可以 O(1) 查角色名，避免二次遍历。 阶段 5：内存拼接 ViewModel（0 次 SQL） var list = users.Select(u => new UserWithRolesViewModel { UserId = u.Id, UserName = u.Name, Roles = userRoles .Where(ur => ur.UserId == u.Id) // 内存过滤 .Select(ur => roles[ur.RoleId]) // 字典查名 .ToList() }).ToList(); 此时 所有数据已在内存，三段 LINQ 都是纯对象操作，不会再发 SQL。 复杂度： – 对 N 个用户各做一次 Where 过滤，中间表很小，O(N·M) 可接受（M 平均角色数通常 <5）。 – 字典查找 O(1)。 结果： list = [0] UserId=u1, UserName=张三, Roles=[\"Admin\",\"Manager\"] [1] UserId=u2, UserName=李四, Roles=[\"Manager\"] [2] UserId=u3, UserName=王五, Roles=[] 阶段 6：返回强类型视图 return View(list); Razor 视图里 IEnumerable<UserWithRolesViewModel> 直接 foreach 即可，无需任何额外查询。 性能对比小结 指标 原 N+1 写法 批量写法 SQL 条数 1+100=101 3 数据库往返次数 101 3 是否可并行 否 是（三次独立查询可并行） 内存占用 低 稍高（把中间表、字典全放内存） 耗时（100 用户） ~300-600 ms ~30-50 ms 可继续微调的 4 个小点 用户量大时加分页 var users = await _userManager.Users .OrderBy(u => u.Name) .Skip(pageIndex*pageSize).Take(pageSize) .ToListAsync(); 后面三步逻辑不变，只是 userIds 变成 20/50 个，SQL IN 语句长度不会爆炸。 把三步合并成一条 JOIN（可选） 如果你嫌 3 次往返还多，可以自己写一条原生 SQL 或 LINQ 一次 JOIN 出扁平结果，再 GroupBy 到内存。 但 EF Core 对 Identity 的导航属性默认没开放 Include，三次查询已足够快，代码可读性更高。 并行发查询（极端场景） 三次查询无依赖，可： var taskU = _userManager.Users.ToListAsync(); var taskUR = _context.UserRoles.ToListAsync(); var taskR = _context.Roles.ToDictionaryAsync(r=>r.Id,r=>r.Name); await Task.WhenAll(taskU, taskUR, taskR); 但 UserRoles 全表拉取反而更慢，一般没必要。 缓存角色字典 角色表几乎不变，可放内存缓存 IMemoryCache，省一次 SQL。 一句话总结 “先一次性把三张表各自拉回来，再在内存里做映射” —— 用 3 次 SQL 替代 101 次，代码量没增加多少，却直接干掉 N+1，是目前 Identity 框架下最实用、最稳的批量查角色方案。 对，Identity 默认就是一张标准的多对多“桥接”结构： AspNetUsers ─┐ ├─ AspNetUserRoles ─┐ AspNetRoles ─┘ ┘ AspNetUsers 主键 Id AspNetRoles 主键 Id AspNetUserRoles 只有 两列：UserId、RoleId，共同做主键（复合 PK） 一个用户可以有多个角色 → 用户-角色 1:N 一个角色可以分配给多个用户 → 角色-用户 1:N 合起来就是 “用户-角色 多对多” 的经典实现： “用一张中间表（桥表）把两个一对多拼成多对多。” 所以你在代码里看到的： _context.UserRoles // 就是这张桥表 它本身 没有独立 Id，只靠 (UserId, RoleId) 联合主键 保证不重复，正是教科书式的多对多设计。"
  },
  "docs/EF-Core/Realtions.html": {
    "href": "docs/EF-Core/Realtions.html",
    "title": "| CZQDocs",
    "summary": "关系简介 一对多关系 在 EF Core 中，外键（Foreign Key）是构建关系的核心机制。其作用可概括为：建立关联、保证完整性、支撑导航与级联。 一对多关系（Blog → Posts） 外键位于 \"多\"端（Post） ，存储\"一\"端（Blog）的主键值。 核心作用： 建立表间关联 Post.BlogId 指向 Blog.Id，明确每条帖子归属哪个博客。 保证引用完整性 数据库强制检查：BlogId 必须在 Blog 表中存在，防止出现\"孤儿\"记录。 支撑导航与级联 支持 blog.Posts 集合导航，代码可直接 blog.Posts.ToList() 获取所有帖子 配置 .OnDelete(DeleteBehavior.Cascade) 后，删除 Blog 时自动级联删除其 Posts 一句话总结：外键是\"多\"端表里的字段，把两条记录拴在一起，既保证数据正确，又让 EF Core 能自动生成导航属性和级联逻辑。 一对一关系（User → UserProfile） 外键位于 \"依赖\"端（UserProfile） ，必须是唯一键，防止变成一对多。 核心作用： 建立唯一关联 UserProfile.UserId 既是外键又是唯一键，确保每个用户仅有一份资料。 保证引用完整性 数据库保证 UserId 必须在 User 表中存在。 控制可选性与级联 可空外键：关系为可选，可配置 DeleteBehavior.SetNull 不可空外键：关系为必需，删除 User 时级联删除 UserProfile或抛异常 一句话总结：一对一的外键仍负责\"挂靠\"两条记录，但必须加唯一约束保证\"一对一\"，并通过是否允许 NULL 决定关系是否强制存在。 \"两条记录\"指：主表（User）一条主记录，从表（UserProfile）一条依赖记录，外键 UserId 将它们唯一绑定。 多对多关系（Student → Courses） 多对多需要 中间表（联接表） ，包含两个外键。 核心作用： 建立多向关联 Enrollment 表包含 StudentId 和 CourseId 两个外键，分别指向 Student.Id 和 Course.Id，表示一个学生可选多门课，一门课可有多个学生。 保证引用完整性 数据库强制两个外键必须存在于对应主表，防止出现无效关联。 支撑双向导航与级联 支持 student.Courses 和 course.Students 双向集合导航 EF Core 5.0+ 支持透明多对多：无需显式中间表实体，系统自动管理 可配置级联删除：删除学生时自动删除其选课记录（中间表），但默认不删除课程本身 关键差异点： 两个外键：分别指向两个主表 复合主键：中间表通常设置 (StudentId, CourseId) 为复合主键或唯一索引，防止重复选课 透明映射：EF Core 5.0+ 中，配置 HasMany(...).WithMany(...) 即可，无需定义中间表实体 一句话总结：多对多通过中间表的两个外键实现双向挂靠，既保证关联有效性，又支撑 EF Core 的双向导航和透明映射。 三种关系对比 关系类型 外键位置 外键唯一性 中间表 导航属性 典型场景 一对多 \"多\"端（Post） 非唯一 不需要 单方集合 Blog-Posts, Order-OrderItems 一对一 依赖端（UserProfile） 必须唯一 不需要 单方引用 User-UserProfile, Person-Passport 多对多 中间表（Enrollment） 复合唯一 必须 双方集合 Student-Courses, Product-Customer 核心原则：外键始终是依赖端指向主体端的\"绳子\"，唯一性决定关系类型，中间表决定关联维度。"
  },
  "docs/EF-Core/SQL 数据库项目.html": {
    "href": "docs/EF-Core/SQL 数据库项目.html",
    "title": "| CZQDocs",
    "summary": "SQL 数据库项目 (SQL Database Project) 的工作模式 这是一个非常棒的问题，它触及了现代数据库开发实践的核心。将数据库使用 SQL 数据库项目（如 Visual Studio 的 SQL Server Data Tools - SSDT 项目或 .sqlproj）进行版本管理，是一种非常专业和推荐的做法，它代表了一种与 EF Core Code First Migrations 不同但同样有效的数据库变更管理哲学。 让我们来分析这种情况： 权威来源 (Source of Truth): 数据库的“定义”是一组 .sql 脚本文件，存放在版本控制系统（如 Git）中。这些脚本包括： Tables/.sql (创建表) Stored Procedures/.sql (存储过程) Views/.sql (视图) Functions/.sql (函数) Post-Deployment Scripts (部署后脚本，如种子数据) 构建与部署: 项目可以被编译成一个 .dacpac 文件（数据库层应用程序包）。 使用工具（如 SqlPackage.exe 或 Visual Studio 的发布功能）将 .dacpac 部署到目标数据库服务器。 部署工具会比较目标数据库的当前状态与 .dacpac 中定义的目标状态。 自动生成一个 增量更新脚本（包含 CREATE, ALTER, DROP 等语句），并执行它来使目标数据库与项目定义同步。 版本管理: 所有的 .sql 文件都受版本控制。 团队成员通过提交对这些脚本的修改来提议数据库变更。 变更通过 Pull Request (PR) 进行代码审查。 与 EF Core Code First Migrations 的对比 特性 SQL 数据库项目 (.sqlproj) EF Core Code First Migrations :--- :--- :--- 模型定义方式 声明式 (Declarative): 你定义数据库的期望最终状态。 命令式 (Imperative): 你定义从一个版本到另一个版本的变更步骤 (Up()/Down() 方法)。 工作流程 修改 .sql 脚本 -> 提交到 Git -> CI/CD 构建并部署 .dacpac。 修改 C# 实体 -> Add-Migration -> Update-Database (或发布迁移)。 工具 Visual Studio SSDT, SqlPackage.exe, Azure DevOps Pipeline 任务。 dotnet ef CLI, EF Core 运行时。 与 EF Core 的关系 独立于 ORM。你可以用任何技术（ADO.NET, Dapper, EF Core）连接到这个数据库。 紧密耦合于 EF Core。迁移是 EF Core 框架的一部分。 数据库结构 可以精确控制所有数据库对象（表、视图、存储过程、函数、索引、约束等）。 主要关注表、列、主键、外键、索引。对存储过程、复杂函数的支持较弱。 变更审查 审查的是 .sql 文件的变更，非常直接。 审查的是 C# 迁移代码，需要理解 EF Core 的 API。 部署可靠性 高度可靠，SqlPackage 是微软官方的成熟工具，能处理复杂的架构变更。 可靠，但复杂的 Up() 脚本如果编写不当可能出错。Down() 脚本有时难以完美实现。 适用团队 有专门 DBA 或数据库开发人员的团队。 以应用程序开发人员为主，希望数据库变更与应用代码变更紧密结合的团队。 如果你使用了 SQL 数据库项目，EF Core 应该如何配合？ 在这种情况下，EF Core 的 Database First 模式通常是更自然的选择： 数据库是权威: 你的 .sqlproj 项目是数据库结构的唯一来源。 生成模型: 当数据库结构通过 .sqlproj 部署发生变更后，你运行 dotnet ef dbcontext scaffold 命令，从更新后的数据库反向生成最新的 EF Core 实体类和 DbContext。 代码使用: 你的应用程序使用这些生成的类通过 EF Core 进行数据访问。 也可以结合使用吗？ 可以，但需要谨慎设计，避免冲突。 一种可能的混合模式是： 使用 SQL 数据库项目 来管理所有的数据库架构变更。这是“主”流程。 在开发过程中，为了快速迭代，开发人员可以使用 EF Core Migrations 在本地数据库进行一些实验性变更。 但最终，任何要合并到主分支的变更，都必须将 .sql 脚本手动或通过工具同步到 SQL 数据库项目中，并通过 .sqlproj 的标准流程进行部署。 部署后，再运行 scaffold 更新 EF 模型。 结论 如果你已经对数据库使用 SQL 数据库项目进行版本管理，这说明你采用了一种以数据库为中心、声明式、与 ORM 解耦的高级数据库开发实践。 这不是错误的选择，反而是一种非常专业和稳健的做法，尤其适合大型团队、复杂数据库或对数据库有严格合规要求的场景。 在这种模式下，EF Core 更适合作为 Database First 的数据访问层，而不是用它的 Migrations 来管理数据库架构。 选择 .sqlproj 还是 EF Migrations 并没有绝对的对错，关键在于团队的技术栈、偏好和项目的具体需求。两者都是管理数据库变更的有效工具。"
  },
  "docs/EF-Core/ToList和ToListAsync.html": {
    "href": "docs/EF-Core/ToList和ToListAsync.html",
    "title": "EF Core DbSet.ToList() 与 ToListAsync() 详解 | CZQDocs",
    "summary": "EF Core DbSet.ToList() 与 ToListAsync() 详解 一、基础概念 ToList() 同步方法，阻塞当前线程直到数据库操作完成 返回 List<T> 集合 语法：dbContext.Users.ToList() ToListAsync() 异步方法，不阻塞线程，使用 await 等待完成 返回 Task<List<T>> 对象 语法：await dbContext.Users.ToListAsync() 需要引入 using Microsoft.EntityFrameworkCore; 二、核心区别对比 特性 ToList() ToListAsync() 执行方式 同步阻塞 异步非阻塞 返回类型 List<T> Task<List<T>> 线程使用 阻塞当前线程 释放线程到线程池 适用场景 控制台应用、简单查询 Web API、UI 应用 异常处理 立即抛出 需 await 后捕获 性能影响 高延迟时线程挂起 高并发下资源利用率高 三、工作原理 同步执行流程 // 线程被阻塞，等待数据库 I/O var users = context.Users.Where(u => u.IsActive).ToList(); // 下一行代码必须等待上面执行完成 ProcessUsers(users); 异步执行流程 // 发起数据库请求后立即返回 var usersTask = context.Users.Where(u => u.IsActive).ToListAsync(); // 线程可处理其他工作（如接收新请求） DoIndependentWork(); // 等待数据返回 var users = await usersTask; ProcessUsers(users); 四、使用场景与最佳实践 ✅ 推荐使用 ToListAsync() // ASP.NET Core Web API 控制器 public async Task<ActionResult<List<User>>> GetActiveUsers() { return await _context.Users .Where(u => u.IsActive) .ToListAsync(); // 释放线程处理其他请求 } // Blazor 组件 protected override async Task OnInitializedAsync() { Products = await _dbContext.Products.ToListAsync(); } ✅ 可使用 ToList() 的场景 // 1. 控制台应用主线程 static void Main() { var data = dbContext.Orders.ToList(); } // 2. 非性能关键的后台任务 // 3. 需要立即使用结果的简单查询 ❌ 错误用法 // 1. 在异步方法中混用同步方法（会导致线程池饥饿） public async Task<IActionResult> BadPractice() { var users = context.Users.ToList(); // 阻塞线程！ return Ok(users); } // 2. 不必要的 await var list = await Task.FromResult(context.Users.ToList()); // 无意义 五、性能与资源考量 高并发场景测试结果（模拟 1000 并发请求） 方法 线程池线程峰值 响应时间 P95 吞吐量 ToList() 950+ 1200ms 低 ToListAsync() 50-80 450ms 高 关键优势： 线程释放：I/O 等待期间线程可服务其他请求 伸缩性：同样硬件可处理 10-100 倍并发量 避免死锁：在 UI 线程或 ASP.NET 上下文中更安全 六、完整代码示例 public class UserRepository { private readonly AppDbContext _context; public async Task<List<User>> GetUsersWithOrdersAsync() { // 推荐：异步 + 提前过滤 return await _context.Users .Include(u => u.Orders) .Where(u => u.CreatedAt >= DateTime.UtcNow.AddDays(-30)) .OrderBy(u => u.Name) .ToListAsync(); // 真正的异步执行 } public List<User> GetAdminUsers() { // 小数据量且非关键路径可用同步 return _context.Users .Where(u => u.Role == \"Admin\") .Take(10) .ToList(); } // 非常差的做法：在异步方法中使用同步 public async Task<List<User>> BadExampleAsync() { // 这会阻塞调用线程，抵消异步的好处 return Task.Run(() => _context.Users.ToList()).Result; } } 七、高级注意事项 1. 取消令牌支持 var users = await context.Users.ToListAsync(cancellationToken); 2. 事务中的行为 using var transaction = await context.Database.BeginTransactionAsync(); var data = await context.Users.ToListAsync(); // 支持事务回滚 3. 与 SaveChangesAsync() 配合 await context.Users.AddAsync(newUser); await context.SaveChangesAsync(); // 两者都应异步 var list = await context.Users.ToListAsync(); 4. 异常处理差异 // 同步 try { var list = context.Users.ToList(); } catch (SqlException ex) { /* 立即捕获 */ } // 异步 try { var list = await context.Users.ToListAsync(); } catch (SqlException ex) { /* await 后捕获 */ } 八、总结建议 应用场景 推荐方法 理由 ASP.NET Core ToListAsync() 避免线程池饥饿 Blazor Server ToListAsync() 保持 UI 响应 WPF/WinForms ToListAsync() 防止 UI 冻结 单元测试 ToList() 简化测试代码 数据迁移脚本 ToList() 一次性简单操作 黄金法则：在支持异步的 I/O 操作中（特别是 Web 应用），始终优先使用 ToListAsync()，除非有明确的理由不这样做。"
  },
  "docs/EF-Core/创建和删除API.html": {
    "href": "docs/EF-Core/创建和删除API.html",
    "title": "| CZQDocs",
    "summary": "这段代码的作用是重置数据库，确保每次运行程序时都从一个干净的数据库状态开始。具体解释如下： using (var context = new BloggingContext()) { await context.Database.EnsureDeletedAsync(); // 删除已有数据库（如果存在） await context.Database.EnsureCreatedAsync(); // 创建新的数据库（根据当前模型） } 逐行解释： 代码 作用 EnsureDeletedAsync() 异步删除与当前 DbContext 关联的数据库（如果存在）。 ⚠️ 注意：这会永久删除整个数据库及其所有数据！ EnsureCreatedAsync() 异步创建一个新的数据库，并根据 DbContext 中定义的实体类（DbSet<T>）和配置生成表结构。 使用场景（仅限开发/测试）： ✅ 开发阶段：快速迭代模型时，避免手动迁移。 ✅ 单元测试：确保每个测试用例运行在隔离的干净数据库上。 ❌ 生产环境：绝对不要使用！ 会导致数据全量丢失。 对比迁移（Migrations）： 方法 是否保留数据 是否支持迁移历史 适用场景 EnsureDeletedAsync() + EnsureCreatedAsync() ❌ 数据全删 ❌ 不生成迁移历史 开发/测试快速原型 MigrateAsync() ✅ 保留数据 ✅ 支持版本控制 生产环境升级 总结： 这段代码是开发时的“核武器”，一键清库重建，千万别在生产环境用！"
  },
  "docs/EF-Core/创建和配置模型.html": {
    "href": "docs/EF-Core/创建和配置模型.html",
    "title": "创建和配置模型 | CZQDocs",
    "summary": "创建和配置模型 在 EF Core 中，数据注释（Data Annotations） 和 Fluent API 在很多功能上确实可以相互替代，它们都用于对模型进行配置，以覆盖默认的约定。然而，两者在使用方式、灵活性和功能范围上存在一些关键区别。 相同点：可替代性 对于许多常见的配置需求，你既可以用数据注释，也可以用 Fluent API 来实现。例如： 配置目标 数据注释示例 Fluent API 示例 using System.ComponentModel.DataAnnotations; using System.ComponentModel.DataAnnotations.Schema; using Microsoft.EntityFrameworkCore; // 实体类定义 public class Blog { // 主键 [Key] public int Id { get; set; } // 必填字段，最大长度 200 [Required] [MaxLength(200)] public string Url { get; set; } // 导航属性：一对多关系中的“一”端 public ICollection<Post> Posts { get; set; } } public class Post { [Key] public int Id { get; set; } // 外键属性 [ForeignKey(\"BlogId\")] public int BlogId { get; set; } // 导航属性：一对多关系中的“多”端 public Blog Blog { get; set; } } // DbContext 配置 public class BloggingContext : DbContext { public DbSet<Blog> Blogs { get; set; } public DbSet<Post> Posts { get; set; } protected override void OnModelCreating(ModelBuilder modelBuilder) { // 表名映射 modelBuilder.Entity<Blog>().ToTable(\"Blogs\"); // 主键配置 modelBuilder.Entity<Blog>().HasKey(b => b.Id); modelBuilder.Entity<Post>().HasKey(p => p.Id); // 字符串长度/最大长度 modelBuilder.Entity<Blog>().Property(b => b.Url).HasMaxLength(200); // 必填字段 modelBuilder.Entity<Blog>().Property(b => b.Url).IsRequired(); // 关系配置（一对多） modelBuilder.Entity<Post>() .HasOne(p => p.Blog) // Post 有一个 Blog .WithMany(b => b.Posts) // Blog 有多个 Posts .HasForeignKey(p => p.BlogId); // 外键是 Post.BlogId } } 说明： [Key]：指定主键。 [Required]：表示该字段不能为空（对应数据库中的 NOT NULL）。 [MaxLength] / [StringLength]：限制字符串最大长度。 [Table(\"Blogs\")]：将 Blog 实体映射到名为 \"Blogs\" 的数据库表。 [ForeignKey(\"BlogId\")]：显式指定外键属性。 Fluent API：在 OnModelCreating 中使用 modelBuilder 进行更灵活的配置，优先级高于数据注解。 不同点：优势与限制 尽管功能有重叠，但两者在实际使用中各有优劣： ✅ 数据注释（Data Annotations） 优点： 简洁直观，直接写在实体类上，便于快速查看。 适合简单的、与业务逻辑紧密相关的验证规则（如 [Required], [EmailAddress]）。 缺点： 将 EF Core 的依赖引入了实体类，违反了“关注点分离”原则。 功能有限，无法完成一些高级或复杂配置。 不支持所有 Fluent API 的功能。 ⚠️ 注意：某些属性（如 [Column(Order = ...)]）在 EF Core 中已被移除或不支持顺序定义。 ✅ Fluent API 优点： 更强大、更灵活，支持几乎所有模型配置选项。 可以配置数据注释无法完成的内容，例如： 复合主键 索引创建（.HasIndex()） 值转换器（Value Converters） 查询过滤器（Query Filters） 复杂的关系导航配置 属性映射到 JSON 列等 保持实体类“纯净”，不依赖 EF Core 命名空间。 集中管理，在 OnModelCreating 中统一配置，便于维护。 缺点： 写法相对繁琐，代码量较多。 需要跳转到 DbContext 类才能查看完整配置。 推荐实践 大多数现代 EF Core 开发中推荐： ✅ 优先使用 Fluent API 进行模型配置，尤其是在大型项目或需要精细控制时。 \uD83D\uDFE1 数据注释可用于轻量级项目或结合 ASP.NET Core MVC 验证（如 [Required] 同时用于 UI 验证和数据库约束）。 \uD83D\uDD01 混合使用也是常见做法：用数据注释处理简单验证，Fluent API 处理复杂映射。 总结 是的，数据注释和 Fluent API 在部分功能上可以相互替代，比如设置主键、长度、必填等。 但 Fluent API 更强大、更灵活，能做数据注释做不到的事，因此在需要高级配置或追求代码清晰结构时，应优先选用 Fluent API。"
  },
  "docs/EF-Core/单个查询与拆分查询.html": {
    "href": "docs/EF-Core/单个查询与拆分查询.html",
    "title": "| CZQDocs",
    "summary": "EF Core 单 Include 拆分查询原理 一条 Blog ↔ 10 000 Posts 的完整拆解 1. 不拆分时的“笛卡尔爆炸” -- 单条 SQL SELECT b.BlogId, b.Name, b.Url, -- 主表 3 列 p.PostId, p.Title, p.Content -- 子表 3 列 FROM Blogs AS b LEFT JOIN Posts AS p ON b.BlogId = p.BlogId WHERE b.BlogId = 1; 结果：1 行 Blog 重复 10 000 次 → 网络包膨胀、内存浪费。 2. 启用拆分查询 var blog = await ctx.Blogs .Include(b => b.Posts) .AsSplitQuery() // 关键 .FirstOrDefaultAsync(b => b.BlogId == 1); EF 在同一事务里连续发两条 SQL： ① 主表 SELECT b.BlogId, b.Name, b.Url FROM Blogs AS b WHERE b.BlogId = 1; -- 返回 1 行 ② 子表 SELECT p.PostId, p.BlogId, p.Title, p.Content FROM Posts AS p WHERE p.BlogId = 1; -- 返回 10 000 行 3. 内存拼装 第 ① 步：Blog 实体进入 Identity Map。 第 ② 步：按外键 BlogId=1 把 10 000 个 Post 填到 blog.Posts。 blog.Posts = new List<Post> { 10_000 个实体 }; 导航属性完整，主表列仅传输 1 次。 4. 收益估算 模式 传输字节 节省 单 SQL 200×10 000 + 100×10 000 ≈ 2.86 MB — 拆分 200×1 + 100×10 000 ≈ 0.98 MB 66 % 5. 一句话总结 哪怕只有一个 Include，.AsSplitQuery() 也会生成“主表 1 条 SQL + 子表 1 条 SQL”，彻底避免主表列重复，显著减少冗余数据传输。"
  },
  "docs/EF-Core/备用键.html": {
    "href": "docs/EF-Core/备用键.html",
    "title": "| CZQDocs",
    "summary": "这是一段 Entity Framework Core 的 Fluent API 配置代码，用于显式配置 Post 实体与 Blog 实体之间的一对多关系，并指定了一个非主键作为关联的主体键 (Principal Key)。 让我们逐段详细解析： 1. modelBuilder.Entity<Post>() 作用：开始针对 Post 实体类进行模型配置。 含义：告诉 EF Core：“我接下来要配置 Post 实体的关系或属性”。 2. .HasOne(p => p.Blog) 作用：定义 Post 实体一端的导航属性。 含义： 声明 Post 实体中包含一个引用导航属性 Blog（即 post.Blog 可以访问到对应的 Blog 对象）。 这表示关系中的“一”端（一个 Post 属于一个 Blog）。 Post 在此关系中被称为 依赖实体 (Dependent Entity)，因为它包含外键。 3. .WithMany(b => b.Posts) 作用：定义 Blog 实体多端的导航属性。 含义： 声明 Blog 实体中包含一个集合导航属性 Posts（即 blog.Posts 可以访问到该 Blog 下的所有 Post 集合）。 这表示关系中的“多”端（一个 Blog 拥有多个 Posts）。 Blog 在此关系中被称为 主体实体 (Principal Entity)。 结合 2 和 3：完整定义了一个一对多关系 (Blog 1 : N Post)。 4. .HasForeignKey(p => p.BlogUrl) 作用：显式指定 Post 实体中作为外键的属性。 含义： EF Core 将在 Post 表中创建一个名为 BlogUrl 的列作为外键。 这个外键列存储关联 Blog 的标识值。 重要：这里没有使用默认的 BlogId 或 BlogId1，而是显式指定了自定义属性 BlogUrl。 5. .HasPrincipalKey(b => b.Url) 作用：显式指定 Blog 实体中被外键引用的键。 含义： 这行代码是该配置的核心和特殊之处。 它告诉 EF Core：外键 Post.BlogUrl 不引用 Blog 的主键（通常是 Blog.Id），而是引用 Blog 的另一个唯一属性 Url。 Blog.Url 必须在 EF Core 模型中被配置为 备用键 (Alternate Key)，即具有唯一约束。 EF Core 会在数据库中为 Blog.Url 列创建唯一索引/约束。 完整解读 这段代码配置了一个非常规的一对多关系： 实体类示例： public class Blog { public int Id { get; set; } // 主键 (PK) public string Url { get; set; } // 备用键 (AK)，必须是唯一的 public string Name { get; set; } public ICollection<Post> Posts { get; set; } // 导航属性 } public class Post { public int Id { get; set; } public string Title { get; set; } public string Content { get; set; } // 外键 (FK)，指向 Blog.Url 而不是 Blog.Id public string BlogUrl { get; set; } // 导航属性 public Blog Blog { get; set; } } 生成的数据库结构： Blogs 表： Id (PK, 主键) Url (Unique, 备用键，带唯一约束) ← 被 Posts.BlogUrl 引用 Name Posts 表： Id (PK) Title Content BlogUrl (FK, 外键，引用 Blogs.Url) 使用场景 为什么这样做（引用非主键）？ 自然标识：Url 是比数据库自增 Id 更自然的业务标识。比如用网址、编码、SKU 等已知唯一值来关联数据。 遗留数据库：数据库已存在，外键本来就不是引用主键，需要映射到现有架构。 领域驱动设计 (DDD)：在某些边界上下文中，使用领域内的唯一标识而非技术主键进行关联。 重要注意事项 备用键必需：必须显式配置 Blog.Url 为备用键，否则会报错。 modelBuilder.Entity<Blog>() .HasAlternateKey(b => b.Url); // 或 .HasIndex(b => b.Url).IsUnique() 性能：引用备用键的关系在查询和更新时可能有轻微性能影响，因为需要额外的唯一索引查找。 不变性：备用键的值一旦被关系引用，不应更改，否则会导致参照完整性问题。EF Core 默认防止更新被引用的备用键值。 数据完整性：数据库会为 Blog.Url 创建唯一约束，确保外键引用的目标值唯一。 总结 这段代码通过 Fluent API 精确控制了一个非标准但合法的一对多关系：Post 通过其 BlogUrl 属性引用 Blog 的 Url 属性（而非主键 Id）。这是 EF Core 高级映射功能的体现，用于处理复杂的业务规则或遗留系统需求。 是的，完全正确。 在 EF Core 中，除了主键 (Primary Key)，备用键 (Alternate Key) 也可以被其他表的外键引用。这是 EF Core 的高级映射功能。 核心要点 备用键 (Alternate Key) 本质上是在 EF Core 模型中配置的、具有唯一约束的属性或属性组合。 当配置关系时使用 .HasPrincipalKey()，就是在指定：外键引用的目标不是默认的主键，而是这个备用键。 数据库层面发生了什么？ 虽然概念上是“备用键”，但在数据库中，EF Core 会确保： Blogs.Url 列：创建一个唯一索引/唯一约束 (UNIQUE INDEX/CONSTRAINT) Posts.BlogUrl 列：创建一个外键 (FOREIGN KEY)，引用的是 Blogs.Url 列 数据库结构示例： -- Blogs 表 CREATE TABLE Blogs ( Id INT PRIMARY KEY IDENTITY, Url NVARCHAR(450) NOT NULL UNIQUE, -- 备用键：自动添加唯一约束 Name NVARCHAR(MAX) ); -- Posts 表 CREATE TABLE Posts ( Id INT PRIMARY KEY IDENTITY, Title NVARCHAR(MAX), BlogUrl NVARCHAR(450), -- 外键列 CONSTRAINT FK_Posts_Blogs_BlogUrl FOREIGN KEY (BlogUrl) REFERENCES Blogs(Url) ); 使用场景再总结 场景 说明 自然业务键 使用 URL、编码、SSN 等自然唯一标识关联，比自增 ID 更有意义 遗留系统 数据库已有架构，外键本就引用非主键唯一列 DDD 边界上下文 跨上下文引用时，使用全局唯一业务标识而非技术主键 重要警告 必须先配置备用键：EF Core 不会自动推断 Url 是备用键，必须显式配置。 值不可变：被引用的备用键值一旦使用，不应更改，否则会破坏数据完整性。EF Core 默认阻止此类更改。 不推荐滥用：如无特殊理由，优先使用主键作为外键引用，更简单高效。 结论：EF Core 通过“备用键”概念，让外键可以引用任何唯一列，这为处理复杂映射提供了强大灵活性。"
  },
  "docs/EF-Core/简单日志记录.html": {
    "href": "docs/EF-Core/简单日志记录.html",
    "title": "| CZQDocs",
    "summary": "LogTo 是 EF Core 5.0+ 提供的 “一行代码就能看 SQL” 的轻量级日志方案，官方叫 Simple Logging。 无需引入任何第三方包（NLog、Serilog 都不用），也无需配置 ILoggerFactory，最适合在控制台程序、示例项目里快速调试。 1. 最小可用写法 protected override void OnConfiguring(DbContextOptionsBuilder b) { b.UseSqlServer(_connStr) .LogTo(Console.WriteLine); // 默认级别 Information } 运行后每条 SQL 都会原样输出： info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (2ms) [Parameters=[...], CommandType='Text', CommandTimeout='30'] SELECT [b].[BlogId], [b].[Name] FROM [Blogs] AS [b] 2. 完整重载签名 LogTo( Action<string> writeAction, // 字符串写到哪里 LogLevel minimumLevel = Information, // 最低级别 IEnumerable<string> categories = null, // 只留空即可 Func<EventId, LogLevel, bool> filter = null, // 额外过滤 DbContextLoggerOptions options = None) // 附加信息开关 3. 常用组合示例 场景 代码 只看 SQL .LogTo(Console.WriteLine, LogLevel.Information) SQL + 参数值 .LogTo(Console.WriteLine, LogLevel.Information, options: DbContextLoggerOptions.SingleLine) 写到文件 .LogTo(File.CreateText(\"sql.log\").WriteLine, LogLevel.Information) 调试窗口 .LogTo(Debug.WriteLine, LogLevel.Information) 4. 日志级别对照表 级别 会看到什么 Trace 最细，包括 EF 内部状态变化 Debug 翻译后的 LINQ 表达式树 Information SQL 语句 + 执行耗时（最常用） Warning 查询缓存未命中、索引提示等 Error 执行失败时的异常详情 5. 与 ILoggerFactory 的关系 LogTo 是 独立通道，不会干扰 ASP.NET Core 的 ILogger。 如果已经配置了 AddDbContext<T>(b => b.UseLoggerFactory(...))，LogTo 仍可并存，两边都会写。 6. 关闭/动态开关 Simple Logging 没有开关 API，需要动态控制时： #if DEBUG builder.LogTo(Console.WriteLine, LogLevel.Information); #endif 或把 Action<string> 指向空方法即可变相“关闭”。 7. 一句话总结 LogTo(Console.WriteLine, LogLevel.Information) = 零依赖、零配置、一眼看到 SQL 的 EF Core 官方“简易控制台记录器”。"
  },
  "docs/EF-Core/跟踪与 No-Tracking 查询.html": {
    "href": "docs/EF-Core/跟踪与 No-Tracking 查询.html",
    "title": "| CZQDocs",
    "summary": "AsNoTrackingWithIdentityResolution 从数据库中查询所有 Blog 实体，禁用变更追踪和身份解析（Identity Resolution），以只读方式高效加载数据。 逐段解释： 代码片段 作用 context.Blogs 访问 DbContext 中定义的 DbSet<Blog>，即 Blog 表。 .AsNoTrackingWithIdentityResolution() 关键配置： 1. 禁用变更追踪（No Tracking）：EF Core 不会缓存实体，节省内存，提升性能。 2. 禁用身份解析（No Identity Resolution）：即使多表连接返回重复主键，也不会合并为同一对象，每行数据都创建新实例。 .ToListAsync() 异步执行查询，将结果加载到内存中的 List<Blog>。 使用场景： 只读查询（如展示数据、报表、API 响应）。 需要避免内存缓存（如大量数据导出）。 明确需要重复实体实例（如某些特殊投影逻辑）。 对比其他模式： 模式 是否追踪 身份解析 性能 适用场景 默认追踪 ✅ ✅ 慢 需要增删改 AsNoTracking() ❌ ✅ 较快 只读，需合并重复实体 AsNoTrackingWithIdentityResolution() ❌ ❌ 最快 只读，无需合并重复实体 总结： 这行代码是 EF Core 高性能只读查询 的终极形态，内存占用最小、速度最快，但无法保存更改，且可能产生重复对象。"
  },
  "docs/EF-Core/软删除.html": {
    "href": "docs/EF-Core/软删除.html",
    "title": "| CZQDocs",
    "summary": "软删除标记做成阴影属性的完整流程 1. 数据库表结构（SQL Server 示例） CREATE TABLE Blogs ( BlogId INT IDENTITY PRIMARY KEY, Url NVARCHAR(200) NOT NULL, -- 没有显式定义 IsDeleted，它只存在于 EF 模型里 ); 2. 实体类（完全不知道“软删除”这件事） public class Blog { public int BlogId { get; set; } public string Url { get; set; } // 不包含 IsDeleted、DeletedAt 等任何软删除字段 } 3. 在 OnModelCreating 里把 IsDeleted 声明为阴影属性，并加上全局过滤 protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity<Blog>() .Property<bool>(\"IsDeleted\") // 阴影属性：数据库列存在，但实体类看不到 .HasDefaultValue(false); modelBuilder.Entity<Blog>() .HasQueryFilter(b => !EF.Property<bool>(b, \"IsDeleted\")); // 全局过滤：默认查询只返回未删除的记录 } 4. 正常业务查询（自动忽略已删除数据） // 生成的 SQL 会自动加上 WHERE [IsDeleted] = 0 var activeBlogs = context.Blogs.ToList(); 5. 需要查看“已删除”数据时，显式关闭过滤器 // 生成的 SQL 不再带 WHERE [IsDeleted] = 0，能查出所有记录 var allBlogs = context.Blogs.IgnoreQueryFilters().ToList(); 6. 执行“软删除”操作 var blog = context.Blogs.Find(1); context.Entry(blog).Property(\"IsDeleted\").CurrentValue = true; context.SaveChanges(); // 数据库里该行的 IsDeleted 被设为 1，但记录仍在；下次普通查询就查不到它了 7. 恢复已删除数据 var blog = context.Blogs.IgnoreQueryFilters().First(b => b.BlogId == 1); context.Entry(blog).Property(\"IsDeleted\").CurrentValue = false; context.SaveChanges(); 一句话总结 把 IsDeleted 放进阴影属性后，实体类完全不感知软删除逻辑；EF Core 通过全局过滤器自动屏蔽已删除数据，业务代码只需在需要时用 .IgnoreQueryFilters() 打开“查看全部”的开关即可。 把 IsDeleted 放在阴影属性里确实能实现“实体类不感知”，但它只是软删除的一种实现技巧，并不是“最佳实践”的全部。 真正的“最佳实践”还要考虑： 级联软删除：父实体被软删除后，子实体是否也要自动标记为已删除？ 性能：软删除后数据量持续增长，查询会变慢，需要定期归档或清理。 恢复机制：如何把误删的数据一键恢复？有没有“回收站”界面？ 硬删除策略：某些场景（如合规要求）仍需物理删除，不能只靠软删除。 一句话总结：阴影属性 + 全局过滤器是实现软删除的一种手段，但“最佳实践”需要结合业务场景、性能、合规等多方面权衡，不能只靠这一招。 级联软删除 = “删父带子” 核心思路：父实体被打上删除标记后，所有子实体也自动被标记为已删除，且后续恢复时能一起还原。 1. 数据库准备 父表、子表都加 IsDeleted BIT DEFAULT 0（或 DeletedAt DATETIME2）。 外键保持 NOT NULL，确保关系完整。 2. EF Core 模型 父、子实体类都不写 IsDeleted 属性。 在 OnModelCreating 里把 IsDeleted 声明为阴影属性，并给父、子表都加上全局过滤器： modelBuilder.Entity<Parent>() .Property<bool>(\"IsDeleted\") .HasDefaultValue(false); modelBuilder.Entity<Parent>() .HasQueryFilter(p => !EF.Property<bool>(p, \"IsDeleted\")); // 子表同理 3. 级联软删除逻辑 删除父实体时，手动把所有子实体的 IsDeleted 也设为 true： var parent = context.Parents.Find(id); context.Entry(parent).Property(\"IsDeleted\").CurrentValue = true; var children = context.Children.Where(c => c.ParentId == id); foreach (var child in children) context.Entry(child).Property(\"IsDeleted\").CurrentValue = true; context.SaveChanges(); 恢复时同理：先把父实体的 IsDeleted 设回 false，再把子实体全部恢复。 4. 优化：自动级联 重写 SaveChanges，当发现父实体被软删除时，自动把所有关联子实体也标记为已删除。 或者用 EF Core 的 DeleteBehavior.Cascade 配合软删除标记，但需注意： 数据库层面不要启用 ON DELETE CASCADE，否则会物理删除子表，破坏软删除语义。 一句话总结：级联软删除 = 父子表都用阴影属性 + 全局过滤器，删除时手动或自动把所有子实体的 IsDeleted 一起设为 true，恢复时再一起还原。"
  },
  "docs/GitBash常用命令.html": {
    "href": "docs/GitBash常用命令.html",
    "title": "| CZQDocs",
    "summary": "查找占用 8080 端口的进程 PID netstat -ano | grep :8080 关闭 $ powershell -command \"Stop-Process -Id 12092 -Force\" 生成32位随机字符串 可用于JWT 密钥 openssl rand -base64 32"
  },
  "docs/Html/1.html": {
    "href": "docs/Html/1.html",
    "title": "| CZQDocs",
    "summary": "下面把“最常用的 HTML 标签”按功能分组，背完这些即可覆盖 90 % 日常开发需求。 ---------------- 结构骨架 ---------------- <html> <head> <title> <meta> <link> <style> <script> <body> <header> <nav> <main> <article> <section> <aside> <footer> <!-- 语义化布局 --> ---------------- 文本排版 ---------------- <h1>～<h6> <p> <br> <hr> <!-- 标题、段落、换行、分隔线 --> <strong> <em> <u> <small> <sup> <sub> <!-- 强调、修饰 --> <ul> <ol> <li> <dl> <dt> <dd> <!-- 列表 --> <blockquote> <pre> <code> <!-- 引用、代码块 --> ---------------- 超链接 & 多媒体 ---------------- <a href=\"\" target=\"\" download> <!-- 超链接 --> <img src=\"\" alt=\"\" width=\"\" height=\"\"> <!-- 图片 --> <audio src=\"\" controls loop> <!-- 音频 --> <video src=\"\" controls width=\"\" poster=\"\"> <!-- 视频 --> <figure> <figcaption> <!-- 图文/图表组合 --> ---------------- 表格 ---------------- <table> <thead> <tbody> <tfoot> <tr> <th> <td> <caption> <colgroup> <col> ---------------- 表单 ---------------- <form action=\"\" method=\"\"> <!-- 表单容器 --> <input type=\"text|password|checkbox|radio|file|hidden|submit|reset|button\"> <textarea rows=\"\" cols=\"\"> <!-- 多行文本 --> <select> <option> <optgroup> <!-- 下拉列表 --> <button type=\"submit|button|reset\"> <!-- 按钮 --> <label for=\"\"> <!-- 标签/绑定控件 --> <fieldset> <legend> <!-- 分组 --> <datalist> <output> <progress> <meter> <!-- HTML5 增强控件 --> ---------------- 嵌入 & 语义 ---------------- <div> <span> <!-- 通用块/行内容器 --> <iframe src=\"\"> <!-- 内嵌页面 --> <object> <embed> <param> <!-- 插件/外部资源 --> <time datetime=\"\"> <mark> <abbr> <address> <!-- 细语义 --> ---------------- 记忆口诀 ---------------- “骨架头身脚，链接图声表，表单九大件，div span 兜底。” 掌握这些标签即可应对常规静态页面开发；其余标签（如 <details>、<canvas>、<svg> 等）按需查阅即可。"
  },
  "docs/Markdown.html": {
    "href": "docs/Markdown.html",
    "title": "A First Level Header | CZQDocs",
    "summary": "A First Level Header A Second Level Header Now is the time for all good men to come to the aid of their country. This is just a regular paragraph. The quick brown fox jumped over the lazy dog's back. Header 3 This is a blockquote. This is the second paragraph in the blockquote. This is an H2 in a blockquote Some of these words are emphasized. Some of these words are emphasized also. Use two asterisks for strong emphasis. Or, if you prefer, use two underscores instead. Candy. Gum. Booze. Candy. Gum. Booze. Candy. Gum. Booze. Red Green Blue A list item. With multiple paragraphs. Another item in the list. This is an example link. I get 10 times more traffic from Google than from Yahoo or MSN. I start my morning with a cup of coffee and The New York Times. I strongly recommend against using any <blink> tags. I wish SmartyPants used named entities like &mdash; instead of decimal-encoded entities like &#8212;. int a=1; 这是普通文本，而 this is inline code。"
  },
  "docs/Nuget/1.html": {
    "href": "docs/Nuget/1.html",
    "title": "在 SharedLibrary 目录内 | CZQDocs",
    "summary": "要让两个独立的 .NET 解决方案（分别位于两个独立的 Git 仓库中）共同引用同一个 DLL 类库项目，并使用 Gitea 托管，你需要考虑如何共享这个类库项目。以下是几种可行的方案，各有优缺点，可根据你的团队规模、发布频率和维护需求选择： 方案一：使用 Git Submodule（推荐用于小型团队或内部共享） 原理：将类库项目作为一个子模块（submodule）添加到两个主解决方案的仓库中。 步骤： 创建独立的类库仓库： 在 Gitea 上创建一个新的仓库，例如 SharedLibrary。 将你的类库项目（.csproj 文件及代码）推送到这个仓库。 在主解决方案中添加 Submodule： 在本地克隆第一个解决方案仓库（SolutionA）。 在 SolutionA 的根目录下执行： bash git submodule add https://your-gitea.com/username/SharedLibrary.git SharedLibrary 这会在 SolutionA 仓库中创建一个 SharedLibrary 目录，并将其关联到远程的 SharedLibrary 仓库。 重复以上步骤，为 SolutionB 添加相同的 submodule。 在 .NET 项目中引用： 在 SolutionA 和 SolutionB 的主项目中，通过 项目引用 (Project Reference) 添加对 SharedLibrary/SharedLibrary.csproj 的引用。 例如，在 .csproj 文件中： xml 开发与更新： 当你在 SharedLibrary 中修改代码并提交后，需要在主解决方案仓库中更新 submodule 的指针： bash 在 SharedLibrary 目录内 git pull origin main 回到主仓库根目录 git add SharedLibrary git commit -m \"Update SharedLibrary to latest\" git push 其他开发者在拉取主仓库代码后，需要初始化 submodule： bash git clone --recurse-submodules https://your-gitea.com/username/SolutionA.git 或者 git clone https://your-gitea.com/username/SolutionA.git cd SolutionA git submodule update --init --recursive 优点： 代码完全同步，主项目直接引用源码。 调试方便，可以直接进入类库代码。 无需额外的包管理工具。 缺点： 管理复杂，需要处理 submodule 的更新和同步。 如果类库频繁更新，主项目需要频繁提交 submodule 指针更新。 对团队成员的 Git 熟练度有一定要求。 方案二：使用 NuGet 私有包（推荐用于生产环境或大型团队） 原理：将类库项目打包成 NuGet 包，发布到 Gitea 内置的 NuGet 包注册表 (Package Registry) 或自建的私有 NuGet 服务器，然后在两个主项目中通过 NuGet 引用。 步骤： 配置 Gitea 的 NuGet 包注册表： 登录 Gitea，进入 SharedLibrary 仓库。 导航到 Packages -> NuGet，按照提示获取你的私有 NuGet 源 URL，例如： https://your-gitea.com/username/SharedLibrary/packages/nuget 打包类库项目： 在 SharedLibrary.csproj 中配置包信息： xml net6.0 MyCompany.SharedLibrary 1.0.0 Your Name A shared library for common functionality. https://your-gitea.com/username/SharedLibrary 构建并打包： bash dotnet pack -c Release 这会生成一个 .nupkg 文件。 发布到 Gitea NuGet 源： 在 Gitea 中为你的用户或组织创建一个 Access Token（具有 write:packages 权限）。 使用 dotnet nuget push 命令发布： bash dotnet nuget push bin/Release/MyCompany.SharedLibrary.1.0.0.nupkg --source https://your-gitea.com/username/SharedLibrary/packages/nuget --api-key YOUR_GITEA_ACCESS_TOKEN 在主项目中引用 NuGet 包： 在 SolutionA 和 SolutionB 的项目中，添加对私有 NuGet 源的引用： bash dotnet nuget add source https://your-gitea.com/username/SharedLibrary/packages/nuget --name gitea-shared-library --username your-username --password YOUR_GITEA_ACCESS_TOKEN （注意：生产环境建议使用更安全的凭据管理方式） 安装包： bash dotnet add package MyCompany.SharedLibrary --version 1.0.0 优点： 版本化管理清晰，主项目可以独立选择依赖的版本。 解耦性强，主项目和类库项目完全独立。 发布流程自动化友好（可结合 CI/CD）。 是 .NET 生态的标准做法。 缺点： 调试类库代码不如直接引用源码方便（但可以通过 Source Link 或直接引用源码调试）。 需要设置和管理包注册表。 方案三：Monorepo（单一代码仓库） 原理：将两个主项目和共享类库合并到一个大的 Git 仓库中。 步骤： 创建一个新的仓库，包含三个子目录：SolutionA、SolutionB、SharedLibrary。 两个主项目通过相对路径引用 SharedLibrary 项目。 优点： 管理最简单，所有代码在一个地方。 共享代码的变更和主项目的更新可以原子化提交。 缺点： 违背了“两个独立仓库”的要求。 仓库可能变得臃肿，权限管理复杂。 不适合大型或独立发布的项目。 总结与建议 方案 适用场景 推荐度 :--- :--- :--- Git Submodule 小型团队，共享代码频繁变更，需要直接调试源码 ⭐⭐⭐⭐ NuGet 私有包 生产环境，需要版本控制，团队较大，追求标准化 ⭐⭐⭐⭐⭐ Monorepo 项目紧密耦合，愿意放弃独立仓库的结构 ⭐⭐ 强烈推荐使用方案二（NuGet 私有包），因为它符合 .NET 最佳实践，便于版本管理和持续集成，长期维护成本最低。Gitea 内置的包注册表功能使得搭建私有 NuGet 源非常方便。 你可以根据团队的实际情况和对复杂度的容忍度来选择最合适的方案。"
  },
  "docs/SQL-Server/CQRS.html": {
    "href": "docs/SQL-Server/CQRS.html",
    "title": "| CZQDocs",
    "summary": "非常好的问题！CQRS（Command Query Responsibility Segregation，命令查询职责分离） 是一种强大的架构模式，尤其适合中大型、高性能、复杂业务的应用系统。 你已经理解了“视图用于查询，表用于更新”的思想，这正是 CQRS 的核心理念之一。下面我们来深入探讨 CQRS 风格的具体好处、适用场景和潜在代价。 CQRS 的核心思想 “写”和“读”走不同的路径： Command（命令）：负责修改数据（Create, Update, Delete）→ 写模型（Write Model） Query（查询）：负责读取数据 → 读模型（Read Model，常基于视图或物化视图） // 写：使用实体和表 var movie = new Movie { Title = \"Inception\", Genre = \"Sci-Fi\", Price = 12.99 }; context.Movies.Add(movie); context.SaveChanges(); // 读：使用视图或 DTO var movies = context.Set<MovieSummaryView>() .Where(v => v.Genre == \"Sci-Fi\") .ToList(); CQRS 风格的 7 大核心好处 好处 详细说明 ### 1. 性能优化 ? 读写分离后，可以为“读”专门优化：创建索引、使用视图、缓存、甚至用 Redis/Elasticsearch 存储查询结果，不影响写性能。 ### 2. 模型解耦 ? 写模型关注数据一致性、业务规则、事务；读模型关注展示结构、性能、聚合。两者互不影响。 ### 3. 可扩展性增强 ? 读操作通常远多于写操作。你可以：横向扩展只读数据库副本，或使用 CDN/缓存服务，而写库保持稳定。 ### 4. 简化复杂查询 ? 不再需要在 C# 中拼接复杂 JOIN 和 GroupBy。直接用数据库视图、存储过程或物化视图封装查询逻辑。 ### 5. 支持事件驱动架构（Event Sourcing） ? CQRS 常与“事件溯源”结合：写操作发布事件，异步更新读模型（如更新 MovieSummaryView 的物化表）。 ### 6. 更好的安全性与权限控制 ? 可以为读模型添加行级/列级安全（如：普通用户只能查自己的订单视图），写模型则严格校验权限。 ### 7. 易于维护和演进 ? 修改读模型（如加一个计算字段）不会影响写逻辑；重构写模型时，只要读模型输出不变，前端无需改。 实际场景示例：电商系统 场景 传统方式 CQRS 方式 用户下单 直接插入 Orders 表 发布 OrderPlacedEvent，写入 Orders 表 查看订单列表 JOIN Users, Products, Payments... 实时计算 从 UserOrderSummaryView 或 OrderReadModel 表中快速读取 修改价格 直接 UPDATE Products 发布 ProductPriceChangedEvent，异步更新所有相关读模型 报表统计 每次查询都 GROUP BY 使用物化视图或定时任务预计算 DailySalesReport ?? 在高并发场景下，CQRS 能显著降低数据库压力，提升响应速度。 CQRS 的两种常见实现方式 方式 1：轻量级 CQRS（推荐初学者使用） 使用 同一个数据库 写：实体 + 表 读：DTO/视图 + HasNoKey() + ToView() 适合中小型项目 // 写 context.Movies.Add(new Movie { ... }); context.SaveChanges(); // 读 var result = context.Set<MovieSummaryView>() .FromSqlRaw(\"SELECT * FROM MovieSummaryView WHERE Genre = {0}\", \"Comedy\") .ToList(); 方式 2：重量级 CQRS（事件驱动 + 多数据库） 写库（Command DB）：SQL Server，负责事务一致性 读库（Query DB）：MySQL Replica / Elasticsearch / Redis 使用 事件总线（如 RabbitMQ、Kafka）同步数据 适合大型分布式系统 // 写 await _commandBus.Send(new CreateMovieCommand { Title = \"Interstellar\" }); // 读 var movies = await _queryBus.Send(new GetMovieSummariesQuery()); CQRS 的潜在代价（注意事项） 缺点 说明 缓解方案 ? 数据延迟（最终一致性） 读模型更新可能延迟几秒 明确告知用户“数据可能延迟”，或强制刷新 ? 系统复杂度增加 需要维护两套模型、事件、同步逻辑 从小处开始，先用轻量级 CQRS ? 开发成本上升 更多代码、更多测试 使用 MediatR、AutoMapper 等工具简化 ? 调试困难 读写路径分离，问题定位难 加强日志、监控、追踪 何时应该使用 CQRS？ ? 推荐使用 ? 不建议使用 查询逻辑复杂、性能要求高 简单的 CRUD 应用（如内部管理后台） 读多写少（如新闻网站、电商） 写多读少（如日志系统） 需要支持缓存、搜索、报表 数据一致性要求极高（如银行核心交易） 团队有足够技术能力 小团队、快速原型开发 总结：CQRS 的核心价值 传统 CRUD CQRS 一个模型搞定一切 读写分离，各司其职 性能瓶颈明显 可独立优化读/写 修改牵一发而动全身 模型解耦，易于演进 ?? CQRS 不是银弹，但它是应对复杂系统演进的“高级武器”。 你已经在使用它的思想（视图用于查询），这非常棒！ 下一步可以尝试： 使用 MediatR 实现轻量级 CQRS 为读模型添加缓存（如 IMemoryCache） 创建物化视图（Materialized View）提升性能 需要我为你生成一个 基于 MediatR 的 CQRS 示例（含 Command 和 Query） 吗？"
  },
  "docs/SQL-Server/Transact-SQL.html": {
    "href": "docs/SQL-Server/Transact-SQL.html",
    "title": "| CZQDocs",
    "summary": "Transact-SQL 参考 T-SQL 语言元素（如控制流语句、运算符、函数等） 数据定义语言（DDL）、数据操作语言（DML）、数据控制语言（DCL）语法 系统存储过程、内置函数、数据类型等详细说明 Transact-SQL（通常缩写为 T-SQL）是微软和Sybase公司共同开发的一种关系数据库通用语言SQL的扩展。它在标准SQL的基础上增加了编程功能，如变量、流程控制、函数等，主要用于Microsoft SQL Server和Sybase Adaptive Server等数据库管理系统中。 T-SQL 的主要特点： 数据操作语言 (DML) 扩展： 支持标准的 SELECT, INSERT, UPDATE, DELETE 语句。 提供更强大的 SELECT 功能，如 TOP, OFFSET-FETCH, 窗口函数（ROW_NUMBER(), RANK(), OVER() 等）。 数据定义语言 (DDL) 支持： 用于创建、修改和删除数据库对象，如表、视图、索引等。 示例：CREATE TABLE, ALTER TABLE, DROP INDEX。 数据控制语言 (DCL)： 用于管理数据库权限和安全性。 示例：GRANT, REVOKE, DENY。 流程控制语句： IF...ELSE WHILE 循环 BEGIN...END 块 TRY...CATCH 异常处理 GOTO（不推荐使用） 变量与批处理： 局部变量：以 @ 开头，如 @name NVARCHAR(50) 全局变量（系统函数）：以 @@ 开头，如 @@VERSION, @@ROWCOUNT, @@ERROR 内置函数： 字符串函数：LEN(), SUBSTRING(), REPLACE() 数值函数：ROUND(), CEILING(), FLOOR() 日期函数：GETDATE(), DATEADD(), DATEDIFF() 聚合函数：SUM(), COUNT(), AVG(), MAX(), MIN() 存储过程与函数： 存储过程（Stored Procedure）：预编译的SQL代码块，可带参数，提高性能和复用性。 用户定义函数（UDF）：可返回标量值或表。 事务控制： BEGIN TRANSACTION COMMIT ROLLBACK 支持事务的ACID特性。 示例代码： -- 声明变量 DECLARE @EmployeeID INT = 101; DECLARE @Salary DECIMAL(10,2); -- 使用 SELECT 查询赋值 SELECT @Salary = Salary FROM Employees WHERE ID = @EmployeeID; -- 流程控制 IF @Salary > 5000 PRINT 'High Salary'; ELSE PRINT 'Normal Salary'; -- 异常处理示例 BEGIN TRY BEGIN TRANSACTION; UPDATE Accounts SET Balance -= 100 WHERE AccountID = 1; UPDATE Accounts SET Balance += 100 WHERE AccountID = 2; COMMIT TRANSACTION; END TRY BEGIN CATCH ROLLBACK TRANSACTION; PRINT 'Transaction failed: ' + ERROR_MESSAGE(); END CATCH; 下面给你 3 条“能直接下载、用 SSDT 打开就能跑”的开源 Transact-SQL 演练项目，按“先易后难”排好，5 分钟就能在 Visual Studio 里按 F5 调试，最适合快速把 T-SQL + SSDT 的完整工作流跑通。 Northwind-SSDT（微软经典库，零门槛） 仓库：https://github.com/microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs 已拆成 .sql 脚本，直接“文件→新建→SQL Server 数据库项目→导入脚本”即可生成完整项目。 表、视图、存储过程、触发器一应俱全，适合练“单步调试存储过程”“重构索引”等基础操作。 WideWorldImporters-SSDT（微软官方“现代”示例，带 CI/CD） 1 分钟拿到源码：打开官方仓库 https://github.com/microsoft/sql-server-samples → 右侧 Releases → 找到“WideWorldImporters SSDT sample database”（标签名 wwi-ssdt）→ 下载 Source code (zip)。 解压后路径：samples\\databases\\wide-world-importers\\wide-world-importers-ssdt\\WideWorldImporters.sqlproj 双击 .sqlproj 即可用 Visual Studio + SSDT 打开，F5 直接跑。 官方 SSDT 项目（.sqlproj），下载即用，README 里自带 Azure DevOps yaml，可顺带把“Git → Build → Publish”整条 DevOps 流水线跑一遍。 包含大量 2016+ 新语法（JSON、列存、CCI、安全策略），想练“现代 T-SQL”就它。 tSQLt-SSDT-Template（单元测试框架，进阶必备） 仓库：https://github.com/tSQLt-org/tSQLt-SSDT-Template 把主流单元测试框架 tSQLt 打包成 SSDT 项目，F5 后自动部署 tSQLt 与示例测试。 可练“测试先行”模式：写测试类→写实现→调试→提交 Git，完美模拟企业级数据库开发流程。 5 分钟上手步骤（以 WideWorldImporters 为例） 装 SSDT：打开 Visual Studio Installer → 勾选“SQL Server Data Tools”工作负载。 拿代码：下载解压后，双击 .sqlproj 打开。 配调试库：右键项目 → 属性 → 调试 → 新建 LocalDB 或指向自己的 SQL Server 实例。 F5 一键部署+调试：选“Start (调试)”，VS 会自动生成 .dacpac、publish 到调试库、附加调试器，随后即可在存储过程里打断点、单步、看变量。 两库对比 对比维度 Northwind-SSDT（经典版） WideWorldImporters-SSDT（现代版） 设计年代 1996 年随 Office 发布，90 年代小商户场景 2016 年随 SQL Server 2016 设计，面向云端与现代 ERP 目标 SQL 版本 SQL Server 2000-2012 语法为主 SQL Server 2016+ / Azure SQL DB，需 2016 SP1+ 跑全功能 项目体积 ≈ 1-2 MB，几十张表，数据 1-10 MB 级 空库 30 MB，生成 3.5 年数据后 ≈ 160 MB（可扩到 GB 级） 新特性覆盖 无（无列存、内存、JSON、时态表、分区） 全部都有：列存、内存 OLTP、时态表、JSON、分区、数据掩码、行级安全等 SSDT 项目结构 手工拆分脚本，简单直观，适合“第一次按 F5” 官方原生 .sqlproj，预置 300+ 对象，分 Schema 文件夹，企业级模板 数据生成方式 静态 INSERT 脚本，数据量固定 内置 DataLoadSimulation.PopulateDataToCurrentDate 存储过程，可参数化按日生成订单，支持周末系数、静默模式等 场景定位 ① 零基础学 T-SQL ② 教课 ③ 做演示用 ① 练“现代”T-SQL/新特性 ② 练 CI/CD 发布 ③ 做性能测试（列存、内存） 调试体验 表少、逻辑简单，存储过程断点一目了然 对象多，但自带示例测试存储过程，可练“大库”下调试 & 单元测试 与 CI/CD 结合 无官方 yaml，需自己写 同仓库直接给 Azure DevOps/GitHub Actions 样例，push 即发布 学习路线图（按工作日每天 1.5h 估算） 起点 A：只会简单 SELECT / 没用过 SSDT 阶段 目标 任务清单（可量化） 耗时 ① 入门 把 SSDT 玩顺 克隆 Northwind-SSDT → F5 成功 → 单步调试 5 个存储过程 3 天 ② 基础 SQL 写 CRUD + 视图 + 事务 在 Northwind 里自己写 10 个查询、3 个视图、2 个带事务的存储过程并通过 tSQLt 测试 7 天 ③ 迁移现代库 体验“大数据量” 把 Northwind 订单表导入 WideWorldImporters，跑通 PopulateDataToCurrentDate 生成 100 万订单 3 天 ④ 新特性 掌握 2016+ 功能 在 WideWorldImporters 里各做一次：列存索引、内存 OLTP、时态表、JSON 查询、行级安全 10 天 ⑤ 实战 端到端 DevOps 用 GitHub Actions 把 WideWorldImporters 自动发布到 Docker 版 SQL 2025，加单元测试闸门 5 天 合计 ≈ 4 周（20 工作日） 起点 B：已会 T-SQL，第一次用 SSDT 跳过阶段 ①②，直接从阶段 ③ 开始， ≈ 2 周 可完成。 起点 C：熟手，只想快速补新特性 / CI/CD 只跑阶段 ④⑤， ≈ 1 周 就够。 加速技巧（通用） 每天任务拆成 ≤30 min 的小块，用 tSQLt 测试保证一次做对。 把 WideWorldImporters 数据生成脚本参数调小（@YearNumberToLoad=1），笔记本也能 3 min 跑完。 用 VS Code 的 mssql 扩展 + SSDT 同时开，查询窗口和项目文件切换更快。 周末集中 2 h 做“综合演练”——写个迷你业务需求（如“给 Northwind 加会员积分表”）从需求→建表→存储过程→测试→Git 提交一条龙，一次性把知识缝起来。 验收标准（你能独立做出即算“掌握”） 不用向导，手工新建 SSDT 项目，把任意业务库（≥15 张表）反向工程进来并推送到 Git。 能用列存 + 分区把 1 亿行销售表查询压到 1 s 内。 一条 git push 自动跑 tSQLt 测试→生成发布脚本→部署到 Docker SQL 实例→回写结果。 达到这三条，两个示例库就可以毕业，接下来直接拿生产项目练手即可。祝你 1 个月后就能上台讲“SQL Server 现代开发工作流”！"
  },
  "docs/SQL-Server/数据库.html": {
    "href": "docs/SQL-Server/数据库.html",
    "title": "| CZQDocs",
    "summary": "创建外键关系 SQL 数据库项目 SQL Server 数据工具 Transact-SQL 调试器"
  },
  "docs/Testing/EF-Core测试总结.html": {
    "href": "docs/Testing/EF-Core测试总结.html",
    "title": "第6章：测试策略与最佳实践 | CZQDocs",
    "summary": "第6章：测试策略与最佳实践 至此，我们已经探讨了从单元测试到集成测试的各种技术。然而，拥有强大的工具并不等于能写出高效的测试套件。本章将总结一套全面的测试策略，并提供一系列经过验证的最佳实践，帮助你构建一个既快速又可靠的测试体系。 6.1 构建金字塔式的测试策略 一个健康的测试体系应该遵循\"测试金字塔\"模型： |‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾| | 端到端测试 | (少量) | (E2E / UI Tests) | |___________________| | | |‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾| | 集成测试 | (中等数量) | (Integration Tests)| |___________________| | |‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾| | 单元测试 | (大量) | (Unit Tests) | |___________________| 金字塔结构详解 底层：大量的单元测试 (占 ~70%) 目标：验证单个类、方法的内部逻辑 技术：使用 Moq Mock DbContext 和外部服务 优点：速度快（毫秒级），定位问题精确，易于维护 示例：测试 ProductService.CalculateDiscount() 方法是否根据规则正确计算折扣 中层：适量的集成测试 (占 ~20%) 目标：验证多个组件协同工作，特别是与数据库的交互 技术：使用 In-Memory Database 或 SQLite 内存模式 优点：能发现查询翻译、数据映射、约束冲突等问题 示例：测试 OrderService.PlaceOrderAsync() 是否能正确地在 Orders 和 OrderItems 表中创建记录 顶层：少量的端到端测试 (占 ~10%) 目标：模拟真实用户场景，从 API 入口到数据库再到响应 技术：使用 WebApplicationFactory<T> 启动一个真实的 Web 服务器实例进行测试 优点：最接近生产环境，能发现系统集成问题 缺点：速度慢，维护成本高，容易因环境问题而失败 示例：通过 HTTP POST 请求 /api/orders 来下订单，并验证返回状态码和数据库状态 核心原则 尽可能用低层的测试来覆盖功能。不要因为可以写 E2E 测试就放弃单元测试。一个由大量慢速 E2E 测试组成的\"冰山\"会严重拖累开发效率。 6.2 最佳实践清单 遵循以下最佳实践，可以显著提升你的测试代码质量和可维护性。 6.2.1 命名约定：清晰表达意图 测试方法的名称应该像一句完整的句子，清晰地描述被测场景、输入条件和预期结果。 // ❌ 模糊不清 [Fact] public void Test1() { ... } // ❌ 仍然不够好 [Fact] public void CreateProductTest() { ... } // ✅ 推荐：Given_When_Then (GWT) 模式 [Fact] public async Task CreateProductAsync_WithValidNameAndPrice_CreatesProductAndReturnsIt() { // ... } // ✅ 推荐：直接描述行为 [Fact] public async Task GetActiveProductsAsync_ExcludesInactiveProductsFromResult() { // ... } 6.2.2 组织结构：AAA 模式 始终将测试方法分为三个清晰的部分： Arrange (准备)：设置测试前提条件。创建对象、配置 Mock、准备测试数据。 Act (执行)：调用被测试的方法。 Assert (断言)：验证结果是否符合预期。 [Fact] public async Task UpdateProductAsync_WithValidIdAndNewName_ChangesProductName() { // Arrange var mockContext = new Mock<AppDbContext>(); var mockDbSet = new Mock<DbSet<Product>>(); mockContext.Setup(c => c.Products).Returns(mockDbSet.Object); var service = new ProductService(mockContext.Object); var existingProduct = new Product { Id = 1, Name = \"Old\", Price = 10 }; var newName = \"New\"; // Act await service.UpdateProductAsync(existingProduct.Id, newName, existingProduct.Price); // Assert mockDbSet.Verify(m => m.Update(It.Is<Product>(p => p.Name == newName)), Times.Once()); } 6.2.3 测试独立性：避免污染 每个测试都应该是独立的、可重复的。它不应该依赖于其他测试的执行顺序或状态。 解决方案： 使用 Per-Test 数据库（为每个测试使用唯一名称的 In-Memory DB） 在测试开始前清理或重建数据库状态 避免使用静态变量存储共享状态 6.2.4 只测试公共契约 单元测试应只关注类的公共接口（Public Methods）。不要测试私有方法（Private Methods）的实现细节。 为什么？ 实现细节是会变的。如果你的测试紧密耦合到私有方法，那么重构代码时就会导致大量测试失败，即使最终功能没有改变 怎么做？ 通过测试公共方法的行为来间接验证私有逻辑 如果某个私有逻辑非常复杂，考虑将其提取到一个新的、可独立测试的服务类中 6.2.5 避免过度 Mocking Mock 应该用于隔离真正的外部依赖（如数据库、HTTP 服务、文件系统）。不要为了 Mock 而 Mock。 // 不要 Mock 一个简单的 DTO 或纯数据类 var mockProduct = new Mock<Product>(); // ❌ 没必要 // ✅ 正确做法：直接创建实体的实例作为测试数据 var product = new Product { Name = \"Test\", Price = 10 }; // ✅ 6.2.6 保持测试的单一职责 一个测试方法应该只验证一个明确的行为。 // ❌ 反例：一个测试做了太多事 [Fact] public void TestProductService() { // 测试创建 // 测试更新 // 测试删除 // 测试查询 } // ✅ 正例：拆分成多个小测试 [Fact] public async Task CreateProductAsync_CreatesNewRecord() { ... } [Fact] public async Task UpdateProductAsync_UpdatesExistingRecord() { ... } [Fact] public async Task DeleteProductAsync_RemovesRecord() { ... } 这样做的好处：当测试失败时，你能立即知道是哪个具体功能出了问题。 6.2.7 善用测试初始化和清理 利用 xUnit.net 的 IClassFixture<T> 或 ICollectionFixture<T> 来管理昂贵的资源（如共享的 SQLite 连接、大型测试数据集）。 对于需要在每个测试前后执行的代码，可以使用构造函数和 IDisposable.Dispose() 方法。 public class MyTests : IDisposable { private readonly AppDbContext _context; public MyTests() { // 所有测试开始前运行 _context = CreateInMemoryContext(\"MyTests\"); SeedTestData(); } public void Dispose() { // 所有测试结束后运行 _context?.Dispose(); } [Fact] public async Task Test1() { /* 使用 _context */ } [Fact] public async Task Test2() { /* 使用 _context */ } } 6.2.8 监控测试覆盖率，但不迷信 使用工具（如 Coverlet）来测量代码覆盖率。目标是达到一个合理的水平（例如 80%），但不要盲目追求 100%。 不需要测试的代码： 自动生成的代码（如 EF Core 的 OnModelCreating） 简单的 Getter/Setter 明显的、无逻辑的 DTO 类 重点测试的代码： 复杂的业务逻辑 条件分支和循环 错误处理和异常路径 6.3 总结：选择正确的工具 最后，让我们回顾一下三种主要测试技术的适用场景： 场景 Mocking In-Memory Database SQLite 测试纯业务逻辑 ✅ 首选 ❌ 不需要 ❌ 不需要 快速验证 LINQ 查询 ⚠️ 有限 ✅ 首选 ⚠️ 较慢但可以 验证完整 CRUD 流程 ❌ 无法 ✅ 非常适合 ✅ 非常适合 测试数据库约束 ❌ 无法 ❌ 无法 ✅ 首选 持续集成 (CI) ✅ 极佳 ✅ 极佳 ✅ 极佳 测试复杂事务 ⚠️ 困难 ⚠️ 有限 ✅ 首推 终极建议 以 Mocking 为主，In-Memory 为辅，关键路径用 SQLite 加固。 根据你的应用特点和风险点，灵活组合这些技术，构建一个高效、可靠的测试防护网。"
  },
  "docs/Testing/Microsoft.EntityFrameworkCore.InMemory.html": {
    "href": "docs/Testing/Microsoft.EntityFrameworkCore.InMemory.html",
    "title": "内存数据库提供程序：Microsoft.EntityFrameworkCore.InMemory | CZQDocs",
    "summary": "内存数据库提供程序：Microsoft.EntityFrameworkCore.InMemory 当我们需要进行集成测试时，理想的情况是使用一个快速、轻量级、无需外部依赖的数据库。这就是 In-Memory Database Provider 的用武之地。EF Core 官方提供了一个名为 Microsoft.EntityFrameworkCore.InMemory 的包，它允许我们将 EF Core 配置为使用一个完全驻留在内存中的数据库。 为什么使用 In-Memory Database 进行集成测试？ 速度快：所有数据操作都在内存中完成，没有磁盘 I/O 或网络延迟，测试执行非常迅速。 零外部依赖：不需要安装 SQL Server、PostgreSQL 等数据库服务器。测试可以在任何环境中运行，包括 CI/CD 管道。 隔离性好：每个测试都可以拥有自己独立的内存数据库实例，确保测试间互不影响。 接近真实：它使用真正的 EF Core 查询管道，会执行 SQL 翻译（尽管是翻译成内存操作），因此可以发现查询逻辑错误、导航属性加载等问题。 ⚠️ 重要注意事项与局限性 并非 100% 真实：In-Memory 数据库是一个简化版的数据库，不强制执行真实的数据库约束。 主要局限性： 外键约束 (Foreign Key Constraints)：不会自动级联删除或阻止插入无效的外键 唯一约束 (Unique Constraints)：不会阻止插入重复的值 索引：没有真正的索引，因此无法测试索引相关的性能问题 SQL 特定功能：某些特定于数据库的功能（如 SQL Server 的 ROW_NUMBER()）无法使用 数据持久性：进程结束后，所有数据都会丢失 并发：模拟多用户并发访问的能力有限 结论 In-Memory Database 是进行大部分集成测试的绝佳选择，尤其适合测试： CRUD 操作 LINQ 查询的正确性 业务逻辑流程 但对于需要严格验证数据库约束、复杂事务或性能的场景，仍需考虑使用 SQLite 或真实数据库。 安装与基本使用 安装步骤 在你的测试项目中，通过 NuGet 安装包： dotnet add package Microsoft.EntityFrameworkCore.InMemory 基本使用示例 在测试中配置 DbContext 使用 In-Memory 提供程序： // 在测试方法中 var options = new DbContextOptionsBuilder<AppDbContext>() .UseInMemoryDatabase(databaseName: \"TestDatabase\") // 指定一个数据库名 .Options; using var context = new AppDbContext(options); // 使用配置好的选项创建 DbContext // ... 执行你的测试操作 (Add, Save, Query, etc.) // ... 进行断言 // using 语句确保 context 被释放，数据库被清理 数据库名的作用 UseInMemoryDatabase 使用数据库名来区分不同的内存数据库实例。如果两个 DbContext 实例使用相同的数据库名，它们将共享同一份内存数据。 最佳实践：在测试中，通常为每个测试或每个测试集合使用唯一的数据库名，以保证隔离性。 第4章：集成测试实践——使用 In-Memory Database 在上一章中，我们通过 Mocking 技术隔离了 DbContext，对业务逻辑进行了快速的单元测试。然而，这些测试无法验证 LINQ 查询是否能被正确翻译成 SQL、数据库约束是否生效等关键问题。本章将介绍如何使用 EF Core 的 In-Memory Database Provider 来进行集成测试，这是一种在真实（或近似真实）的数据库环境中验证数据访问代码的有效方法。 4.1 为什么选择 In-Memory Database 进行集成测试？ 正如第2章所述，In-Memory Database 提供了一个完美的中间地带： 速度：接近内存操作的速度，远快于连接真实的数据库服务器。 便利性：无需安装和配置外部数据库，降低了开发和 CI/CD 环境的复杂性。 隔离性：每个测试可以拥有独立的数据库实例，保证了测试的纯净和可重复性。 真实性：它使用了完整的 EF Core 查询管道，会执行从 LINQ 到\"内存查询\"的翻译过程，能够发现许多 Mock 测试无法捕捉的问题。 虽然它不强制执行所有数据库约束，但对于大多数 CRUD 操作和查询逻辑的验证，它已经足够强大。 4.2 配置与初始化 In-Memory DbContext 进行集成测试的第一步是为测试创建一个配置好的 DbContext 实例。 步骤 1: 安装 NuGet 包 确保你的测试项目引用了 Microsoft.EntityFrameworkCore.InMemory 包。 步骤 2: 创建 DbContextOptions 这是最关键的一步。你需要创建一个 DbContextOptionsBuilder 并使用 .UseInMemoryDatabase() 方法。 // TestBase.cs (可选的基础类) public class TestBase { protected AppDbContext CreateContext(string databaseName) { var options = new DbContextOptionsBuilder<AppDbContext>() .UseInMemoryDatabase(databaseName: databaseName) .Options; return new AppDbContext(options); } } // 在具体的测试类中 public class ProductServiceIntegrationTests : TestBase { [Fact] public async Task CreateProductAsync_ValidInput_PersistsToDatabase() { // Arrange: 为这个测试创建一个唯一的数据库名 const string dbName = \"CreateProductTestDb\"; using var context = CreateContext(dbName); // 使用 using 确保释放 var service = new ProductService(context); // Act var product = await service.CreateProductAsync(\"New Phone\", 999.99m); // Assert: 直接查询数据库验证 var savedProduct = await context.Products.FindAsync(product.Id); Assert.NotNull(savedProduct); Assert.Equal(\"New Phone\", savedProduct.Name); Assert.Equal(999.99m, savedProduct.Price); } } 关键点解释 databaseName 参数：这个名称用于区分不同的内存数据库。如果两个 DbContext 实例使用相同的名称，它们会共享同一份数据。因此，在自动化测试中，最好为每个测试生成一个唯一的名称（例如使用 Guid.NewGuid().ToString()），或者在测试结束后清理数据库。 using 语句：AppDbContext 实现了 IDisposable。使用 using 可以确保在测试结束时，上下文被正确释放，相关的内存数据库资源也会被清理。这对于防止内存泄漏和确保测试间隔离至关重要。 4.3 编写基础的 CRUD 集成测试 现在，我们可以编写测试来验证真正的数据库操作。 4.3.1 Create (创建) 测试 [Fact] public async Task CreateProductAsync_ValidInput_IncrementsCountAndSetsId() { // Arrange const string dbName = \"CreateProductCountTest\"; using var context = CreateContext(dbName); var service = new ProductService(context); // 获取初始计数 var initialCount = await context.Products.CountAsync(); // Act await service.CreateProductAsync(\"Laptop\", 1200.00m); // Assert var finalCount = await context.Products.CountAsync(); Assert.Equal(initialCount + 1, finalCount); // 验证新实体的 Id 是否被设置（通常由数据库生成） var createdProduct = await context.Products.FirstAsync(p => p.Name == \"Laptop\"); Assert.True(createdProduct.Id > 0); // 假设使用的是整数主键 } 4.3.2 Read (读取) 测试 [Fact] public async Task GetProductByIdAsync_ExistingId_ReturnsCorrectProduct() { // Arrange const string dbName = \"GetProductByIdTest\"; using var context = CreateContext(dbName); // 手动添加测试数据到数据库 var testProduct = new Product { Name = \"Mouse\", Price = 25.00m }; context.Products.Add(testProduct); await context.SaveChangesAsync(); // 必须先保存 var service = new ProductService(context); // Act var result = await service.GetProductByIdAsync(testProduct.Id); // Assert Assert.NotNull(result); Assert.Equal(testProduct.Id, result.Id); Assert.Equal(\"Mouse\", result.Name); } [Fact] public async Task GetProductsByPriceRangeAsync_ValidRange_ReturnsFilteredProducts() { // Arrange const string dbName = \"GetProductsByPriceRangeTest\"; using var context = CreateContext(dbName); // 添加多条测试数据 var products = new List<Product> { new() { Name = \"Cheap Item\", Price = 10.00m }, new() { Name = \"Mid Item\", Price = 50.00m }, new() { Name = \"Expensive Item\", Price = 200.00m } }; context.Products.AddRange(products); await context.SaveChangesAsync(); var service = new ProductService(context); // Act var results = await service.GetProductsByPriceRangeAsync(20, 100); // Assert Assert.Collection(results, item => Assert.Equal(\"Mid Item\", item.Name)); // 应该只有 Mid Item 符合条件 Assert.DoesNotContain(results, r => r.Name == \"Cheap Item\"); Assert.DoesNotContain(results, r => r.Name == \"Expensive Item\"); } 4.3.3 Update (更新) 和 Delete (删除) 测试 [Fact] public async Task UpdateProductAsync_ValidChanges_UpdatesDatabaseRecord() { // Arrange const string dbName = \"UpdateProductTest\"; using var context = CreateContext(dbName); var product = new Product { Name = \"Old Name\", Price = 100.00m }; context.Products.Add(product); await context.SaveChangesAsync(); var service = new ProductService(context); // Act await service.UpdateProductAsync(product.Id, \"New Name\", 150.00m); // Assert var updatedProduct = await context.Products.FindAsync(product.Id); Assert.NotNull(updatedProduct); Assert.Equal(\"New Name\", updatedProduct.Name); Assert.Equal(150.00m, updatedProduct.Price); } [Fact] public async Task DeleteProductAsync_ExistingId_RemovesFromDatabase() { // Arrange const string dbName = \"DeleteProductTest\"; using var context = CreateContext(dbName); var product = new Product { Name = \"To Be Deleted\", Price = 1.00m }; context.Products.Add(product); await context.SaveChangesAsync(); var service = new ProductService(context); // Act await service.DeleteProductAsync(product.Id); // Assert var deletedProduct = await context.Products.FindAsync(product.Id); Assert.Null(deletedProduct); // 应该已被删除 } 4.4 处理关联关系的集成测试 In-Memory Database 能够很好地处理导航属性和关联关系的加载。 示例：加载订单及其项目 [Fact] public async Task GetOrderWithItemsAsync_ExistingOrder_LoadsItemsCollection() { // Arrange const string dbName = \"GetOrderWithItemsIntegrationTest\"; using var context = CreateContext(dbName); // 手动构建关联数据 var order = new Order { OrderDate = DateTime.Today, Items = new List<OrderItem> { new OrderItem { ProductName = \"Widget\", Quantity = 2 }, new OrderItem { ProductName = \"Gadget\", Quantity = 1 } } }; context.Orders.Add(order); await context.SaveChangesAsync(); // 保存时，EF Core 会处理外键 var service = new OrderService(context); // Act var result = await service.GetOrderWithItemsAsync(order.Id); // Assert Assert.NotNull(result); Assert.Equal(2, result.Items.Count); Assert.Contains(result.Items, i => i.ProductName == \"Widget\"); Assert.Contains(result.Items, i => i.ProductName == \"Gadget\"); } 在这个测试中，当我们调用 context.SaveChangesAsync() 时，EF Core 会自动为 OrderItem 实体设置正确的 OrderId。然后，当我们在服务中使用 .Include(o => o.Items) 查询时，In-Memory 提供程序能够正确地返回包含项目的完整订单对象。 4.5 测试数据管理策略 随着测试数量的增加，如何高效地准备和清理测试数据成为一个挑战。 4.5.1 每个测试独立数据库 (Per-Test Isolation) 这是我们目前采用的策略。为每个测试使用一个唯一的数据库名。 优点： 提供了最强的隔离性 测试完全独立，不会因数据污染而相互影响 缺点： 可能会占用更多内存（尽管很小，每个内存数据库的开销很低） 4.5.2 测试集合共享数据库 (Per-TestCollection) xUnit.net 允许你定义 IClassFixture<T> 或 ICollectionFixture<T>。你可以创建一个共享的 DbContext 实例供同一个测试类或测试集合中的所有测试使用。 // SharedDatabaseFixture.cs public class SharedDatabaseFixture : IDisposable { public AppDbContext Context { get; } public SharedDatabaseFixture() { var options = new DbContextOptionsBuilder<AppDbContext>() .UseInMemoryDatabase(databaseName: \"SharedTestDb\") .Options; Context = new AppDbContext(options); // 可以在这里一次性 Seed 共享的测试数据 SeedData(); } private void SeedData() { if (!Context.Products.Any()) { Context.Products.AddRange(new List<Product> { new() { Name = \"Default Product 1\", Price = 10.00m }, new() { Name = \"Default Product 2\", Price = 20.00m } }); Context.SaveChanges(); } } public void Dispose() => Context?.Dispose(); } // 在测试类中使用 public class ProductServiceSharedTests : IClassFixture<SharedDatabaseFixture> { private readonly AppDbContext _context; public ProductServiceSharedTests(SharedDatabaseFixture fixture) { _context = fixture.Context; // 注意：在使用共享上下文时，需要在每个测试开始前清理数据， // 或者设计测试使其不互相干扰。 ClearTestData(); } private void ClearTestData() { // 删除本测试可能添加的特定数据 var testProducts = _context.Products.Where(p => p.Name.StartsWith(\"Test_\")); _context.Products.RemoveRange(testProducts); _context.SaveChanges(); } [Fact] public async Task SomeTest() { // 使用 _context ... } } 注意：使用共享数据库时，必须非常小心地管理数据状态，避免测试间的污染。 4.5.3 使用种子数据 (Seed Data) 对于有大量固定参考数据的应用，可以在测试启动时一次性播种。EF Core 支持 OnModelCreating 中的 HasData() 方法，或者在测试的 Setup 阶段手动添加。 4.6 In-Memory Database 的局限性再审视 尽管 In-Memory Database 功能强大，但我们必须时刻牢记它的局限性： 无约束检查 如前所述，唯一约束、外键约束不会被强制执行。下面的测试在 In-Memory 中会意外地通过，但在真实数据库中会失败： [Fact] public async Task InsertDuplicateUniqueKey_DoesNotThrow() // ❌ 错误的期望！ { // Arrange const string dbName = \"DuplicateKeyTest\"; using var context = CreateContext(dbName); context.Products.Add(new Product { Name = \"UniqueName\", Price = 10 }); await context.SaveChangesAsync(); // Act & Assert context.Products.Add(new Product { Name = \"UniqueName\", Price = 20 }); // 重复的 Name // 下面这行在真实数据库中会抛出异常，但在 In-Memory 中不会！ await context.SaveChangesAsync(); // 不会抛出 DbUpdateException } 结论：对于涉及约束的关键业务逻辑，必须使用 SQLite 或真实数据库进行补充测试。 有限的 SQL 功能 不支持存储过程、用户自定义函数、窗口函数等高级 SQL 特性 与真实数据库的行为可能存在微小差异 浮点数精度 内存中的浮点运算可能与特定数据库（如 SQL Server 的 DECIMAL/NUMERIC 类型）行为略有不同。"
  },
  "docs/Testing/Moq.html": {
    "href": "docs/Testing/Moq.html",
    "title": "2.2 Mocking 框架：Moq | CZQDocs",
    "summary": "2.2 Mocking 框架：Moq 在进行单元测试时，我们需要将被测代码（通常是业务服务）与其依赖项（如 DbContext）隔离开来。这就是 Mocking 框架发挥作用的地方。 Moq 是 .NET 中最受欢迎、最成熟的 Mocking 框架。 什么是 Mocking？ Mocking 是一种技术，它创建一个对象的“替身”（Mock），这个替身可以模拟真实对象的行为。我们可以对这个 Mock 对象进行配置（Setup），指定当某个方法被调用时应该返回什么值，或者记录该方法是否被调用以及被调用了多少次。 为什么选择 Moq？ LINQ 风格的 API：Moq 使用 LINQ 表达式树来设置期望和行为，语法直观且类型安全。 功能全面：支持方法调用、属性、事件、回调、验证调用次数等几乎所有常见的 Mocking 场景。 易于使用：API 设计简洁，学习曲线平缓。 与 xUnit.net 完美集成：两者都是现代 .NET 开发的标准配置。 核心概念与示例 假设我们有一个 ProductService，它依赖于 AppDbContext 来操作 Products 表。 被测类：ProductService.cs // ProductService.cs public class ProductService { private readonly AppDbContext _context; public ProductService(AppDbContext context) // 通过构造函数注入 { _context = context; } public async Task<Product> CreateProductAsync(string name, decimal price) { if (string.IsNullOrWhiteSpace(name)) throw new ArgumentException(\"Name is required.\", nameof(name)); if (price <= 0) throw new ArgumentException(\"Price must be greater than zero.\", nameof(price)); var product = new Product { Name = name, Price = price }; _context.Products.Add(product); await _context.SaveChangesAsync(); // 关键点：这里会与数据库交互 return product; } } 现在，我们要对 CreateProductAsync 方法进行单元测试。 我们不希望这个测试真正去连接数据库（那会变成集成测试，速度慢且不稳定），而只想测试它的内部逻辑（参数验证、是否调用了 Add 和 SaveChangesAsync）。 测试类：ProductServiceTests.cs // ProductServiceTests.cs using Moq; using Xunit; public class ProductServiceTests { [Fact] public async Task CreateProductAsync_ValidInput_CallsAddAndSaveChanges() { // Arrange: 准备测试环境 // 1. 创建 DbContext 的 Mock 对象 var mockContext = new Mock<AppDbContext>(); // 2. 创建 DbSet<Product> 的 Mock 对象 var mockDbSet = new Mock<DbSet<Product>>(); // 3. 将 mockDbSet 设置到 mockContext 的 Products 属性上 mockContext.Setup(c => c.Products).Returns(mockDbSet.Object); // 4. 创建被测服务，并注入 Mock 的 DbContext var service = new ProductService(mockContext.Object); // Act: 执行被测操作 await service.CreateProductAsync(\"New Phone\", 999.99m); // Assert: 验证结果 // 验证 Products DbSet 的 Add 方法是否被调用了一次 mockDbSet.Verify(m => m.Add(It.IsAny<Product>()), Times.Once()); // 验证 SaveChangesAsync 方法是否被调用了一次 mockContext.Verify(m => m.SaveChangesAsync(It.IsAny<CancellationToken>()), Times.Once()); } [Fact] public async Task CreateProductAsync_EmptyName_ThrowsArgumentException() { // Arrange var mockContext = new Mock<AppDbContext>(); var service = new ProductService(mockContext.Object); // Act & Assert // 验证传入空名称时是否抛出正确的异常 await Assert.ThrowsAsync<ArgumentException>( () => service.CreateProductAsync(\"\", 100)); } } 关键点说明 new Mock () 创建了 T 类型的 Mock 实例。 .Setup(...) 用于配置 Mock 对象的行为。在这里，我们配置了 mockContext.Products 属性的 getter，让它返回我们创建的 mockDbSet.Object。 .Verify(...) 用于断言某个方法或属性是否以预期的方式被调用。这是单元测试中验证“交互”的关键。 Moq 的局限性 ⚠️ Moq 只能 Mock 虚方法 (virtual) 或接口 (interface)。 EF Core 的 DbContext 和 DbSet 的许多关键方法（如 SaveChangesAsync）都是虚方法，因此可以被 Moq 成功 Mock。 但如果要 Mock 的类或方法： 不是 virtual 来自密封类（sealed） 是静态方法 那么 Moq 就无能为力。 ✅ 幸运的是，对于 EF Core 的场景，这通常不是问题。 第3章：单元测试实践——Mocking DbContext 本章将深入探讨如何使用 Moq 框架对 DbContext 及其相关的 DbSet<T> 进行 Mock，从而编写出高效、可靠的单元测试。我们的核心目标是隔离业务逻辑，确保测试只关注被测方法本身的正确性，而不受数据库连接、网络延迟或外部数据状态的影响。 3.1 设计可测试的代码：依赖注入 (DI) 是前提 在进行 Mock 之前，一个至关重要的前提是：你的代码必须设计成易于测试。这通常意味着要遵循**依赖注入（Dependency Injection, DI）**原则。 回顾我们在第2章中提到的 ProductService： public class ProductService { private readonly AppDbContext _context; public ProductService(AppDbContext context) // 构造函数注入 { _context = context; } // ... 方法 } 这种设计模式是单元测试的基础，因为： 可替换性：在生产环境中，DI 容器会注入一个真实的 AppDbContext 实例 可 Mock 性：在测试环境中，我们可以手动创建一个 ProductService 的实例，并传入一个 Mock 的 AppDbContext 对象 ❌ 不可测试的设计 如果 ProductService 像下面这样直接创建 DbContext，那么它将变得几乎无法进行单元测试： public class BadProductService { public async Task<Product> CreateProductAsync(string name, decimal price) { using var context = new AppDbContext(); // 直接 new，无法替换 // ... 操作 context await context.SaveChangesAsync(); } } 结论：始终通过构造函数注入 DbContext 或其抽象（如仓储接口），这是编写可测试代码的第一步。 3.2 Mock DbSet：基础操作的模拟 DbSet<T> 是我们与实体集交互的主要入口。最常见的操作是 Add、Update、Remove 和查询（通过 LINQ）。我们需要学会如何 Mock 这些行为。 3.2.1 模拟查询操作 (IQueryable ) 这是最常见也最关键的场景。许多业务逻辑都基于查询数据库。 问题：DbSet<T> 实现了 IQueryable<T>。Moq 不能直接让一个 Mock<DbSet<T>> 表现出完整的 IQueryable 行为（例如支持 .Where()、.Select() 等 LINQ 操作）。 解决方案：我们需要创建一个支持 LINQ to Objects 的 IQueryable<T> 集合，并将其设置为 DbSet<T> 的返回值。 [Fact] public async Task GetActiveProductsAsync_ReturnsOnlyActiveProducts() { // Arrange var mockContext = new Mock<AppDbContext>(); // 1. 准备测试数据 var testData = new List<Product> { new Product { Id = 1, Name = \"Phone\", IsActive = true }, new Product { Id = 2, Name = \"Laptop\", IsActive = false }, // 非活跃 new Product { Id = 3, Name = \"Tablet\", IsActive = true } }.AsQueryable(); // 转换为 IQueryable // 2. 创建 Mock 的 DbSet var mockDbSet = new Mock<DbSet<Product>>(); // 3. 关键步骤：配置 mockDbSet 表现得像一个 IQueryable // 我们需要设置它的提供程序和表达式 mockDbSet.As<IQueryable<Product>>().Setup(m => m.Provider).Returns(testData.Provider); mockDbSet.As<IQueryable<Product>>().Setup(m => m.Expression).Returns(testData.Expression); mockDbSet.As<IQueryable<Product>>().Setup(m => m.ElementType).Returns(testData.ElementType); mockDbSet.As<IQueryable<Product>>().Setup(m => m.GetEnumerator()).Returns(testData.GetEnumerator); // 4. 将 mockDbSet 设置到 mockContext mockContext.Setup(c => c.Products).Returns(mockDbSet.Object); // 5. 创建服务 var service = new ProductService(mockContext.Object); // Act var result = await service.GetActiveProductsAsync(); // Assert Assert.Equal(2, result.Count()); // 应该只有 2 个活跃产品 Assert.All(result, p => Assert.True(p.IsActive)); // 断言所有结果都是活跃的 } 这个模式很繁琐。我们可以创建一个帮助类来简化它： // TestHelper.cs public static class TestHelper { public static Mock<DbSet<T>> CreateMockDbSet<T>(IQueryable<T> data) where T : class { var mockSet = new Mock<DbSet<T>>(); mockSet.As<IQueryable<T>>().Setup(m => m.Provider).Returns(data.Provider); mockSet.As<IQueryable<T>>().Setup(m => m.Expression).Returns(data.Expression); mockSet.As<IQueryable<T>>().Setup(m => m.ElementType).Returns(data.ElementType); mockSet.As<IQueryable<T>>().Setup(m => m.GetEnumerator()).Returns(data.GetEnumerator()); return mockSet; } } // 在测试中使用 var testData = new List<Product>{ /* ... */ }.AsQueryable(); var mockDbSet = TestHelper.CreateMockDbSet(testData); mockContext.Setup(c => c.Products).Returns(mockDbSet.Object); 3.2.2 模拟 CUD 操作 (Create, Update, Delete) 对于 Add、Update、Remove 操作，我们通常不关心它们的\"返回值\"，而是关心它们是否被调用，以及被调用了多少次。这正是 .Verify() 方法的用武之地。 [Fact] public async Task DeleteProductAsync_ExistingId_CallsRemoveAndSaveChanges() { // Arrange var mockContext = new Mock<AppDbContext>(); var mockDbSet = new Mock<DbSet<Product>>(); mockContext.Setup(c => c.Products).Returns(mockDbSet.Object); var service = new ProductService(mockContext.Object); var productId = 1; // Act await service.DeleteProductAsync(productId); // Assert // 验证 Remove 方法被调用了一次，且参数是正确的 Product 对象 // 注意：这里我们不知道具体的 Product 实例，所以用 It.IsAny<Product>() mockDbSet.Verify(m => m.Remove(It.IsAny<Product>()), Times.Once()); // 验证 SaveChangesAsync 被调用了一次 mockContext.Verify(m => m.SaveChangesAsync(It.IsAny<CancellationToken>()), Times.Once()); } [Fact] public async Task UpdateProductAsync_ValidInput_CallsUpdateAndSaveChanges() { // Arrange var mockContext = new Mock<AppDbContext>(); var mockDbSet = new Mock<DbSet<Product>>(); mockContext.Setup(c => c.Products).Returns(mockDbSet.Object); var service = new ProductService(mockContext.Object); var productToUpdate = new Product { Id = 1, Name = \"Old Name\", Price = 100 }; // Act await service.UpdateProductAsync(productToUpdate, \"New Name\", 200); // Assert mockDbSet.Verify(m => m.Update(It.IsAny<Product>()), Times.Once()); mockContext.Verify(m => m.SaveChangesAsync(It.IsAny<CancellationToken>()), Times.Once()); } 3.3 处理复杂的导航属性和关联关系 现实世界中的实体往往通过导航属性相互关联（一对多、多对多等）。Mock 这些关系的查询需要更精细的控制。 示例场景 有一个 Order 实体，它包含多个 OrderItem： public class Order { public int Id { get; set; } public DateTime OrderDate { get; set; } public virtual ICollection<OrderItem> Items { get; set; } = new List<OrderItem>(); } public class OrderItem { public int Id { get; set; } public int OrderId { get; set; } public virtual Order Order { get; set; } public string ProductName { get; set; } public int Quantity { get; set; } } 现在，我们要测试一个服务方法，它根据订单 ID 获取订单及其所有项目： public async Task<Order> GetOrderWithItemsAsync(int orderId) { return await _context.Orders .Include(o => o.Items) // 包含 Items 导航属性 .FirstOrDefaultAsync(o => o.Id == orderId); } 为了测试这个方法，我们需要 Mock 两个 DbSet：Orders 和 OrderItems，并确保 Include 操作能正确地\"连接\"它们。 [Fact] public async Task GetOrderWithItemsAsync_ExistingOrder_ReturnsOrderWithItems() { // Arrange var mockContext = new Mock<AppDbContext>(); // 准备 Orders 数据 var ordersData = new List<Order> { new Order { Id = 1, OrderDate = DateTime.Today } // 注意：这里 Items 集合是空的，但我们会通过 Include 来\"填充\" }.AsQueryable(); // 准备 OrderItems 数据 var orderItemsData = new List<OrderItem> { new OrderItem { Id = 1, OrderId = 1, ProductName = \"Widget\", Quantity = 2 }, new OrderItem { Id = 2, OrderId = 1, ProductName = \"Gadget\", Quantity = 1 } }.AsQueryable(); // 创建 Mock 的 DbSets var mockOrdersSet = TestHelper.CreateMockDbSet(ordersData); var mockOrderItemsSet = TestHelper.CreateMockDbSet(orderItemsData); // 设置 Context mockContext.Setup(c => c.Orders).Returns(mockOrdersSet.Object); mockContext.Setup(c => c.OrderItems).Returns(mockOrderItemsSet.Object); var service = new OrderService(mockContext.Object); // Act var result = await service.GetOrderWithItemsAsync(1); // Assert Assert.NotNull(result); Assert.Equal(1, result.Id); Assert.Equal(2, result.Items.Count); // 断言 Items 集合被正确填充 Assert.Contains(result.Items, i => i.ProductName == \"Widget\"); } 在这个例子中，EF Core 的查询管道会处理 Include 语句。由于我们 Mock 的 DbSet<Order> 和 DbSet<OrderItem> 都提供了 IQueryable，Moq 允许 EF Core 的查询执行引擎去\"执行\"这个包含查询。虽然这不是真正的 SQL JOIN，但 Moq 提供的 IQueryable 支持基本的内存中连接操作，足以满足大多数测试需求。 3.4 验证方法调用与参数 .Verify() 方法非常强大，可以精确地验证方法是如何被调用的。 验证调用次数 mockContext.Verify(m => m.SaveChangesAsync(), Times.Once()); // 恰好一次 mockContext.Verify(m => m.SaveChangesAsync(), Times.Exactly(2)); // 恰好两次 mockContext.Verify(m => m.SaveChangesAsync(), Times.AtLeastOnce()); // 至少一次 mockContext.Verify(m => m.SaveChangesAsync(), Times.Never()); // 从未被调用 验证参数 使用 It.Is<T>() 或 It.IsAny<T>()： // 验证 Remove 被调用时，传入的 Product 的 Id 是 5 mockDbSet.Verify(m => m.Remove( It.Is<Product>(p => p.Id == 5)), Times.Once()); // 验证 Add 被调用时，传入的 Product 的 Name 不为空 mockDbSet.Verify(m => m.Add( It.Is<Product>(p => !string.IsNullOrEmpty(p.Name))), Times.Once()); 回调 (Callback) 如果你想在 Mock 方法被调用时执行一些自定义逻辑（例如，修改传入的对象），可以使用 Callback： Product capturedProduct = null; mockDbSet.Setup(m => m.Add(It.IsAny<Product>())) .Callback<Product>(p => capturedProduct = p); // 捕获传入的 Product // ... 执行操作 ... // 断言被捕获的对象 Assert.NotNull(capturedProduct); Assert.Equal(\"Expected Name\", capturedProduct.Name); 3.5 单元测试的局限性总结 尽管 Mocking 功能强大，但它也有明显的局限性： 不验证 SQL：你无法知道你的 LINQ 查询会被翻译成什么样的 SQL。一个低效的查询在单元测试中可能表现完美，但在生产环境中却成为性能瓶颈。 不验证数据库约束：外键、唯一性等约束不会被强制执行，因此无法发现因违反约束而导致的 DbUpdateException。 不验证事务行为：Mock 无法模拟真实的数据库事务隔离级别和并发控制。 过度 Mock：如果 Mock 了太多细节，测试可能会变得脆弱，一旦内部实现改变（即使功能不变），测试就会失败。 结论：单元测试应该与集成测试结合使用。单元测试确保逻辑正确，集成测试确保与数据库的集成正确。"
  },
  "docs/Testing/NET的单元测试最佳做法.html": {
    "href": "docs/Testing/NET的单元测试最佳做法.html",
    "title": ".NET 的单元测试最佳做法 | CZQDocs",
    "summary": ".NET 的单元测试最佳做法 一、单元测试的优点 节省时间：相比耗时的功能测试，单元测试可毫秒级自动运行 防止回归：代码变更后能快速验证现有功能是否被破坏 可执行文档：清晰的测试用例能说明代码在不同输入下的预期行为 促进解耦：难以测试的代码通常意味着耦合度过高，写测试会自然推动代码解耦 二、良好单元测试的特征 (FIRST 原则) 特征 说明 快速 (Fast) 测试应快速执行 独立 (Independent) 测试应能独立运行，不依赖外部环境（如数据库、文件系统） 可重复 (Repeatable) 在相同条件下，测试结果应始终一致 自我验证 (Self-Validating) 测试应自动判断通过或失败，无需人工检查 适时 (Timely) 编写测试不应耗费过多不必要的时间 三、关键概念辨析 Fake (伪对象) 存根（Stub）和模拟（Mock）的统称 Stub (存根) 为测试提供可控的依赖项替代品，用于\"安排\"（Arrange）阶段，不用于断言 Mock (模拟) 一种特殊的伪对象，其交互（如方法是否被调用）是测试\"断言\"（Assert）的一部分 关键区别 如果在 Assert 阶段检查了该对象的状态或行为，它就是 Mock；否则，它就是 Stub。 正确使用术语能避免团队误解。 四、核心最佳做法 1. 遵循命名规范 测试名称应清晰表达三要素：被测方法、测试场景、预期结果 // ✅ 好的命名 public void Add_EmptyString_ReturnsZero() // ❌ 差的命名 public void Test_Single() 2. 使用\"排列-操作-断言\" (Arrange-Act-Assert) 模式 [Fact] public void Add_TwoNumbers_ReturnsSum() { // Arrange (安排)：创建并配置对象和依赖项 var calculator = new Calculator(); // Act (操作)：调用被测方法 var result = calculator.Add(3, 5); // Assert (断言)：验证结果是否符合预期 Assert.Equal(8, result); } 此模式提升测试的可读性和结构清晰度。 3. 编写最简通过测试 使用最简单、最小的数据来验证行为。例如，测试单个数字相加，用 \"0\" 比用 \"42\" 更能体现\"最简\"原则，减少不必要的复杂性。 // ✅ 更简洁 [Fact] public void Add_ZeroAndNumber_ReturnsNumber() { var result = calculator.Add(0, 5); Assert.Equal(5, result); } 4. 避免\"魔法字符串\" (Magic Strings) 避免在测试中直接硬编码意义不明的值。应将其定义为有明确含义的常量。 // ❌ 不推荐 if (result == \"1001\") { /* ... */ } // ✅ 推荐 private const string MAXIMUM_RESULT = \"1001\"; if (result == MAXIMUM_RESULT) { /* ... */ } 5. 避免在测试中编写逻辑 测试代码中应尽量避免 if、for、while 等逻辑控制语句，以防止测试本身出现 Bug。 如果需要测试多种情况，应使用参数化测试，而不是在单个测试中用循环。 // ❌ 不推荐 [Fact] public void Add_MultipleCases() { for (int i = 0; i < 10; i++) { /* ... */ } } // ✅ 推荐使用参数化测试 [Theory] [InlineData(1, 2, 3)] [InlineData(0, 0, 0)] [InlineData(-1, 1, 0)] public void Add_VariousNumbers_ReturnsSum(int a, int b, int expected) { Assert.Equal(expected, calculator.Add(a, b)); } 6. 使用帮助程序方法，而非 Setup/Teardown 优先使用自定义的帮助方法来创建测试对象，而不是依赖测试框架的全局 Setup 方法。这能提高测试的可读性，避免不必要的共享状态和过度/不足的初始化。 // ✅ 推荐 private Product CreateTestProduct(string name, decimal price) { return new Product { Name = name, Price = price }; } [Fact] public void SomeTest() { var product = CreateTestProduct(\"Phone\", 999); // 清晰明确 // ... } 7. 避免单个测试包含多个 Act 操作 一个测试应只关注一个行为。如果一个测试中有多个 Act，应将其拆分为多个独立测试或使用参数化测试。这能确保测试失败时能精确定位问题。 // ❌ 不推荐 [Fact] public void MultipleActs() { service.Action1(); // 第一个操作 // Assert... service.Action2(); // 第二个操作 // Assert... } // ✅ 推荐拆分为多个测试 [Fact] public void Action1_ShouldWork() { /* ... */ } [Fact] public void Action2_ShouldWork() { /* ... */ } 8. 通过公共方法测试私有方法 通常不需要为 private 方法编写直接的单元测试。应通过测试调用它的公共方法来间接验证其行为，因为私有方法的实现细节可能变化，而公共方法的行为才是最终的契约。 // ✅ 测试公共方法 [Fact] public void PublicMethod_WhenCalled_ExecutesCorrectly() { var result = service.PublicMethod(); Assert.Equal(expected, result); // 间接验证私有方法的逻辑 } 9. 使用\"接缝\" (Seams) 处理静态依赖 当代码依赖静态调用（如 DateTime.Now）时，难以进行控制和测试。解决方案是引入\"接缝\"，即通过依赖注入将静态调用封装在接口中，然后在测试时用 Stub/Mock 替换，从而完全控制其返回值。 // 1. 定义接口 public interface IDateTimeService { DateTime Now { get; } } // 2. 生产实现 public class DateTimeService : IDateTimeService { public DateTime Now => DateTime.Now; } // 3. 使用 DI 注入 public class MyService { private readonly IDateTimeService _dateTimeService; public MyService(IDateTimeService dateTimeService) { _dateTimeService = dateTimeService; } public bool IsBusinessHours() { var now = _dateTimeService.Now; return now.Hour >= 9 && now.Hour < 17; } } // 4. 测试中 Mock [Fact] public void IsBusinessHours_Noon_ReturnsTrue() { var mockDateTime = new Mock<IDateTimeService>(); mockDateTime.Setup(d => d.Now).Returns(new DateTime(2024, 1, 1, 12, 0, 0)); // 中午12点 var service = new MyService(mockDateTime.Object); Assert.True(service.IsBusinessHours()); } 总结 该文档强调，优秀的单元测试不仅是验证代码正确性的工具，更是高质量的、可维护的活文档。关键在于写出可读性强、独立、稳定且专注的测试。遵循上述最佳实践，可以构建一个可靠的测试套件，从而增强代码质量、提升开发效率并有效防止回归。"
  },
  "docs/Testing/Nunit.html": {
    "href": "docs/Testing/Nunit.html",
    "title": "| CZQDocs",
    "summary": "Nunit 功能介绍 NUnit 是一个流行的开源单元测试框架，专为 .NET 平台设计。它提供了一套丰富的功能，帮助开发者编写、组织和运行单元测试，从而提高代码质量和可靠性。以下是 NUnit 的一些主要功能： 丰富的断言库 NUnit 提供了多种断言方法，允许开发者验证代码行为是否符合预期。例如，Assert.AreEqual、Assert.IsTrue、Assert.Throws 等，覆盖了各种常见的测试场景。 [Test] public void TestAddition() { int result = Calculator.Add(2, 3); Assert.AreEqual(5, result); } 灵活的测试组织 NUnit 支持通过属性（Attributes）来组织测试用例。开发者可以使用 [TestFixture] 来定义测试类，使用 [Test] 来标记测试方法，还可以使用 [SetUp] 和 [TearDown] 来进行测试前后的初始化和清理工作。 [SetUp]作用：在测试方法执行之前执行，通常用于初始化测试环境。 [TearDown] 作用：在测试方法执行之后执行，通常用于清理测试环境。 [TestFixture] public class CalculatorTests { private Calculator calculator; [SetUp] public void Setup() { calculator = new Calculator(); } [Test] public void TestAddition() { int result = calculator.Add(2, 3); Assert.AreEqual(5, result); } [TearDown] public void Teardown() { // 清理资源 } } 参数化测试 NUnit 支持参数化测试，允许开发者使用不同的输入数据运行同一个测试方法。可以使用 [TestCase] 属性来定义多个测试用例。 [Test] [TestCase(2, 3, 5)] [TestCase(-1, 1, 0)] [TestCase(0, 0, 0)] public void TestAddition(int a, int b, int expected) { int result = calculator.Add(a, b); Assert.AreEqual(expected, result); } 并行测试执行 NUnit 支持并行执行测试用例，能够显著减少测试运行时间。开发者可以通过配置属性来启用并行测试。 [TestFixture] [Parallelizable(ParallelScope.All)] public class CalculatorTests { // 测试方法 } 测试结果报告 NUnit 提供了多种格式的测试结果报告，方便开发者查看测试结果和分析失败原因。可以生成 XML、HTML 等格式的报告。 nunit3-console.exe MyTests.dll --result=TestResult.xml;format=nunit2 集成支持 NUnit 可以与多种持续集成工具（如 Jenkins、Azure DevOps、GitHub Actions 等）集成，方便自动化测试流程。 - name: Run NUnit Tests run: | dotnet test MyTests.csproj --logger \"trx;LogFileName=test_results.trx\" 扩展性 NUnit 提供了丰富的扩展点，允许开发者创建自定义的断言、属性和测试运行器，以满足特定的测试需求。 public class CustomAssert { public static void IsPositive(int value) { Assert.IsTrue(value > 0, \"Value should be positive\"); } } Assert的断言方法 在 NUnit 新的约束模型中，Assert 类提供了多种断言方法用于验证测试条件。以下是常用的断言方法分类和说明： Assert.Multiple Assert.Multiple NUnit 提供了一个名为 Assert.Multiple 的方法，允许在单个测试方法中运行多个断言。其作原理是，在测试方法中，使用 Assert.Multiple 方法包裹多个断言，然后使用 Assert.Multiple.End 方法结束。区别于单个断言，多个断言可以一起运行，如果其中某个断言失败，则整个测试方法会失败。 基本断言 Assert.That(actual, Is.EqualTo(expected)) - 验证两个值是否相等 Assert.That(actual, Is.Not.EqualTo(expected)) - 验证两个值是否不相等 Assert.That(actual, Is.SameAs(expected)) - 验证两个对象是否引用同一个实例 Assert.That(actual, Is.Not.SameAs(expected)) - 验证两个对象是否引用不同实例 Assert.That(object, Is.Null) - 验证对象是否为 null Assert.That(object, Is.Not.Null) - 验证对象是否不为 null Assert.That(condition, Is.True) - 验证条件是否为 true Assert.That(condition, Is.False) - 验证条件是否为 false 数值比较断言 Assert.That(value, Is.GreaterThan(expected)) - 验证值是否大于期望值 Assert.That(value, Is.GreaterThanOrEqualTo(expected)) - 验证值是否大于等于期望值 Assert.That(value, Is.LessThan(expected)) - 验证值是否小于期望值 Assert.That(value, Is.LessThanOrEqualTo(expected)) - 验证值是否小于等于期望值 Assert.That(value, Is.InRange(min, max)) - 验证值是否在指定范围内 字符串断言 Assert.That(actual, Does.Contain(expected)) - 验证字符串是否包含指定子串 Assert.That(actual, Does.StartWith(expected)) - 验证字符串是否以指定前缀开始 Assert.That(actual, Does.EndWith(expected)) - 验证字符串是否以指定后缀结束 Assert.That(actual, Is.EqualTo(expected).IgnoreCase) - 验证字符串是否相等（忽略大小写） Assert.That(actual, Does.Not.Contain(unexpected)) - 验证字符串是否不包含指定子串 集合断言 Assert.That(collection, Is.EquivalentTo(expected)) - 验证两个集合是否包含相同元素 Assert.That(collection, Contains.Item(element)) - 验证集合是否包含指定元素 Assert.That(collection, Does.Not.Contain(element)) - 验证集合是否不包含指定元素 Assert.That(collection, Is.Empty) - 验证集合是否为空 Assert.That(collection, Is.Not.Empty) - 验证集合是否不为空 Assert.That(collection, Has.Count.EqualTo(expected)) - 验证集合元素数量 文件断言 Assert.That(file, Does.Exist) - 验证文件是否存在 Assert.That(file, Does.Not.Exist) - 验证文件是否不存在 异常断言 Assert.That(code, Throws.TypeOf<ExceptionType>()) - 验证代码是否抛出指定类型的异常 Assert.That(code, Throws.Nothing) - 验证代码是否不抛出异常 Assert.That(code, Throws.Exception.With.Message.Contains(expected)) - 验证异常消息 逻辑组合断言 Assert.That(actual, Is.Not.EqualTo(unexpected)) - 逻辑非 Assert.That(actual, Is.GreaterThan(min).And.LessThan(max)) - 逻辑与 Assert.That(actual, Is.LessThan(min).Or.GreaterThan(max)) - 逻辑或 这些断言方法使用 NUnit 的约束模型，提供了更自然的语法和更好的错误消息，帮助开发者编写更具表达力的单元测试。 这些断言方法可以帮助开发者编写全面的单元测试，验证各种条件和场景。 总结 NUnit 是一个功能强大且灵活的单元测试框架，提供了丰富的功能来支持各种测试需求。通过使用 NUnit，开发者可以更轻松地编写高质量的测试用例，从而提升代码的可靠性和维护性。"
  },
  "docs/Testing/TDD.html": {
    "href": "docs/Testing/TDD.html",
    "title": "1.3 测试驱动开发 (TDD) 简介 | CZQDocs",
    "summary": "1.3 测试驱动开发 (TDD) 简介 测试驱动开发（Test-Driven Development, TDD）是一种敏捷开发实践，其核心流程是 “红-绿-重构”（Red-Green-Refactor）： 红 (Red)：先编写一个失败的测试（通常是单元测试），用来描述你想要实现的功能。 绿 (Green)：编写最少的代码让这个测试通过。 重构 (Refactor)：在不改变功能的前提下，优化代码结构，使其更清晰、更易维护。 \uD83D\uDCA1 TDD 的本质不是“写更多测试”，而是“用测试来驱动设计”。 TDD 的好处 强制思考：在写实现之前就必须明确需求和接口。 高质量代码：产生的代码天生就是可测试的，促进了松耦合的设计。 详尽的测试覆盖：所有代码都是为了通过某个测试而编写的。 自信重构：庞大的测试套件让你可以大胆地重构，而不必担心破坏现有功能。 虽然本系列的重点是“如何测试”，但理解 TDD 的理念有助于我们写出更易于测试的代码。"
  },
  "docs/Testing/xUnit.net.html": {
    "href": "docs/Testing/xUnit.net.html",
    "title": "xUnit.net | CZQDocs",
    "summary": "xUnit.net 在 .NET 平台，有三大主流的测试框架：xUnit.net、MSTest 和 NUnit。 虽然三者都能胜任工作，但 xUnit.net 因其现代化的设计、简洁的 API 和强大的扩展性，已成为 .NET Core/.NET 5+ 社区的事实标准，也是我们推荐的选择。 为什么选择 xUnit.net？ ✅ 设计理念先进 无静态状态：与 MSTest 不同，xUnit.net 的 TestCollection 默认是隔离的。这意味着同一个类中的不同测试方法不会共享一个实例，从而避免了测试间的副作用。每个测试方法都会创建一个新的测试类实例。 ✅ 数据驱动测试更优雅 通过 [Theory] 和 [InlineData]、[MemberData] 等特性，可以非常方便地编写参数化测试，用不同的输入数据运行同一个测试逻辑。 ✅ 丰富的断言库 xUnit.net 自带了一个强大且流畅的断言库（Assert 类），提供了比其他框架更细致的断言方法，例如： Assert.Contains Assert.DoesNotContain Assert.InRange Assert.IsType 它也完美兼容第三方断言库，如 FluentAssertions，后者能提供更具可读性的“流式”断言。 ✅ 强大的扩展模型 xUnit.net 拥有极佳的扩展性。你可以轻松创建自定义的特性（Attributes）、数据源、断言等。这对于构建复杂的测试夹具（Fixture）和共享上下文至关重要。 ✅ 社区与生态 作为 ASP.NET Core 官方项目使用的测试框架，xUnit.net 拥有最活跃的社区支持和最丰富的文档、教程资源。 核心特性示例 using Xunit; public class CalculatorTests { // 基本测试 [Fact] public void Add_TwoNumbers_ReturnsSum() { var calculator = new Calculator(); var result = calculator.Add(2, 3); Assert.Equal(5, result); // 断言相等 } // 数据驱动测试 (Theory) [Theory] [InlineData(2, 3, 5)] [InlineData(-1, 1, 0)] [InlineData(0, 0, 0)] public void Add_MultipleScenarios_ReturnsCorrectSum(int a, int b, int expected) { var calculator = new Calculator(); var result = calculator.Add(a, b); Assert.Equal(expected, result); } // 异常测试 [Fact] public void Divide_ByZero_ThrowsDivideByZeroException() { var calculator = new Calculator(); Assert.Throws<DivideByZeroException>(() => calculator.Divide(5, 0)); } } 关键特性说明 [Fact]：标记一个方法是一个测试事实（必须通过）。 [Theory]：标记一个方法是一个理论，需要数据来验证。 [InlineData(...)]：为 [Theory] 提供一行内联数据。"
  },
  "docs/Testing/引言与测试基础.html": {
    "href": "docs/Testing/引言与测试基础.html",
    "title": "引言与测试基础 | CZQDocs",
    "summary": "引言与测试基础 为什么需要测试数据访问层？ 数据是现代应用的核心。Entity Framework Core（EF Core）作为 .NET 主流的对象关系映射（ORM）框架，负责处理实体映射、查询翻译、事务管理等复杂任务，也因此成为最易出错且最难调试的环节之一。 未经充分测试的数据访问层可能导致： 数据不一致：并发处理不当或业务逻辑错误引发数据损坏 性能瓶颈：低效的 LINQ 查询被翻译成性能糟糕的 SQL 隐蔽 Bug：空值处理、外键约束等边界问题仅在特定场景暴露 重构恐惧：缺乏测试保护，开发者不敢修改现有代码 有效的测试策略能帮助我们： 验证正确性：确保 CRUD 操作、复杂查询与业务规则按预期执行 提升可维护性：清晰的测试用例即文档，支持安全重构 加速反馈循环：本地快速运行，无需部署即可发现问题 增强发布信心：自动化测试套件提供可靠的质量保障 1.2 单元测试 vs. 集成测试 理解二者的区别是设计有效测试策略的基础。 单元测试 定义：针对软件最小可测试单元（通常是方法或类）的测试，核心思想是隔离。 目标：验证单个组件的内部逻辑，不依赖外部系统（如数据库、网络）。 特点： ⚡ 速度快：毫秒级完成 \uD83C\uDF9B️ 可控性强：通过 Mock/Stub 精确模拟依赖行为 \uD83D\uDCCA 覆盖率高：易于覆盖分支路径与异常情况 \uD83D\uDD0C 依赖注入：要求代码具备良好的 DI 设计，便于替换依赖 在 EF Core 中的应用：测试使用 DbContext 的服务类时，用模拟的 DbContext 替代真实数据库连接，验证是否调用了正确的 Add、Update、SaveChanges 等方法，不实际执行 SQL。 集成测试 定义：测试多个组件协同工作，特别是与外部系统（如数据库）的交互。 目标：验证组件间接口及与真实外部资源的集成。 特点： \uD83D\uDC0C 速度较慢：涉及 I/O 操作，执行时间为百毫秒至秒级 \uD83C\uDFAF 真实性高：使用真实或内存数据库，执行实际 SQL 与事务 \uD83D\uDC1B 发现集成问题：捕捉单元测试无法发现的问题： LINQ 是否能正确翻译为有效 SQL？ 数据库约束（主键、外键、唯一索引）是否生效？ 事务提交与回滚是否符合预期？ 是否存在性能陷阱（如 N+1 查询）？ \uD83D\uDDC3️ 状态管理：需仔细管理测试数据，确保独立性与可重复性 核心区别对比 维度 单元测试 集成测试 测试范围 单个方法/类 多组件 + 外部系统 执行速度 毫秒级 百毫秒至秒级 依赖处理 Mock/Stub 隔离 真实依赖（如内存数据库） 覆盖重点 内部逻辑、边界条件 组件协作、持久化、SQL 行为 可维护性 高（强隔离） 中（需管理测试数据） 问题类型 逻辑错误 集成错误、配置错误、性能瓶颈 最佳实践建议 以单元测试为主：覆盖核心业务逻辑，实现快速反馈与高覆盖率 辅以集成测试：覆盖关键数据路径、复杂查询与事务行为 遵循测试金字塔： 底层：大量快速的单元测试（约 70%） 中层：适量的集成测试（约 20%） 顶层：少量端到端/UI 测试（约 10%，视项目而定） ✅ 测试比例并非绝对，应根据项目特点灵活调整，但原则不变——越接近代码的测试越快速、越频繁。"
  },
  "docs/WPF/ControlTemplate和ControlTemplate.html": {
    "href": "docs/WPF/ControlTemplate和ControlTemplate.html",
    "title": "ControlTemplate 与 DataTemplate 核心区别 | CZQDocs",
    "summary": "ControlTemplate 与 DataTemplate 核心区别 在 WPF 中，这两类模板服务于不同的抽象层级： 特性 ControlTemplate DataTemplate 目标对象 控件（Button, TextBox 等） 数据对象（业务实体、ViewModel） 核心职责 定义控件的视觉结构和交互行为 定义数据的视觉呈现方式 典型应用 自定义按钮形状、重制滚动条样式、创建全新控件皮肤 定制列表项布局、内容呈现形式、集合数据显示 使用属性 Control.Template, Style.Setter ItemsControl.ItemTemplate, ContentControl.ContentTemplate 设计思维 无外观的控件 - 控件逻辑与视觉分离 无外观的数据 - 数据与呈现分离 本质差异 ControlTemplate 回答：\"控件应该长什么样？\" 它重塑控件的整个视觉树（Visual Tree），包括背景、边框、状态效果等，但保留控件的核心行为逻辑。例如，将方形按钮变为圆形，不影响其点击命令。 DataTemplate 回答： \"数据应该如何可视化？\" 它仅为数据对象生成呈现内容，通常作为控件内容的一部分。例如，将 Person 对象显示为\"姓名+头像\"的组合，而不改变承载它的 ListBoxItem 控件本身。 决策指南 需要改变控件外观或交互结构 → 使用 ControlTemplate 需要定义数据的展示方式 → 使用 DataTemplate 两者常配合使用：DataTemplate 定义数据呈现，ControlTemplate 定义承载数据的容器样式 最佳实践：优先使用 DataTemplate 呈现数据；仅在需要深度定制控件交互或视觉结构时才使用 ControlTemplate。"
  },
  "docs/WPF/WPF功能.html": {
    "href": "docs/WPF/WPF功能.html",
    "title": "| CZQDocs",
    "summary": "WPF所有功能模块 微软官网 自定义WPF控件的方式 微软官网 WPF数据绑定 数据绑定概述 WPF样式和模板 样式和模板概述 Xaml设计 Xaml 设计"
  },
  "docs/WPF/依赖属性.html": {
    "href": "docs/WPF/依赖属性.html",
    "title": "WPF 依赖属性（DependencyProperty） | CZQDocs",
    "summary": "WPF 依赖属性（DependencyProperty） 核心要点：依赖属性是 WPF 的属性管理系统，存储在全局哈希表中而非对象字段里，为实现数据绑定、动画、样式等高级功能提供基础。 一、什么是依赖属性？ 依赖属性（DP）是 WPF 特有的属性系统，值由 WPF 属性系统统一管理，可依赖多种外部输入（绑定、动画、样式等）动态计算得出。 与标准属性的本质区别： 标准属性值存储在对象实例的私有字段中；依赖属性值存储在 DependencyObject 的高效哈希表里，支持多源求值。 二、为什么需要依赖属性？ 内存优化：控件（如 Button）有上百个属性，依赖属性通过共享默认值、仅存储非默认值，极大减少内存占用 功能基础：支撑数据绑定、样式、模板、动画、属性继承、元数据重写等核心特性 三、如何创建依赖属性 三个步骤（必须在 DependencyObject 派生类中）： public class MyCustomControl : Control { // 1. 声明和注册 public static readonly DependencyProperty MyCustomPropertyProperty = DependencyProperty.Register( \"MyCustomProperty\", // 属性名（必须与字段名一致，后缀\"Property\"） typeof(string), // 属性类型 typeof(MyCustomControl), // 所属类型 new FrameworkPropertyMetadata( // 元数据 \"DefaultValue\", // 默认值 FrameworkPropertyMetadataOptions.AffectsRender, // 变化时重绘 OnMyCustomPropertyChanged // 变化回调（可选） ), ValidateMyCustomValue // 验证回调（可选） ); // 2. .NET属性包装器（方便代码使用，XAML不走这里） public string MyCustomProperty { get => (string)GetValue(MyCustomPropertyProperty); set => SetValue(MyCustomPropertyProperty, value); } // 3. 验证回调 private static bool ValidateMyCustomValue(object value) { string str = value as string; return !string.IsNullOrEmpty(str) && str.Length <= 50; } // 变化回调 private static void OnMyCustomPropertyChanged( DependencyObject d, DependencyPropertyChangedEventArgs e) { var control = d as MyCustomControl; // 处理逻辑，e.OldValue/e.NewValue 包含旧值新值 } } ⚠️ 重要 ：XAML 和绑定直接调用 GetValue/SetValue，包装器仅为代码使用提供便利。 四、核心特性 1. 属性值优先级（从高到低） 优先级 来源 1 本地值（SetValue() 或 XAML 直接设置） 2 样式触发器（Style Triggers） 3 模板触发器（Template Triggers） 4 样式 Setter（Style Setters） 5 主题样式 Setter（Theme Style Setters） 6 继承（父元素传递的值） 7 默认值（注册时指定） 注意：数据绑定结果是表达式，求值后按来源进入相应优先级；SetCurrentValue() 设置的值不被视为\"本地值\"。 2. 属性值继承 子元素自动继承父元素的属性值（如 FontSize, Foreground）。 <StackPanel FontSize=\"20\"> <TextBlock Text=\"自动继承20pt\" /> <!-- 无需重复设置 --> </StackPanel> 实现：注册时设置 FrameworkPropertyMetadataOptions.Inherits = true。 3. 变化通知 元数据中指定 PropertyChangedCallback，属性值最终改变时自动触发。 4. 强制值（Coercion） 在 PropertyChangedCallback 中调用 CoerceValue()，将非法值强制到合法范围（如负数宽度强制为0）。 5. 验证（Validation） ValidateValueCallback 在赋值前验证，失败则抛出异常阻止设置。 五、依赖属性 vs 标准属性 特性 依赖属性 标准属性 内存存储 集中哈希表 每个实例一个字段 内存效率 高（只存非默认值） 低 数据绑定 完全支持 仅支持 OneWayToSource 动画 支持 不支持 样式/模板 支持 不支持 变化通知 内置高效 需手动实现 INotifyPropertyChanged 创建复杂度 较高（需注册） 简单（自动属性） 性能 获取设置稍慢，但系统整体性能优 获取设置快，但功能受限 六、何时使用 ✅ 必须使用 创建自定义控件（Custom Control）需支持样式、模板、绑定时 需要属性值继承 需与动画、触发器交互 ❌ 不应使用 普通数据模型类（ViewModel）→ 应使用 INotifyPropertyChanged 私有或内部简单属性 七、依赖属性如何支撑WPF核心功能 1. 数据绑定 机制：绑定目标必须是依赖属性，绑定引擎通过 SetValue() 更新值 原理：BindingExpression 监听源变化，调用 SetValue() 触发UI更新 2. 样式 机制：Style 的 Setter 指定依赖属性，应用时调用 SetValue() 原理：依赖属性系统按优先级管理样式值与本地值冲突 3. 模板 机制：ControlTemplate 中的 ContentPresenter 通过 TemplateBinding 绑定宿主控件的依赖属性 原理：属性变化通知自动更新模板内呈现 4. 动画 机制：动画目标必须是依赖属性 原理：动画值插入优先级体系，运行时覆盖本地值，通过定时器不断 SetValue() 驱动UI变化 5. 属性值继承 机制：注册时设置 Inherits = true 原理：属性系统在未找到本地值时，沿逻辑树向上遍历查找父元素值 6. 元数据重写 机制：子类用 OverrideMetadata() 修改继承的依赖属性行为 用途：更改默认值、注册新的 PropertyChangedCallback、添加 CoerceValueCallback 7. 验证、回调和强制 验证：ValidateValueCallback 阻止非法值 回调：PropertyChangedCallback 响应变化 强制：CoerceValueCallback 在值确定前干预，实现属性间依赖（如 Width 不小于 MinWidth） 总结 依赖属性是 WPF 响应式、声明式UI的基石。其中心化存储与多源求值机制，实现了高效通知、灵活值管理和强大扩展性。 关键要点： 静态 DependencyProperty 实例 + .NET包装器 值由系统按优先级动态计算 是实现高级UI功能的必要条件 掌握依赖属性是深入理解 WPF 框架的关键一步。"
  },
  "docs/WPF/依赖属性元数据类.html": {
    "href": "docs/WPF/依赖属性元数据类.html",
    "title": "PropertyMetadata 与 FrameworkPropertyMetadata | CZQDocs",
    "summary": "PropertyMetadata 与 FrameworkPropertyMetadata WPF 中定义依赖属性行为的两个元数据类，后者是前者的扩展，提供 WPF 框架特有功能。 1. PropertyMetadata（基础元数据） 所有元数据的基类，提供基本功能。 用途： 指定依赖属性默认值 注册 PropertyChangedCallback 注册 CoerceValueCallback 构造函数示例： public static readonly DependencyProperty MyPropertyProperty = DependencyProperty.Register( \"MyProperty\", typeof(string), typeof(MyControl), new PropertyMetadata( \"DefaultValue\", OnMyPropertyChanged, OnCoerceMyProperty ) ); 关键成员： DefaultValue：属性默认值 PropertyChangedCallback：值变化回调 CoerceValueCallback：值强制回调 注意：不包含任何与 UI 渲染、布局或继承相关的标志位。 2. FrameworkPropertyMetadata（框架级元数据） PropertyMetadata 的子类，专为 WPF 框架设计，提供更精细的属性行为控制。 构造函数示例： public static readonly DependencyProperty BackgroundProperty = DependencyProperty.Register( \"Background\", typeof(Brush), typeof(Control), new FrameworkPropertyMetadata( null, FrameworkPropertyMetadataOptions.AffectsRender | FrameworkPropertyMetadataOptions.Inherits, OnBackgroundChanged ) ); 关键标志位： 标志位 说明 AffectsArrange 属性改变触发父元素 Arrange 过程（如 Margin） AffectsMeasure 属性改变触发父元素 Measure 过程（如 Width、Height） AffectsParentArrange 子元素属性改变影响父元素 Arrange AffectsParentMeasure 子元素属性改变影响父元素 Measure AffectsRender 属性改变触发 UI 重绘（如 Background、Foreground） Inherits 启用属性值继承，子元素自动继承父元素值（如 FontSize） BindsTwoWayByDefault 默认双向绑定，适合用户可编辑属性（如 TextBox.Text） Journal 属性值被导航历史记录（Journal）跟踪 NotDataBindable 明确表示该属性不支持数据绑定（极少用） OverridesInheritanceBehavior 阻止属性值继承继续传播 SubPropertiesDoNotAffectRender 即使属性的子属性改变也不触发渲染更新（性能优化） 何时使用哪个？ 场景 推荐 简单自定义属性，仅需默认值和变化回调 ✅ PropertyMetadata 属性改变影响布局（大小、位置） ✅ FrameworkPropertyMetadata（AffectsMeasure/AffectsArrange） 属性改变影响外观（颜色、背景） ✅ FrameworkPropertyMetadata（AffectsRender） 希望属性支持值继承（字体、语言） ✅ FrameworkPropertyMetadata（Inherits） 类似 Text、IsChecked 等双向绑定属性 ✅ FrameworkPropertyMetadata（BindsTwoWayByDefault） 开发 WPF 内部控件或需精细控制框架行为 ✅ FrameworkPropertyMetadata 核心对比 特性 PropertyMetadata FrameworkPropertyMetadata 继承自 - PropertyMetadata 布局/渲染标志 ❌ ✅ 值继承 ❌ ✅ 默认绑定模式 ❌ ✅ 适用场景 基础属性行为 WPF 框架级高级行为 最佳实践 优先使用 FrameworkPropertyMetadata：开发 WPF 控件时，它提供更完整控制 合理设置标志位：正确配置 AffectsMeasure、AffectsRender 可确保布局渲染系统高效工作，避免不必要重绘 按需启用继承：对字体、文本对齐等全局性属性启用 Inherits，提升开发体验 双向绑定默认值：用户输入类属性（如 Text）应设置 BindsTwoWayByDefault 理解两者的区别，是掌握 WPF 自定义控件开发和性能优化的关键一步。"
  },
  "docs/WPF/内容模型.html": {
    "href": "docs/WPF/内容模型.html",
    "title": "| CZQDocs",
    "summary": "微软官网 ContentPresenter 类显示 ContentControl 的内容。 在 WPF（Windows Presentation Foundation）中，ContentPresenter 和 ContentControl 是两个密切相关但职责完全不同的类。理解它们的区别对于掌握 WPF 的控件模板和内容呈现机制至关重要。 简单来说： ContentControl 是一个控件 (Control)，它可以包含并显示单个内容。 ContentPresenter 是一个元素 (Element)，它的作用是在 ContentControl 的模板中呈现其内容。 下面详细解释它们的区别： 定义与角色 ContentControl 角色：它是一个用户界面控件（继承自 Control），是许多 WPF 控件的基础，如 Button, CheckBox, ScrollViewer 等。 功能：ContentControl 负责管理其“内容”（通过 Content 属性设置）。这个内容可以是任何对象，比如字符串、UIElement、自定义对象等。 关键属性： Content: 存储要显示的内容。 ContentTemplate: 指定如何将内容数据转换为 UI 的 DataTemplate。 ContentTemplateSelector: 允许根据内容选择不同模板的模板选择器。 ContentStringFormat: 格式化内容为字符串时使用的格式。 核心任务：管理内容数据，并提供一种机制来决定内容应该如何被可视化。 ContentPresenter 角色：它是一个轻量级的布局元素（继承自 FrameworkElement），专门用于在视觉树中呈现由 ContentControl 或其他类似容器提供的内容。 功能：它不管理内容本身，而是读取 ContentControl 的 Content, ContentTemplate 等属性，并根据这些信息创建实际的 UI 元素并将其添加到视觉树中。 使用场景：通常出现在 ContentControl 的 ControlTemplate 内部。当你为一个 ContentControl（如 Button）编写自定义模板时，你需要在模板中放置一个 ContentPresenter 来告诉 WPF：“在这里显示 ContentControl 的内容”。 使用方式 ContentControl 是你在 XAML 中直接实例化的控件。 <ContentControl Content=\"Hello, World!\" /> <!-- 或者更复杂的 --> <ContentControl> <StackPanel> <TextBlock Text=\"Title\" /> <Image Source=\"logo.png\" /> </StackPanel> </ContentControl> ContentPresenter 几乎总是在 ControlTemplate 中使用，而不是在常规的 UI 布局中。 <Style TargetType=\"ContentControl\"> <Setter Property=\"Template\"> <Setter.Value> <ControlTemplate TargetType=\"ContentControl\"> <Border Background=\"LightBlue\" BorderBrush=\"Black\" BorderThickness=\"1\"> <!-- ContentPresenter 在这里负责显示 ContentControl.Content --> <ContentPresenter Content=\"{TemplateBinding Content}\" ContentTemplate=\"{TemplateBinding ContentTemplate}\" /> </Border> </ControlTemplate> </Setter.Value> </Setter> </Style> 在上面的例子中，ContentPresenter 位于 ContentControl 的模板内，它从 ContentControl 绑定 Content 和 ContentTemplate，然后负责渲染出最终的 UI。 关键区别总结 | 特性 | ContentControl | ContentPresenter | | -------------- | ------------------------------------------------------- | --------------------------------------------------------------------------------- | | 类型 | 控件 (Control) | 布局元素 (FrameworkElement) | | 主要职责 | 管理内容数据 (Content) 和模板 (ContentTemplate) | 在视觉树中呈现由 ContentControl 提供的内容 | | 使用位置 | XAML 中的主 UI 布局 | ContentControl 的 ControlTemplate 内部 | | 是否可直接使用 | 是，可以直接在窗口或页面中放置 | 通常不是，除非在模板中 | | 继承关系 | Control → ContentControl | FrameworkElement → ContentPresenter | | 核心属性 | Content, ContentTemplate, ContentTemplateSelector | Content, ContentTemplate, ContentTemplateSelector（用于接收来自父控件的值） | 形象比喻 可以把 ContentControl 想象成一个电视盒子： 它内部有信号源（Content）、解码方式（ContentTemplate）。 而 ContentPresenter 就像是电视盒子上的屏幕，它的唯一工作就是把电视盒子处理好的信号显示出来。 没有电视盒子（ContentControl），屏幕（ContentPresenter）就没有信号可显示；没有屏幕（ContentPresenter），电视盒子（ContentControl）处理的信号就无法被人看到。 总结 当你需要一个可以包含任意内容的控件时，使用 ContentControl。 当你为 ContentControl 或其子类（如 Button）编写自定义外观（ControlTemplate）时，使用 ContentPresenter 来指定内容应该在哪里以及如何被呈现。 两者协同工作，ContentControl 管理数据和逻辑，ContentPresenter 负责最终的视觉呈现。"
  },
  "docs/WPF/路由事件.html": {
    "href": "docs/WPF/路由事件.html",
    "title": "WPF 路由事件（Routed Events）核心指南 | CZQDocs",
    "summary": "路由事件概述 WPF 路由事件（Routed Events）核心指南 核心概念：路由事件能在元素树中多个监听器上调用处理程序，而不仅限于事件源。这是 WPF 事件系统与标准 CLR 事件的根本区别。 一、什么是路由事件？ 功能角度：可在元素树多个节点触发处理程序的事件类型 实现角度：由 RoutedEvent 实例支持并向 WPF 事件系统注册的事件 典型场景：Button.Click 事件从按钮冒泡到父容器，父容器可统一处理所有子按钮的点击 <StackPanel Button.Click=\"UnifiedHandler\"> <Button>Yes</Button> <Button>No</Button> <Button>Cancel</Button> </StackPanel> 二、三种路由策略 策略 路径 典型应用 命名约定 冒泡 (Bubble) 源元素 → 根元素 大多数输入/状态事件 直接命名 (Click) 隧道 (Tunnel) 根元素 → 源元素 输入事件的\"预览\"阶段 Preview 前缀 (PreviewMouseDown) 直接 (Direct) 仅源元素 类似 WinForms 的简单事件 无特殊前缀 隧道+冒泡配对：WPF 输入事件通常成对出现（如 PreviewMouseDown + MouseDown），先隧道后冒泡 三、为什么需要路由事件？ 控件组合与封装：允许在 Button 内放 Image 等复杂内容，点击事件仍能正确响应 单一处理点：父容器可统一处理所有子元素事件，无需为每个子元素注册 类处理程序：支持在静态构造函数中注册类级处理程序，优先于实例处理程序执行 样式与模板支持：EventSetter 和 EventTrigger 只能用于路由事件 无反射引用：通过 RoutedEvent 字段标识符，避免运行时反射 四、实现自定义路由事件 // 1. 注册路由事件 public static readonly RoutedEvent TapEvent = EventManager.RegisterRoutedEvent( name: \"Tap\", routingStrategy: RoutingStrategy.Bubble, handlerType: typeof(RoutedEventHandler), ownerType: typeof(CustomButton) ); // 2. CLR 事件包装器 public event RoutedEventHandler Tap { add => AddHandler(TapEvent, value); remove => RemoveHandler(TapEvent, value); } // 3. 触发事件 protected virtual void OnTap() { RaiseEvent(new RoutedEventArgs(TapEvent, this)); } 五、关键机制 1. Handled 机制 RoutedEventArgs.Handled = true 会阻止事件路由继续传播 后续监听器默认不再调用处理程序 例外：通过 AddHandler(event, handler, handledEventsToo: true) 可接收已标记为处理的事件 建议：完成事件处理后应设置 Handled = true，避免意外副作用 2. 类处理程序 注册方式： static CustomButton() { EventManager.RegisterClassHandler( typeof(CustomButton), TapEvent, new RoutedEventHandler(OnTapClassHandler) ); } 特点： 在实例处理程序之前执行 可强制实施实例无法禁止的类行为 常用于控件内部拦截子元素事件 3. 附加事件 语法：<owner type>.<event name> 示例：StackPanel 未实现 Click，但可通过 Button.Click=\"Handler\" 附加处理 <StackPanel Button.Click=\"Button_Click\"> <Button>Click me</Button> </StackPanel> 本质：附加事件也是路由事件，可在任意元素上引发 六、WPF 输入事件特性 隧道+冒泡配对事件处理顺序： PreviewMouseDown 根元素（隧道） PreviewMouseDown 中间元素（隧道） PreviewMouseDown 源元素（隧道） MouseDown 源元素（冒泡） MouseDown 中间元素（冒泡） MouseDown 根元素（冒泡） 关键对象： Source：最初引发事件的对象（始终不变） sender：调用处理程序的对象（随路由变化） 最佳实践：在 Preview 隧道阶段拦截子组件事件，替换为顶层控件事件 七、在样式中的应用 EventSetter <Style TargetType=\"Button\"> <EventSetter Event=\"Click\" Handler=\"ApplyButtonStyle\"/> </Style> EventTrigger <EventTrigger RoutedEvent=\"Mouse.MouseEnter\"> <BeginStoryboard> <Storyboard> <DoubleAnimation Storyboard.TargetProperty=\"Opacity\" To=\"0.5\"/> </Storyboard> </BeginStoryboard> </EventTrigger> 限制：仅适用于路由事件 八、快速决策表 需求 方案 需要事件在元素树传播 使用路由事件 需要父容器统一处理子元素事件 使用冒泡策略 需要拦截子元素事件 使用隧道策略（Preview） 需要样式/动画响应事件 必须是路由事件 需要类级强制行为 注册类处理程序 需要接收已处理的事件 AddHandler(..., handledEventsToo: true) 总结 路由事件是 WPF 事件系统的核心，通过元素树传播机制、Handled 协议和类处理支持，实现了控件组合、事件聚合和灵活响应。掌握路由事件是深入理解 WPF 编程模型的关键。"
  },
  "docs/异常/WPF.html": {
    "href": "docs/异常/WPF.html",
    "title": "| CZQDocs",
    "summary": "关键点一句话： Handler 必须继续抛异常（否则 HTTP 调用链会以为“请求成功”）， 只要 UI 层（或全局）接住它，WPF 就不会崩溃。 下面给你“三选一”的落地做法，按自己口味挑。 方案 A：ViewModel 里就地接住（最常用） [RelayCommand] private async Task LoadLogsAsync() { try { var logs = await _http.GetFromJsonAsync<Log[]>(\"api/logs\"); Logs = new ObservableCollection<Log>(logs); } catch (HttpRequestException ex) // Handler 抛出的异常 { // 友好提示 + 不写日志可再 throw MessageBox.Show(ex.Message, \"连接失败\", MessageBoxButton.OK, MessageBoxImage.Warning); } } 异常在此被吞掉，再也上不了 UI 线程，程序稳如老狗。 方案 B：让异常飞，但给 App.xaml.cs 加全局兜底 App.xaml.cs protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); // 1. UI 线程 DispatcherUnhandledException += (s, args) => { args.Handled = true; // 阻止崩溃 MessageBox.Show(args.Exception.Message, \"错误\", MessageBoxButton.OK, MessageBoxImage.Error); }; // 2. 后台 Task TaskScheduler.UnobservedTaskException += (s, args) => { args.SetObserved(); // 阻止崩溃 MessageBox.Show(args.Exception.InnerException?.Message ?? args.Exception.Message, \"错误\", MessageBoxButton.OK, MessageBoxImage.Warning); }; } 此时 ViewModel 完全不用写 try-catch，用户只会看到统一弹窗，进程依旧存活。 方案 C：又想抛又想不崩溃——在命令层用 AsyncCommand 的异常回调 CommunityToolkit.Mvvm 的 AsyncRelayCommand 支持 onException： LoadLogsCommand = new AsyncRelayCommand(LoadLogsAsync, ex => { MessageBox.Show(ex.Message, \"连接失败\", MessageBoxButton.OK, MessageBoxImage.Warning); return Task.CompletedTask; }); 异常被命令内部捕获并回调，同样不会冒到 Dispatcher。 小结 做法 是否需 try-catch 是否会崩溃 适用场景 ViewModel 就地 catch ✅ ❌ 最常见，可精细提示 全局 Dispatcher & Task 事件 ❌ ❌ 图省事，统一提示 AsyncCommand 异常回调 ❌ ❌ MVVM 洁癖，代码简洁 结论： Handler 继续 throw 没关系，只要在 UI 边界（或全局）把它接住，WPF 就不会崩溃。"
  },
  "index.html": {
    "href": "index.html",
    "title": "个人学习笔记 | CZQDocs",
    "summary": "个人学习笔记 Refer to Markdown for how to write markdown files."
  },
  "软件架构和设计/DevOps.html": {
    "href": "软件架构和设计/DevOps.html",
    "title": "| CZQDocs",
    "summary": "DevOps（Development + Operations）是一组 过程、方法与系统的统称，核心目标是： 让开发（Dev）与运维（Ops）高效协作，通过自动化、持续交付与快速反馈，缩短从需求到上线的周期，同时保证质量与稳定性。 一句话记忆 “代码一提交，几分钟内自动编译、测试、部署到生产，出问题还能快速回滚”——这就是 DevOps 想做到的终极状态。 DevOps 不是工具，而是一套 文化 + 实践 + 工具 的组合拳 文化 开发、测试、运维、安全 共享责任（You build it, you run it）。 小步快跑、频繁交付、允许失败但快速恢复。 实践（CALMS 模型） Culture 文化 Automation 自动化（CI/CD、IaC） Lean 精益（减少浪费、持续改进） Measurement 度量（MTTR、Lead Time、Deployment Frequency） Sharing 共享（知识、工具、复盘） 工具链示例（常见组合） 代码：Git、GitLab、GitHub 构建：Maven、Gradle、npm、Docker CI/CD：Jenkins、GitLab CI、GitHub Actions、Azure DevOps、Argo CD 测试：JUnit、Selenium、Postman、SonarQube 部署：Kubernetes、Helm、Terraform、Ansible 监控：Prometheus、Grafana、ELK、Jaeger 协作：Jira、Trello、Slack、Microsoft Teams 典型流水线（Pipeline）长什么样 开发者 push 代码 ↓ WebHook 触发 CI 服务器 ↓ 自动编译 → 单元测试 → 静态扫描 → 打 Docker 镜像 ↓ 镜像推入仓库（Harbor/ECR/ACR） ↓ CD 触发：自动部署到测试环境 → 接口/UI 自动化测试 ↓ 人工审批（可选） ↓ 自动部署到生产 → 冒烟 → 监控告警 → 自动回滚（若失败） 衡量 DevOps 成熟度的 4 个关键指标（DORA） 指标 优秀值 意义 部署频率 按需（每天多次） 交付能力 变更前置时间 <1 小时 响应速度 失败率 <15 % 质量 故障恢复时间（MTTR） <1 小时 稳定性 DevOps 的延伸 DevSecOps：把安全扫描（SAST/DAST/镜像扫描）嵌入流水线，实现“安全左移”。 GitOps：以 Git 为单一事实来源，Kubernetes 集群自动同步 YAML 变更。 AIOps：用 AI 分析日志/指标，自动定位故障、弹性扩缩容。 快速上手的 5 个步骤 代码放 Git，主干开发 + Pull Request。 用 Jenkins/GitHub Actions 跑通 自动编译 + 单元测试。 把环境做成 Docker 镜像，同一份镜像逐级晋升（测试→预发→生产）。 用 Terraform/Ansible 把基础设施代码化（IaC），不再手工装服务器。 上线 Prometheus + Grafana 做监控告警，失败能自动回滚。 一句话总结 DevOps = “文化”让团队愿意一起快，“实践”告诉团队怎么快，“工具”帮团队把快变成自动化。"
  },
  "软件架构和设计/插件系统.html": {
    "href": "软件架构和设计/插件系统.html",
    "title": "| CZQDocs",
    "summary": "您现在描述的情况触及了现代软件架构中一个非常核心且常见的需求：模块化 (Modularity) 和 按需加载 (On-Demand Loading)。 让我们梳理一下现状和目标： 当前架构 (问题)： 您有多个 WPF 类库（例如 ModuleA.dll, ModuleB.dll, ModuleC.dll），每个代表一个功能模块。 您有一个主 WPF .exe 宿主应用。 宿主应用直接引用了所有这些模块的 .dll 文件。 结果：所有模块在编译时就被“硬编码”进宿主应用。您无法实现： 按功能授权：根据用户的许可证，只启用某些模块。 动态更新：替换或更新单个模块而无需重新部署整个应用。 延迟加载：只在用户需要时才加载某个模块，减少启动时间。 目标架构 (理想)： 宿主应用是轻量级的，只知道如何“发现”和“加载”模块。 功能模块以 .dll 文件的形式存在于一个特定的文件夹（如 Modules/）。 宿主应用在启动时扫描这个文件夹，动态加载 .dll。 宿主应用根据用户的授权信息，决定加载哪些模块。 每个模块可以独立开发、测试、部署和授权。 解决方案：使用插件架构 (Plugin Architecture) 您需要将您的模块从“直接引用的类库”转变为“动态加载的插件”。这可以通过 反射 (Reflection) 和 依赖注入 (DI) 的结合来实现。 核心思想 定义公共契约 (Contracts)：创建一个独立的类库（如 MyApp.Core 或 MyApp.Contracts），其中只包含模块与宿主通信所需的接口和共享模型。 模块实现契约：每个功能模块 (ModuleA, ModuleB) 都引用 Contracts 项目，并实现其中的接口。 宿主发现并加载：宿主应用引用 Contracts 项目，但不直接引用任何 ModuleX.dll。它通过反射从 Modules/ 文件夹加载 .dll，查找实现了特定接口的类型，并创建实例。 集成 DI：在宿主应用的 DI 容器中，为每个加载的模块注册其服务。 详细实现步骤 步骤 1：创建 Contracts 项目 新建一个名为 MyApp.Contracts 的 Class Library 项目。 在其中定义模块与宿主交互的接口。 csharp // 文件: IModule.cs (在 MyApp.Contracts 项目中) /// /// 所有功能模块必须实现的接口。 /// public interface IModule { /// /// 模块的唯一标识符。 /// string Id { get; } /// /// 模块的显示名称。 /// string Name { get; } /// /// 模块的描述。 /// string Description { get; } /// /// 模块的版本。 /// string Version { get; } /// /// 获取此模块提供的菜单项。 /// /// IEnumerable GetMenuItems(); /// /// 此方法由宿主调用，用于注册该模块的服务到 DI 容器。 /// /// The service collection from the host. void RegisterServices(IServiceCollection services); } // 文件: IMenuItem.cs (在 MyApp.Contracts 项目中) /// /// 代表一个菜单项。 /// public interface IMenuItem { string Text { get; } ICommand Command { get; } // 可以添加 Icon, Shortcut 等属性 } 步骤 2：重构功能模块 修改 ModuleA 项目，使其引用 MyApp.Contracts 而不是直接被宿主引用。 csharp // 文件: ModuleA.cs (在 ModuleA 项目中) using MyApp.Contracts; using Microsoft.Extensions.DependencyInjection; public class ModuleA : IModule { public string Id => \"ModuleA\"; public string Name => \"报价管理\"; public string Description => \"处理报价相关的功能。\"; public string Version => \"1.0.0\"; public IEnumerable GetMenuItems() { // 假设您有一个 Command 实现 var command = new RelayCommand(async () => { // 这里可以通过 DI 获取服务 var serviceProvider = ServiceLocator.ServiceProvider; // 或通过其他方式 var viewModel = serviceProvider?.GetService (); var window = new ModuleAWindow { DataContext = viewModel }; window.ShowDialog(); }); return new[] { new MenuItemImpl(\"选取报价表\", command) }; } public void RegisterServices(IServiceCollection services) { // 在这里，您向宿主的 DI 容器注册本模块所需的所有服务 services.AddSingleton<ICadSelectionService, RealCadSelectionService>(); services.AddTransient (); // ... 注册其他服务 } } // 简单的菜单项实现 public class MenuItemImpl : IMenuItem { public string Text { get; } public ICommand Command { get; } public MenuItemImpl(string text, ICommand command) { Text = text; Command = command; } } 步骤 3：重构宿主应用 (WPF .exe) 修改项目引用： 宿主应用 (MyApp.Host) 引用 MyApp.Contracts。 宿主应用 不再直接引用 ModuleA.dll, ModuleB.dll 等。 创建模块加载器： csharp // 文件: ModuleLoader.cs (在宿主应用中) using MyApp.Contracts; using System.Reflection; public class ModuleLoader { private readonly string _modulesPath; public ModuleLoader(string modulesPath = \"Modules\") { _modulesPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, modulesPath); } /// /// 从模块文件夹加载所有实现了 IModule 接口的模块。 /// /// 已加载的模块列表。 public List LoadModules() { var modules = new List (); if (!Directory.Exists(_modulesPath)) { Directory.CreateDirectory(_modulesPath); return modules; } var dllFiles = Directory.GetFiles(_modulesPath, \".dll\"); foreach (var dllFile in dllFiles) { try { // 加载程序集 var assembly = Assembly.LoadFrom(dllFile); // 查找实现了 IModule 接口的公共类型 var moduleTypes = assembly.GetTypes() .Where(t => typeof(IModule).IsAssignableFrom(t) && !t.IsInterface && !t.IsAbstract); foreach (var type in moduleTypes) { // 创建实例 var moduleInstance = (IModule)Activator.CreateInstance(type)!; modules.Add(moduleInstance); } } catch (Exception ex) { // 记录加载失败的模块 Console.WriteLine($\"Failed to load module from {dllFile}: {ex.Message}\"); } } return modules; } } 在宿主应用中集成模块加载和 DI： csharp // 文件: App.xaml.cs (在宿主应用中) using MyApp.Contracts; using Microsoft.Extensions.DependencyInjection; public partial class App : Application { private static ServiceProvider? _serviceProvider; protected override async void OnStartup(StartupEventArgs e) { base.OnStartup(e); var services = new ServiceCollection(); // 1. 注册宿主应用自己的服务 services.AddSingleton<IMainWindow, MainWindow>(); // 2. 加载模块 var moduleLoader = new ModuleLoader(); var allModules = moduleLoader.LoadModules(); // 3. 【关键】根据授权筛选模块 var authorizedModules = FilterModulesByLicense(allModules); // 您需要实现这个方法 // 4. 【关键】让每个授权模块注册自己的服务 foreach (var module in authorizedModules) { module.RegisterServices(services); // 模块将服务添加到宿主的 ServiceCollection } // 5. 构建服务提供者 _serviceProvider = services.BuildServiceProvider(); // 6. 创建主窗口，并将授权的模块列表传递给它（例如通过 ViewModel） var mainWindow = _serviceProvider.GetRequiredService (); var mainViewModel = (MainViewModel)mainWindow.DataContext; mainViewModel.Initialize(authorizedModules); // 让 ViewModel 构建菜单 mainWindow.Show(); } private List FilterModulesByLicense(List allModules) { // TODO: 实现您的授权逻辑 // 例如，读取 license 文件，检查用户是否有权限使用某个模块的 Id // return allModules.Where(m => IsUserAuthorized(m.Id)).ToList(); return allModules; // 暂时返回所有模块 } public static T GetService () where T : class { return _serviceProvider?.GetService () ?? throw new InvalidOperationException($\"Service of type {typeof(T)} not available.\"); } } 步骤 4：部署 编译宿主应用 (MyApp.Host.exe)。 将 ModuleA.dll, ModuleB.dll 等不被直接引用的模块 DLL 文件放入宿主应用目录下的 Modules/ 文件夹中。 运行 MyApp.Host.exe，它将自动发现、加载、根据授权筛选并集成这些模块。 总结 通过这种基于 Contracts + 反射 + DI 的插件架构，您成功实现了： 松耦合：宿主与模块之间通过接口通信。 按需加载：只有被放入 Modules/ 文件夹的 DLL 才会被考虑。 按功能授权：FilterModulesByLicense 方法可以根据任何逻辑（许可证文件、数据库、云服务等）决定启用哪些模块。 独立部署：您可以单独更新 ModuleA.dll 而无需重新编译或部署整个宿主应用。 可扩展性：添加新功能只需开发一个新的模块 DLL 并放入文件夹即可。 这正是大型软件（如 Visual Studio, AutoCAD, Revit）实现插件系统的核心原理。"
  },
  "软件架构和设计/显式依赖项原则.html": {
    "href": "软件架构和设计/显式依赖项原则.html",
    "title": "| CZQDocs",
    "summary": "显式依赖项原则（Explicit Dependencies Principle） “类所需要的所有外部协作对象，都必须通过公开、可观测的方式（通常是构造函数）显式地告诉调用者；禁止在类内部偷偷摸摸地 new、单例、ServiceLocator 等隐式获取。” 只要违反这一点，代码立刻变得难以单元测试、难以替换实现、难以理清依赖关系。下面从 “为什么、长什么样、怎么写、怎么测、常见坑” 五个角度，结合 C# 代码彻底讲透。 一、为什么——隐式依赖的灾难 public class PriceService { private readonly HttpClient _http; // 调用者完全不知道 private readonly ILog _log; // 调用者完全不知道 public PriceService() { _http = new HttpClient(); // 直接 new _log = LogManager.GetLogger<PriceService>(); // 静态单例 } public async Task<decimal> GetPrice(int productId) { _log.Info(\"fetching price\"); var json = await _http.GetStringAsync( $\"http://api.shop.com/prices/{productId}\"); return decimal.Parse(json); } } 问题 测试时必须真的发 HTTP 请求、真的写日志文件——单元测试变集成测试。 想换成 TestServer 或 FakeLogger 做不到，因为创建权在类内部。 阅读 API 时，构造函数没有任何线索，只能“打开源码”才能知道它究竟要啥。 二、长什么样——显式依赖 把依赖全部提到构造函数（或者方法参数，下文再谈），并在接口层面抽象： public interface IPriceGateway { Task<decimal> GetPrice(int productId); } public interface IAppLogger { void Info(string message); } public sealed class PriceService { private readonly IPriceGateway _gateway; private readonly IAppLogger _log; // 所有依赖一目了然 public PriceService(IPriceGateway gateway, IAppLogger log) { _gateway = gateway ?? throw new ArgumentNullException(nameof(gateway)); _log = log ?? throw new ArgumentNullException(nameof(log)); } public async Task<decimal> GetPrice(int productId) { _log.Info($\"Fetching price for {productProductId}\"); return await _gateway.GetPrice(productId); } } 好处 调用者（或 DI 容器）一眼看清：要给我一个 IPriceGateway 和 IAppLogger。 单元测试可以扔 FakePriceGateway、FakeLogger 进去，毫秒级测试。 符合 SOLID 之 DIP（依赖倒置）：高层 PriceService 不依赖低层 HttpClient/Log4Net，而是依赖抽象。 三、怎么写——三种合法注入方式 构造函数注入（最推荐，生命周期与类实例一致） public PriceService(IPriceGateway g, IAppLogger l) { … } 方法注入（依赖只在单个方法用到，或者需要运行时动态传） public async Task<decimal> GetPrice( int productId, CancellationToken ct = default) // 框架传入 属性/字段赋值（仅限“可选依赖”，必须有默认值保护） public IAppLogger Logger { get; set; } = NullLogger.Instance; 四、怎么测——单元测试示范 [Fact] public void Should_return_fake_price() { // Arrange var fakeGateway = new Mock<IPriceGateway>(); fakeGateway.Setup(x => x.GetPrice(1)).ReturnsAsync(99.9m); var fakeLog = new Mock<IAppLogger>(); var svc = new PriceService(fakeGateway.Object, fakeLog.Object); // Act var price = svc.GetPrice(1).GetAwaiter().GetResult(); // Assert Assert.Equal(99.9m, price); } 全程无 HTTP、无日志文件、100 ms 内跑完。 五、常见坑与问答 “构造函数参数太多” → 把相关依赖打包成 IOptions<PriceServiceOptions> 或门面接口，再或者拆分职责。 “我用的是 .NET 6 最小 API，怎么显式？” → 一样构造函数注入： builder.Services.AddScoped<IPriceGateway, HttpPriceGateway>(); builder.Services.AddScoped<IAppLogger, SerilogAdapter>(); app.MapGet(\"/price/{id}\", (int id, PriceService svc) => svc.GetPrice(id)); “静态日志很爽，为什么不行？” → 静态 = 隐式 = 全局状态，测试之间互相污染，且无法替换为 FakeLogger。 “ServiceLocator 好像也能解耦？” → var log = ServiceLocator.Resolve<ILogger>() 依旧把依赖藏进方法体，违反“显式”。 真正可观测的依赖必须出现在类型公开契约里（构造/方法参数）。 六、一句话总结 在 C# 中落地“显式依赖项原则”就是： “能放进构造函数，就别藏到方法体；能抽象成接口，就别直接 new 实现；能让调用者一眼看懂，就别让他翻源码。”"
  },
  "软件架构和设计/设计模式/建造者.html": {
    "href": "软件架构和设计/设计模式/建造者.html",
    "title": "| CZQDocs",
    "summary": "下面给出一份完整、可编译、直接跑的示例，把： 不可变 record（产品） 建造者（Builder） 指挥者（Director，可选） 调用端 全部串在一起，演示**“建造者设计模式”**在现代 C# 中的落地。 ✅ 完整代码（.NET 6+ 控制台项目） using System; using System.Net; #region 1. 产品：不可变 record public enum Code { Ok, Error } public interface IZmMessage { } /// <summary> /// 产品（Product）——不可变数据 /// </summary> public record ZmMessage( Code Code, string Message, HttpStatusCode StatusCode ) : IZmMessage; #endregion #region 2. 建造者（Builder） public sealed class ZmMessageBuilder { private Code _code = Code.Ok; private string _message = string.Empty; private HttpStatusCode _statusCode = HttpStatusCode.OK; public ZmMessageBuilder WithCode(Code code) { _code = code; return this; } public ZmMessageBuilder WithMessage(string message) { _message = message ?? throw new ArgumentNullException(nameof(message)); return this; } public ZmMessageBuilder WithStatusCode(HttpStatusCode statusCode) { _statusCode = statusCode; return this; } /// <summary> /// 组装出最终不可变对象 /// </summary> public ZmMessage Build() => new(_code, _message, _statusCode); // 隐式转换：Builder 直接当成 ZmMessage 用 public static implicit operator ZmMessage(ZmMessageBuilder b) => b.Build(); } #endregion #region 3. 指挥者（Director）——封装常用“建造流程” public static class ZmMessageDirector { public static ZmMessage BadRequest(string message) => new ZmMessageBuilder() .WithCode(Code.Error) .WithMessage(message) .WithStatusCode(HttpStatusCode.BadRequest) .Build(); public static ZmMessage Ok(string message) => new ZmMessageBuilder() .WithCode(Code.Ok) .WithMessage(message) .WithStatusCode(HttpStatusCode.OK) .Build(); } #endregion #region 4. 客户端调用 internal class Program { private static void Main() { // 4.1 完全自定义建造 var msg1 = new ZmMessageBuilder() .WithCode(Code.Error) .WithMessage(\"Invalid token\") .WithStatusCode(HttpStatusCode.Unauthorized) .Build(); Console.WriteLine($\"【自定义】{msg1}\"); // 4.2 隐式转换 ZmMessage msg2 = new ZmMessageBuilder() .WithMessage(\"Server error\") .WithStatusCode(HttpStatusCode.InternalServerError); Console.WriteLine($\"【隐式转换】{msg2}\"); // 4.3 使用 Director 快速拿“模板” var msg3 = ZmMessageDirector.BadRequest(\"Id is required\"); Console.WriteLine($\"【Director】{msg3}\"); } } #endregion ✅ 运行结果示例 【自定义】ZmMessage { Code = Error, Message = Invalid token, StatusCode = Unauthorized } 【隐式转换】ZmMessage { Code = Ok, Message = Server error, StatusCode = InternalServerError } 【Director】ZmMessage { Code = Error, Message = Id is required, StatusCode = BadRequest } ✅ 模式角色对照表 角色 代码中的体现 产品 ZmMessage（不可变 record） 建造者 ZmMessageBuilder 指挥者 ZmMessageDirector（可选） 客户端 Program.Main() 这样，**“复杂对象的创建过程”**被完整地封装在 Builder 与 Director 中，客户端代码始终保持简洁、可读、易扩展。"
  },
  "面试/1.html": {
    "href": "面试/1.html",
    "title": "| CZQDocs",
    "summary": "是的，这些新关键字和特性在面试中确实很重要，尤其是在中高级 C# 开发岗位的面试中，它们常被用作： ✅ 技术深度的“试金石” 面试官通过这些问题判断你是否： 持续学习：是否关注语言演进，还是停留在旧语法。 实战能力：是否真正用过这些特性解决实际问题。 底层理解：是否知道编译器背后做了什么（比如 field 是怎么生成的？主构造函数和 record 有什么区别？）。 ✅ 高频面试问题举例 特性 面试问题示例 init “init 和 set 有什么区别？为什么不能和 set 同时用？” record “record 是值类型还是引用类型？它是怎么做值比较的？” 主构造函数（C# 12） “普通类和 record 的主构造函数有什么区别？参数作用域一样吗？” field（C# 13） “field 是字段吗？它能在 get 外面用吗？编译器怎么实现它的？” required（C# 11） “required 和构造函数参数必填有什么区别？它怎么和 JSON 反序列化配合使用？” file 类型（C# 11） “file 修饰符解决了什么问题？你在什么场景下用过？” ✅ 实战场景题也爱考 “你有一个 DTO 类，字段很多，构造函数写起来很冗长，怎么优化？” → 期望你答：用 主构造函数 或 record 简化。 “你有一个 MVVM 的属性，通知逻辑很重复，怎么简化？” → 期望你答：用 field 关键字 + PropertyChanged.Fody 或 CommunityToolkit.Mvvm。 ✅ 总结一句话 这些新特性不是“加分项”，而是“筛人项”。 如果你不知道，面试官可能会认为你不关注技术演进，直接降档。 ✅ 建议准备方式 做法 说明 写个小项目 用 C# 13 写个控制台或 WebAPI，强制用上 field、主构造函数、required 等。 准备 1 个实战例子 比如：“我用 field 把 50 个 MVVM 属性压缩成 10 行代码，性能还提升了。” 背 3 个底层原理 比如：field 是编译器生成的 private field，名字是 <Name>k__BackingField；record 的 Equals 是用 EqualityContract 做类型区分的。 需要我帮你整理一份**“面试高频新特性问答速记表”**吗？"
  }
}