
## EF Core 单 `Include` 拆分查询原理

> 一条 `Blog ↔ 10 000 Posts` 的完整拆解

---

## 1. 不拆分时的“笛卡尔爆炸”

```sql
-- 单条 SQL
SELECT b.BlogId, b.Name, b.Url,           -- 主表 3 列
       p.PostId, p.Title, p.Content       -- 子表 3 列
FROM Blogs AS b
LEFT JOIN Posts AS p ON b.BlogId = p.BlogId
WHERE b.BlogId = 1;
```

结果：1 行 Blog 重复 10 000 次 → **网络包膨胀、内存浪费**。

---

## 2. 启用拆分查询

```csharp
var blog = await ctx.Blogs
                    .Include(b => b.Posts)
                    .AsSplitQuery()          // 关键
                    .FirstOrDefaultAsync(b => b.BlogId == 1);
```

EF 在同一事务里连续发两条 SQL：

### ① 主表
```sql
SELECT b.BlogId, b.Name, b.Url
FROM Blogs AS b
WHERE b.BlogId = 1;
-- 返回 1 行
```

### ② 子表
```sql
SELECT p.PostId, p.BlogId, p.Title, p.Content
FROM Posts AS p
WHERE p.BlogId = 1;
-- 返回 10 000 行
```

---

## 3. 内存拼装

1. 第 ① 步：Blog 实体进入 **Identity Map**。  
2. 第 ② 步：按外键 `BlogId=1` 把 10 000 个 `Post` 填到 `blog.Posts`。

```csharp
blog.Posts = new List<Post> { 10_000 个实体 };
```

导航属性完整，主表列**仅传输 1 次**。

---

## 4. 收益估算

| 模式   | 传输字节                              | 节省     |
| ------ | ------------------------------------- | -------- |
| 单 SQL | 200×10 000 + 100×10 000 ≈ **2.86 MB** | —        |
| 拆分   | 200×1 + 100×10 000 ≈ **0.98 MB**      | **66 %** |

---

## 5. 一句话总结

哪怕只有一个 `Include`，`.AsSplitQuery()` 也会生成“主表 1 条 SQL + 子表 1 条 SQL”，彻底避免主表列重复，显著减少冗余数据传输。

下面把 **EF Core 拆分查询（AsSplitQuery）** 的两条 SQL 从“发请求”到“拼对象”的完整执行逻辑拆开讲一遍；每一步都对应源码级行为，一眼就能明白“为什么能既快又无冗余”。

---

### 0. 前提代码
```csharp
var blogs = ctx.Blogs
               .Include(b => b.Posts)
               .OrderBy(b => b.BlogId)   //可有可无，这里方便对照 SQL
               .AsSplitQuery()           //关键开关
               .ToList();
```
要求：把 **所有 Blogs 及其 Posts** 一次性拿回来，内存里要是**完整的对象图**（每个 Blog.Posts 列表已填充）。

---

### 1. 第一步：只查主表（Blogs）
**生成的 SQL**
```sql
SELECT [b].[BlogId], [b].[Url], [b].[Rating] ...
FROM [Blogs] AS [b]
ORDER BY [b].[BlogId];          --排序是为了后续 Merge 方便
```

**执行细节**  
① DbCommand 发出去 → 数据库返回 **N 行 Blog 原始记录**。  
② EF Core 逐行 Materialize：  
   - new Blog() 实例  
   - 填充标量字段  
   - **跟踪**（Attach）到状态管理器（ChangeTracker）  
   - 把 BlogId 值按序放进一个 **List\<TKey\>**（后面要用）。  
③ 此时 **Posts 导航属性是 null/空集合**，尚未填充。

---

### 2. 第二步：根据刚拿到的 BlogId 列表，再查子表（Posts）
**生成的 SQL**（IN 列表长度 = 第一步返回的 Blog 数）
```sql
SELECT [p].[PostId], [p].[BlogId], [p].[Title] ...
FROM [Posts] AS [p]
WHERE [p].[BlogId] IN (1,2,3,...,N)   --第一步收集的 Id 列表
ORDER BY [p].[BlogId];                --同样为了 Merge
```

**执行细节**  
① 第二次 DbCommand 发出去 → 数据库返回 **M 行 Post 记录**。  
② 逐行 Materialize：  
   - new Post() 实例  
   - 填充标量字段  
   - **立即根据外键值 BlogId 做 Lookup**，在 ChangeTracker 里找到 **对应的 Blog 实体**（状态管理器已有，O(1) 查找）。  
   - 把当前 Post Add 到该 Blog.Posts 集合里（ICollection\<Post\>）。  
③ 所有 Posts 处理完后，**每个 Blog.Posts 导航属性已完整**，内存对象图 = 跟单条 LEFT JOIN 查询完全等价。

---

### 3. 结果返回
ToList() 得到 `List<Blog>`  
- 主表字段 **0 冗余**（只在第一步传了 1 次）。  
- 子表数据 **无重复拉主表字段**。  
- 导航属性 **已完全填充**，可立即使用 `blog.Posts.Count` 等操作，不会再触发懒加载。

---

### 4. 关键实现要点（源码级）
| 要点                     | 作用                                                                                                                 |
| ------------------------ | -------------------------------------------------------------------------------------------------------------------- |
| **Key List 缓存**        | 第一步把主键按序存进 `List<TKey>`，第二步直接拼成 SQL 的 IN 子句。                                                   |
| **ChangeTracker Lookup** | 第二步不再 JOIN，而是利用 **同一 DbContext 状态管理器**做内存关联，保证导航属性指向同一实例（Identity Resolution）。 |
| **排序一致性**           | 两条 SQL 都按 BlogId 排序，EF 内部用 **OrderedMerge** 算法，可以流式处理，避免二次排序。                             |
| **拆分阈值**             | IN 列表过长（> 2000 项）时 EF 会自动拆成多个批次，或切换到临时表方案，防止 SQL 语句爆炸。                            |

---

### 5. 时序图（一眼看懂）
```
┌-------------┐
│  应用程序   │
└------┬------┘
       │ 1. ToList()
       ▼
┌-------------┐
│ EF Core 编译│───生成 2 个 CommandCache 条目
└------┬------┘
       │ 2. 执行 Command1
       ▼
┌-------------┐
│  数据库      │───返回 Blogs 结果集
└------┬------┘
       │ 3. Materialize + 跟踪 + 收集 Id
       ▼
┌-------------┐
│ EF Core      │───把 Id 列表拼成 IN ()
└------┬------┘
       │ 4. 执行 Command2
       ▼
┌-------------┐
│  数据库      │───返回 Posts 结果集
└------┬------┘
       │ 5. Materialize + Lookup + 填充导航属性
       ▼
┌-------------┐
│  应用程序   │◀──List<Blog> 已完整
└-------------┘
```

---

### 6. 一句话总结
拆分查询 = **用两次轻量级单表往返**  
1. 先拿主表并跟踪对象；  
2. 再用 IN 拿子表，靠内存状态管理器 **“贴”回导航属性**；  
既消灭了 JOIN 冗余，又保证对象图 100 % 完整。