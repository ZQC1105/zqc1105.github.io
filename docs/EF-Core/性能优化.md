# `AutoDetectChangesEnabled` 和 `LazyLoadingEnabled` 的作用详解

## ? `AutoDetectChangesEnabled = false`

### 作用原理

```csharp
// 默认情况下（AutoDetectChangesEnabled = true）
var order = context.Orders.Find(orderId);
order.Status = OrderStatus.Shipped;  // EF Core 会自动检测这个变化
order.Customer.Name = "New Name";    // 导航属性的变化也会被自动检测

// 调用 SaveChanges 时，EF Core 知道哪些实体需要更新
await context.SaveChangesAsync();  // 自动更新 order 和 customer

// --------------------------------------------------------------------

// 关闭后（AutoDetectChangesEnabled = false）
var order = context.Orders.Find(orderId);
order.Status = OrderStatus.Shipped;  // EF Core 不知道这个变化！

// 必须手动通知 EF Core
context.ChangeTracker.DetectChanges();  // 显式检测变化

// 或者使用 Entry API
context.Entry(order).Property(o => o.Status).IsModified = true;

await context.SaveChangesAsync();  // 现在知道要更新了
```

### 性能对比示例

```csharp
public class PerformanceTest
{
    // 批量更新 - 开启自动检测（性能差）
    public async Task UpdateOrdersSlow(List<Guid> orderIds)
    {
        var orders = await _context.Orders
            .Where(o => orderIds.Contains(o.Id))
            .ToListAsync();

        foreach (var order in orders)
        {
            order.Status = OrderStatus.Completed;  // 每次赋值都会触发检测
            order.CompletedAt = DateTime.UtcNow;   // 再次触发检测
        }

        // SaveChanges 内部会再次检测所有变化
        await _context.SaveChangesAsync();  // 性能瓶颈！
    }

    // 批量更新 - 关闭自动检测（性能好）
    public async Task UpdateOrdersFast(List<Guid> orderIds)
    {
        // 先关闭自动检测
        _context.ChangeTracker.AutoDetectChangesEnabled = false;

        try
        {
            var orders = await _context.Orders
                .Where(o => orderIds.Contains(o.Id))
                .ToListAsync();

            // 批量修改 - 不会触发检测
            foreach (var order in orders)
            {
                order.Status = OrderStatus.Completed;
                order.CompletedAt = DateTime.UtcNow;
            }

            // 手动检测一次所有变化
            _context.ChangeTracker.DetectChanges();

            await _context.SaveChangesAsync();  // 性能提升！
        }
        finally
        {
            _context.ChangeTracker.AutoDetectChangesEnabled = true;
        }
    }

    // 更优的批量更新方案
    public async Task UpdateOrdersOptimized(List<Guid> orderIds)
    {
        // 使用批量更新（EF Core 7+）
        await _context.Orders
            .Where(o => orderIds.Contains(o.Id))
            .ExecuteUpdateAsync(setters =>
                setters.SetProperty(o => o.Status, OrderStatus.Completed)
                       .SetProperty(o => o.CompletedAt, DateTime.UtcNow));
    }
}
```

### 何时需要手动调用 DetectChanges

```csharp
public class OrderService
{
    private readonly ApplicationDbContext _context;

    public OrderService(ApplicationDbContext context)
    {
        _context = context;
        _context.ChangeTracker.AutoDetectChangesEnabled = false;
    }

    public async Task UpdateOrder(OrderUpdateDto dto)
    {
        // 场景1：直接修改实体属性
        var order = await _context.Orders.FindAsync(dto.OrderId);
        order.UpdateFromDto(dto);  // 修改了多个属性

        // 必须手动检测
        _context.ChangeTracker.DetectChanges();
        // 或者
        _context.Entry(order).State = EntityState.Modified;

        await _context.SaveChangesAsync();
    }

    public async Task AddOrderItem(Guid orderId, OrderItemDto itemDto)
    {
        // 场景2：修改导航集合
        var order = await _context.Orders
            .Include(o => o.OrderItems)
            .FirstOrDefaultAsync(o => o.Id == orderId);

        var orderItem = new OrderItem
        {
            ProductId = itemDto.ProductId,
            Quantity = itemDto.Quantity
        };

        order.OrderItems.Add(orderItem);  // 添加导航实体

        // 必须手动检测（因为 AutoDetectChangesEnabled = false）
        _context.ChangeTracker.DetectChanges();

        await _context.SaveChangesAsync();
    }

    public async Task ComplexBusinessOperation()
    {
        // 场景3：复杂业务操作
        var order = await GetOrderWithDetails();

        // 一系列业务操作
        order.ApplyDiscount();
        order.UpdateShipping();
        order.AddAuditLog();

        // 在 SaveChanges 前检测一次
        _context.ChangeTracker.DetectChanges();
        await _context.SaveChangesAsync();
    }
}
```

## ? `LazyLoadingEnabled = false`

### 延迟加载的问题

```csharp
// 启用延迟加载（LazyLoadingEnabled = true）
public async Task<OrderDto> GetOrderDetails(Guid orderId)
{
    var order = await _context.Orders.FindAsync(orderId);

    // N+1 查询问题！
    var items = order.OrderItems.ToList();  // 触发第2次查询
    var customer = order.Customer;          // 触发第3次查询
    var address = customer.Address;         // 触发第4次查询

    // 循环中的延迟加载更糟
    foreach (var item in order.OrderItems)
    {
        var product = item.Product;         // 每个item都触发查询！
    }

    return MapToDto(order);
}

// 关闭延迟加载（LazyLoadingEnabled = false）
public async Task<OrderDto> GetOrderDetailsOptimized(Guid orderId)
{
    // 必须显式 Include 需要的导航属性
    var order = await _context.Orders
        .Include(o => o.OrderItems)
            .ThenInclude(i => i.Product)    // 预先加载
        .Include(o => o.Customer)
            .ThenInclude(c => c.Address)
        .FirstOrDefaultAsync(o => o.Id == orderId);

    // 所有数据已加载，不会触发额外查询

    return MapToDto(order);
}
```

### 显式加载的替代方案

```csharp
public class OrderService
{
    public async Task<OrderDto> GetOrderWithOptions(Guid orderId, bool includeItems = false)
    {
        var query = _context.Orders.AsQueryable();

        // 根据需要包含导航属性
        if (includeItems)
        {
            query = query.Include(o => o.OrderItems);
        }

        var order = await query.FirstOrDefaultAsync(o => o.Id == orderId);

        // 后续需要时显式加载
        if (order != null && !includeItems && needItemsLater)
        {
            await _context.Entry(order)
                .Collection(o => o.OrderItems)
                .LoadAsync();  // 显式加载
        }

        return MapToDto(order);
    }

    // 使用投影避免加载整个实体
    public async Task<OrderSummaryDto> GetOrderSummary(Guid orderId)
    {
        return await _context.Orders
            .Where(o => o.Id == orderId)
            .Select(o => new OrderSummaryDto
            {
                Id = o.Id,
                OrderDate = o.CreatedAt,
                TotalAmount = o.TotalAmount,
                CustomerName = o.Customer.Name,  // 自动 join，不会加载整个 Customer
                ItemCount = o.OrderItems.Count   // 自动 count，不会加载所有 OrderItems
            })
            .FirstOrDefaultAsync();
    }
}
```

## ? 性能对比数据

### 测试场景：加载 100 个订单及其明细

```csharp
public class PerformanceComparison
{
    // 方式1：延迟加载（最慢）
    // 查询次数: 1 + 100 + (100 * N) 次
    public async Task<List<Order>> GetOrdersWithLazyLoading()
    {
        var orders = await _context.Orders
            .Take(100)
            .ToListAsync();

        foreach (var order in orders)
        {
            // 触发延迟加载
            var items = order.OrderItems.ToList();  // 每个order单独查询

            foreach (var item in items)
            {
                var product = item.Product;  // 每个item单独查询
            }
        }

        return orders;  // 总计: 1 + 100 + (100 * N) 次查询
    }

    // 方式2：预先加载（较快）
    // 查询次数: 1 次（大查询）
    public async Task<List<Order>> GetOrdersWithEagerLoading()
    {
        return await _context.Orders
            .Include(o => o.OrderItems)
                .ThenInclude(i => i.Product)
            .Take(100)
            .ToListAsync();  // 1次查询，返回所有数据
    }

    // 方式3：投影查询（最快）
    // 查询次数: 1 次（仅返回需要的数据）
    public async Task<List<OrderDto>> GetOrdersWithProjection()
    {
        return await _context.Orders
            .Take(100)
            .Select(o => new OrderDto
            {
                Id = o.Id,
                OrderDate = o.CreatedAt,
                Total = o.TotalAmount,
                Items = o.OrderItems.Select(i => new OrderItemDto
                {
                    ProductName = i.Product.Name,
                    Quantity = i.Quantity,
                    Price = i.Price
                }).ToList()
            })
            .ToListAsync();  // 1次查询，只返回DTO需要的数据
    }
}
```

## ? 最佳实践配置

### 推荐配置

```csharp
public partial class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
        // ============ 性能优化三件套 ============

        // 1. 关闭查询跟踪（读多写少场景）
        ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;

        // 2. 关闭自动变化检测（需要手动调用 DetectChanges）
        ChangeTracker.AutoDetectChangesEnabled = false;

        // 3. 关闭延迟加载（强制使用显式加载）
        ChangeTracker.LazyLoadingEnabled = false;

        // ============ 为什么这样配置？ ============
        // 1. 避免意外的 N+1 查询
        // 2. 提高批量操作性能
        // 3. 使数据加载行为更明确
    }

    // 重写 SaveChanges 确保变化被检测
    public override int SaveChanges()
    {
        ChangeTracker.DetectChanges();  // 手动检测
        return base.SaveChanges();
    }

    public override async Task<int> SaveChangesAsync(
        CancellationToken cancellationToken = default)
    {
        ChangeTracker.DetectChanges();  // 手动检测
        return await base.SaveChangesAsync(cancellationToken);
    }
}
```

### 使用示例

```csharp
public class OrderService
{
    private readonly ApplicationDbContext _context;

    public OrderService(ApplicationDbContext context)
    {
        _context = context;
    }

    // 只读查询 - 使用 NoTracking
    public async Task<List<OrderDto>> GetOrdersForReport()
    {
        // 临时启用 NoTracking（如果全局不是 NoTracking）
        _context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;

        try
        {
            return await _context.Orders
                .Include(o => o.Customer)
                .Select(o => MapToDto(o))
                .ToListAsync();
        }
        finally
        {
            _context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.TrackAll;
        }
    }

    // 更新操作 - 需要跟踪
    public async Task UpdateOrderStatus(Guid orderId, OrderStatus status)
    {
        // 使用 AsTracking 确保跟踪
        var order = await _context.Orders
            .AsTracking()
            .FirstOrDefaultAsync(o => o.Id == orderId);

        if (order != null)
        {
            order.Status = status;
            // 不需要手动调用 DetectChanges，因为 SaveChangesAsync 中会调用
            await _context.SaveChangesAsync();
        }
    }

    // 复杂更新 - 多个实体
    public async Task CompleteOrder(Guid orderId)
    {
        var order = await _context.Orders
            .AsTracking()
            .Include(o => o.OrderItems)
            .Include(o => o.Customer)
            .FirstOrDefaultAsync(o => o.Id == orderId);

        // 业务逻辑
        order.Complete();
        order.Customer.IncrementOrderCount();

        // 手动添加审计日志
        var auditLog = new AuditLog
        {
            OrderId = orderId,
            Action = "OrderCompleted"
        };
        _context.AuditLogs.Add(auditLog);

        // SaveChangesAsync 会调用 DetectChanges
        await _context.SaveChangesAsync();
    }
}
```

## ? 常见问题及解决方案

### 问题 1：忘记调用 DetectChanges

```csharp
// 错误：修改后忘记检测变化
public async Task UpdateOrderName(Guid orderId, string newName)
{
    var order = await _context.Orders.FindAsync(orderId);
    order.Name = newName;

    // 忘记调用 DetectChanges 或设置 IsModified
    await _context.SaveChangesAsync();  // 不会保存修改！
}

// 解决方案1：使用 Entry API
public async Task UpdateOrderNameFixed(Guid orderId, string newName)
{
    var order = await _context.Orders.FindAsync(orderId);
    order.Name = newName;

    // 明确标记属性已修改
    _context.Entry(order).Property(o => o.Name).IsModified = true;

    await _context.SaveChangesAsync();  // 现在会保存
}

// 解决方案2：确保 SaveChanges 中调用 DetectChanges
public override async Task<int> SaveChangesAsync(
    CancellationToken cancellationToken = default)
{
    // 在基类方法中确保调用
    if (!ChangeTracker.AutoDetectChangesEnabled)
    {
        ChangeTracker.DetectChanges();
    }

    return await base.SaveChangesAsync(cancellationToken);
}
```

### 问题 2：导航属性为 null

```csharp
// 错误：尝试访问未加载的导航属性
public async Task<string> GetCustomerEmail(Guid orderId)
{
    var order = await _context.Orders.FindAsync(orderId);

    // LazyLoadingEnabled = false，所以 Customer 为 null
    return order.Customer.Email;  // NullReferenceException!
}

// 解决方案：显式加载
public async Task<string> GetCustomerEmailFixed(Guid orderId)
{
    var order = await _context.Orders.FindAsync(orderId);

    // 显式加载 Customer
    await _context.Entry(order)
        .Reference(o => o.Customer)
        .LoadAsync();

    return order.Customer.Email;  // 现在可以访问
}

// 更好的方案：使用 Include
public async Task<string> GetCustomerEmailBest(Guid orderId)
{
    var order = await _context.Orders
        .Include(o => o.Customer)
        .FirstOrDefaultAsync(o => o.Id == orderId);

    return order?.Customer?.Email;
}
```

## ? 总结

### `AutoDetectChangesEnabled = false` 的作用：

1. **提高性能**：避免每次属性修改都触发变化检测
2. **减少开销**：批量操作时性能提升明显
3. **需要手动管理**：必须显式调用 `DetectChanges()` 或使用 `Entry().IsModified`

### `LazyLoadingEnabled = false` 的作用：

1. **避免 N+1 查询**：强制开发者思考数据加载策略
2. **查询可预测**：明确知道会发生多少次查询
3. **鼓励最佳实践**：使用 Include、投影查询、显式加载

### 适用场景：

| 配置                                 | 推荐场景               | 不推荐场景          |
| ------------------------------------ | ---------------------- | ------------------- |
| **AutoDetectChangesEnabled = false** | 批量操作、性能敏感应用 | 简单 CRUD、新手项目 |
| **LazyLoadingEnabled = false**       | 所有生产环境           | 快速原型、演示项目  |

### 黄金法则：

1. **生产环境永远关闭延迟加载**
2. **复杂应用考虑关闭自动变化检测**
3. **使用投影查询（Select）替代 Include**
4. **批量操作使用 ExecuteUpdate/ExecuteDelete**
5. **始终监控查询性能**
