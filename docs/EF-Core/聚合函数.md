EF Core 对聚合函数有**全面的支持**，可以直接在 LINQ 查询中使用，这些函数会被翻译成相应的 SQL 聚合函数在数据库端执行。

## ? 主要支持的聚合函数

| 聚合函数      | LINQ 方法     | 对应 SQL       | 说明         |
| ------------- | ------------- | -------------- | ------------ |
| **计数**      | `Count()`     | `COUNT(*)`     | 统计记录数   |
|               | `LongCount()` | `COUNT_BIG(*)` | 大数据集计数 |
| **求和**      | `Sum()`       | `SUM()`        | 数值列求和   |
| **平均**      | `Average()`   | `AVG()`        | 计算平均值   |
| **最大/最小** | `Max()`       | `MAX()`        | 获取最大值   |
|               | `Min()`       | `MIN()`        | 获取最小值   |
| **是否存在**  | `Any()`       | `EXISTS`       | 判断是否存在 |
|               | `All()`       | 复杂 CASE 语句 | 是否全部满足 |

## ? 基本用法示例

### 1. **简单聚合查询**

```csharp
// 统计文章总数
var totalPosts = await context.Posts.CountAsync();

// 计算阅读量总和
var totalViews = await context.Posts.SumAsync(p => p.ViewCount);

// 获取平均阅读量
var averageViews = await context.Posts.AverageAsync(p => p.ViewCount);

// 获取最早和最晚发布日期
var oldestPost = await context.Posts.MinAsync(p => p.PublishDate);
var newestPost = await context.Posts.MaxAsync(p => p.PublishDate);
```

### 2. **带条件的聚合**

```csharp
// 统计已发布的文章数量
var publishedCount = await context.Posts
    .Where(p => p.IsPublished)
    .CountAsync();

// 计算特定分类的文章总阅读量
var categoryTotalViews = await context.Posts
    .Where(p => p.CategoryId == 1)
    .SumAsync(p => p.ViewCount);
```

## ? 分组聚合（GROUP BY）

这是聚合函数最强大的应用场景：

### 基础分组统计

```csharp
// 按博客统计文章数量
var postsByBlog = await context.Posts
    .GroupBy(p => p.BlogId)
    .Select(g => new
    {
        BlogId = g.Key,
        PostCount = g.Count(),
        TotalViews = g.Sum(p => p.ViewCount),
        AverageViews = g.Average(p => p.ViewCount),
        MaxViews = g.Max(p => p.ViewCount)
    })
    .ToListAsync();
```

### 多字段分组

```csharp
// 按年份和月份分组统计
var monthlyStats = await context.Posts
    .GroupBy(p => new
    {
        Year = p.PublishDate.Year,
        Month = p.PublishDate.Month
    })
    .Select(g => new
    {
        g.Key.Year,
        g.Key.Month,
        PostCount = g.Count(),
        TotalViews = g.Sum(p => p.ViewCount)
    })
    .OrderBy(s => s.Year)
    .ThenBy(s => s.Month)
    .ToListAsync();
```

## ? 高级聚合场景

### 1. **组合多个聚合**

```csharp
var blogStats = await context.Blogs
    .Select(b => new
    {
        Blog = b,
        PostCount = b.Posts.Count(),
        PublishedCount = b.Posts.Count(p => p.IsPublished),
        TotalViews = b.Posts.Sum(p => (int?)p.ViewCount) ?? 0, // 处理null
        AverageViews = b.Posts.Average(p => (double?)p.ViewCount) ?? 0
    })
    .Where(s => s.PostCount > 0)  // 只统计有文章的博客
    .ToListAsync();
```

### 2. **在 Select 子句中直接聚合**

```csharp
var blogsWithStats = await context.Blogs
    .Select(b => new BlogDto
    {
        Id = b.Id,
        Name = b.Name,
        LatestPostDate = b.Posts.Max(p => p.PublishDate),
        TotalPosts = b.Posts.Count(),
        MostPopularPostViews = b.Posts.Max(p => p.ViewCount)
    })
    .ToListAsync();
```

## ?? 重要注意事项

### 1. **处理 NULL 值**

```csharp
// ? 可能抛出异常（如果所有 ViewCount 都为 null）
var avg = context.Posts.Average(p => p.ViewCount);

// ? 安全写法：使用可空类型转换
var safeAvg = context.Posts.Average(p => (double?)p.ViewCount) ?? 0;
var safeSum = context.Posts.Sum(p => (int?)p.ViewCount) ?? 0;
```

### 2. **性能优化建议**

```csharp
// ? 低效：客户端评估
var allPosts = context.Posts.ToList();
var count = allPosts.Count();  // 在内存中计数

// ? 高效：数据库执行
var count = await context.Posts.CountAsync();  // SQL: SELECT COUNT(*)
```

### 3. **异步方法的使用**

```csharp
// 同步（不推荐在 Web 应用中）
var count = context.Posts.Count();

// 异步（推荐）
var count = await context.Posts.CountAsync();
```

## ? 特殊聚合场景

### 1. **条件计数（Count with condition）**

```csharp
// 方法1：使用 Count 重载
var popularCount = context.Posts.Count(p => p.ViewCount > 1000);

// 方法2：使用 Sum 模拟条件计数
var conditionalCount = context.Posts
    .Sum(p => p.ViewCount > 1000 ? 1 : 0);
```

### 2. **分位数/百分位数（EF Core 8+）**

```csharp
// 获取中位数（50%分位数）
var medianViews = await context.Posts
    .OrderBy(p => p.ViewCount)
    .Skip(context.Posts.Count() / 2)
    .Take(1)
    .Select(p => p.ViewCount)
    .FirstOrDefaultAsync();
```

### 3. **字符串聚合（STRING_AGG）**

```csharp
// SQL Server 的 STRING_AGG
var allTags = await context.Posts
    .Where(p => p.BlogId == 1)
    .Select(p => p.Tags)
    .AsEnumerable()  // 切换到客户端评估
    .Aggregate((current, next) => current + ", " + next);
```

## ? 实际应用示例：数据报表

```csharp
public async Task<BlogReport> GenerateBlogReport(int blogId)
{
    return await context.Blogs
        .Where(b => b.Id == blogId)
        .Select(b => new BlogReport
        {
            BlogName = b.Name,
            TotalPosts = b.Posts.Count(),
            PublishedPosts = b.Posts.Count(p => p.IsPublished),
            TotalViews = b.Posts.Sum(p => (int?)p.ViewCount) ?? 0,
            AvgViewsPerPost = b.Posts.Average(p => (double?)p.ViewCount) ?? 0,
            MostPopularPost = b.Posts.OrderByDescending(p => p.ViewCount)
                                    .Select(p => p.Title)
                                    .FirstOrDefault(),
            LatestPostDate = b.Posts.Max(p => (DateTime?)p.PublishDate),
            PostsByCategory = b.Posts
                .GroupBy(p => p.Category.Name)
                .Select(g => new CategoryStat
                {
                    CategoryName = g.Key,
                    PostCount = g.Count()
                })
                .ToList()
        })
        .FirstOrDefaultAsync();
}
```

## ? 总结

1. **全面支持**：EF Core 支持所有主要 SQL 聚合函数
2. **数据库端执行**：聚合操作在数据库执行，性能最佳
3. **组合灵活**：可与其他 LINQ 操作符组合使用
4. **异步友好**：所有聚合函数都有对应的异步版本

**最佳实践**：

- 尽量使用 `Async` 版本（`CountAsync`, `SumAsync` 等）
- 注意处理 NULL 值
- 对于复杂聚合，考虑使用数据库视图或存储过程
- 在分组查询中注意选择合适的索引

如果你有具体的聚合需求（如性能优化、复杂统计逻辑等），我可以提供更针对性的代码示例。
