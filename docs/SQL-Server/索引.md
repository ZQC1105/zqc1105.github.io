这两句脚本只建了**两个单列**非聚集索引：

```sql
CREATE NONCLUSTERED INDEX [IX_PostTag_PostId] ON [dbo].[PostTag]([PostId] ASC);
CREATE NONCLUSTERED INDEX [IX_PostTag_TagId] ON [dbo].[PostTag]([TagId] ASC);
```

对于典型的“多对多”中间表，它们**只能覆盖**：

- `WHERE PostId = ?`  
- `WHERE TagId = ?`

但**无法最优支持**最常见的“联合过滤”或“排序”场景，例如：

- `WHERE PostId = ? AND TagId = ?`（需同时命中两列）  
- `WHERE PostId = ? ORDER BY TagId`（或反向）

---

### 该怎样建才更合理？

1. 如果**没有唯一约束**，建议直接换成**复合索引**（覆盖+减少书签查找）：

```sql
-- 按 Post 查 Tag
CREATE NONCLUSTERED INDEX [IX_PostTag_PostId_TagId]
    ON [dbo].[PostTag] ([PostId], [TagId]);

-- 按 Tag 查 Post
CREATE NONCLUSTERED INDEX [IX_PostTag_TagId_PostId]
    ON [dbo].[PostTag] ([TagId], [PostId]);
```

2. 如果**已经**建了  
   `CONSTRAINT UQ_PostTag_PostId_TagId UNIQUE ([PostId], [TagId])`  
   那么 `IX_PostTag_PostId_TagId` 可以**省略**（唯一约束自带索引），只需再补一条反向复合索引即可：

```sql
CREATE NONCLUSTERED INDEX [IX_PostTag_TagId_PostId]
    ON [dbo].[PostTag] ([TagId], [PostId]);
```

---

### 一句话总结

- 单列索引 ≠ 复合索引  
- 多对多中间表优先用**复合索引**（或唯一复合索引）  
- 现有这两条 `IX_PostTag_PostId` / `IX_PostTag_TagId` 可以**drop**掉，换成上面的复合索引，性能更好、占用更少。