
```// 请求拦截器
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);


// 具名函数定义
const authInterceptor = (config: InternalAxiosRequestConfig) => {
  const token = localStorage.getItem('token');
  if (token && config.headers) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
};

const errorHandler = (error: AxiosError) => {
  console.error('请求拦截器错误:', error);
  return Promise.reject(error);
};
```
 这两种区别

这两种写法的核心区别在于**代码组织、可测试性和可维护性**，我给你对比一下：

## 🆚 核心区别对比

| 对比维度       | **内联匿名函数**                         | **具名函数**                                                            |
| :------------- | :--------------------------------------- | :---------------------------------------------------------------------- |
| **代码组织**   | 逻辑直接嵌入调用处，适合简单、一次性逻辑 | 逻辑抽离为独立函数，职责清晰                                            |
| **可读性**     | 在简单场景下直观，逻辑复杂时会降低可读性 | **函数名自解释意图**（如 `authInterceptor`），更易理解                  |
| **可复用性**   | **不可复用**，仅作用于当前拦截器         | **可在多个拦截器或其它地方复用**（如响应拦截器也可用 `authInterceptor`) |
| **可测试性**   | 难以单独测试                             | **可独立进行单元测试**                                                  |
| **调试便利性** | 堆栈跟踪显示为匿名函数，难以定位         | 堆栈跟踪显示**具名函数名**，便于定位问题                                |
| **适用场景**   | 简单、一次性、无需复用的逻辑             | 复杂、需要复用、测试或明确命名的逻辑                                    |

## 💡 具名函数的优势详解

```typescript
// 1. 明确职责与意图
const addAuthToken = (config: InternalAxiosRequestConfig) => {
  const token = localStorage.getItem('token');
  if (token && config.headers) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
};

const logRequestError = (error: AxiosError) => {
  console.error('请求拦截器错误:', error);
  return Promise.reject(error);
};

// 2. 更易复用
apiClient.interceptors.request.use(addAuthToken, logRequestError);
apiClient2.interceptors.request.use(addAuthToken); // 复用同一个函数

// 3. 易于测试（使用Jest示例）
describe('addAuthToken', () => {
  it('应添加Authorization头', () => {
    const mockConfig = { headers: {} };
    localStorage.setItem('token', 'test-token');
    
    const result = addAuthToken(mockConfig);
    expect(result.headers.Authorization).toBe('Bearer test-token');
  });
  
  it('无token时应保持原样', () => {
    const mockConfig = { headers: {} };
    localStorage.removeItem('token');
    
    const result = addAuthToken(mockConfig);
    expect(result.headers.Authorization).toBeUndefined();
  });
});
```

## 🎯 最佳实践建议

1.  **简单场景**：如果拦截器逻辑非常简单（如仅添加一个固定Header），可以使用内联匿名函数。
2.  **生产环境**：**强烈建议使用具名函数**，尤其是：
    *   处理认证、日志等核心业务逻辑
    *   需要单元测试的代码
    *   可能在多个地方复用的逻辑
    *   需要明确调试信息的场景

3.  **进一步优化**：可以创建专门的拦截器模块：
```typescript
// interceptors/auth.ts
export const authRequestInterceptor = (config: InternalAxiosRequestConfig) => {
  // 认证逻辑
};

export const authResponseInterceptor = (response: AxiosResponse) => {
  // 响应处理逻辑
};

// interceptors/error.ts  
export const errorInterceptor = (error: AxiosError) => {
  // 统一错误处理
};

// 在入口文件统一配置
import { authRequestInterceptor, errorInterceptor } from './interceptors';
apiClient.interceptors.request.use(authRequestInterceptor, errorInterceptor);
```

## 📊 何时选择哪种方式？

*   **使用内联匿名函数**：快速原型、临时测试、极其简单的逻辑（如添加一个固定Header）。
*   **使用具名函数**：**绝大多数生产场景**，特别是涉及业务逻辑、需要测试、可能复用的代码。

总的来说，虽然内联匿名函数写起来快，但**具名函数在可维护性、可测试性和代码清晰度上具有压倒性优势**，是现代前端工程化的推荐做法。



是的，你观察得很对！**`options => ...` 确实是一个内联的匿名函数（lambda表达式）**。这是C#中配置模式的一个经典应用。

## 🔍 详细分析

### 1. **匿名函数的本质**
```csharp
// 等价拆解，便于理解：

// 假设AddDbContext方法的签名是：
// AddDbContext<TContext>(Action<DbContextOptionsBuilder> optionsAction)

// 1. 匿名函数写法（你提供的）
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

// 2. 具名函数写法（逻辑完全相同）
private void ConfigureDbContext(DbContextOptionsBuilder options)
{
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"));
}

// 调用
builder.Services.AddDbContext<ApplicationDbContext>(ConfigureDbContext);
```

### 2. **为什么这里用内联函数很合适？**
| 方面         | 分析                                                   |
| ------------ | ------------------------------------------------------ |
| **场景特性** | 配置代码通常**一次性使用**，不会在其他地方复用         |
| **代码位置** | 通常在程序启动时（`Program.cs`或`Startup.cs`）集中配置 |
| **可读性**   | 配置逻辑与注册代码**紧邻**，上下文清晰                 |
| **简洁性**   | **避免了不必要的函数命名**，减少代码跳转               |

### 3. **与传统API拦截器的对比**
```csharp
// 场景对比：DbContext配置 vs API拦截器

// 1. DbContext配置（适合内联）
services.AddDbContext<AppDbContext>(options => 
    options.UseSqlServer(connectionString));
    // ✅ 简单、一次性、无需复用

// 2. 复杂API拦截器（适合具名）
services.AddHttpClient("api")
    .AddHttpMessageHandler(() => new AuthHeaderHandler()); // 内联
    // ❌ 如果AuthHeaderHandler逻辑复杂，应该抽离为具名类
```

## 🎯 判断何时用内联/具名的原则

| **使用内联匿名函数**                                 | **使用具名函数/类**                            |
| ---------------------------------------------------- | ---------------------------------------------- |
| **逻辑简单**（1-2行配置）                            | **逻辑复杂**（涉及条件判断、多步骤）           |
| **不会复用**                                         | **需要在多处复用**                             |
| **上下文自解释**                                     | **需要明确命名表达意图**                       |
| **无需单元测试**                                     | **需要独立单元测试**                           |
| **示例**：<br>`options => options.UseSqlServer(...)` | **示例**：<br>自定义的`AuthorizationHandler`类 |

## 📦 ASP.NET Core中的实际应用

实际上，ASP.NET Core自身也遵循这一原则。对于**简单配置**用内联函数，**复杂逻辑**抽离：

```csharp
// 内联函数示例（简单配置）
services.Configure<MyOptions>(options => {
    options.Value1 = "test";
    options.Value2 = 42;
});

// 具名类示例（复杂处理）
services.AddAuthentication()
    .AddJwtBearer(JwtBearerDefaults.AuthenticationScheme, 
        options => { /* 内联配置 */ }) // 简单配置内联
    .AddGoogle(options => { /* 内联配置 */ }); // 简单配置内联

// 但如果是自定义认证处理器：
services.AddAuthentication()
    .AddScheme<CustomAuthOptions, CustomAuthHandler>( // 复杂逻辑用具名类
        "CustomScheme", "Custom Authentication");
```

## 💡 最佳实践建议

对于你的DbContext配置：

1.  **保持内联**：如果你的配置只有`UseSqlServer`这一行，内联是最佳选择
2.  **考虑抽离的场景**：
    ```csharp
    // 如果配置变得复杂，考虑抽离
    builder.Services.AddDbContext<ApplicationDbContext>(ConfigureDbContext);
    
    private static void ConfigureDbContext(
        IServiceProvider serviceProvider, // 如果需要其他服务
        DbContextOptionsBuilder options)
    {
        var config = serviceProvider.GetRequiredService<IConfiguration>();
        var env = serviceProvider.GetRequiredService<IWebHostEnvironment>();
        
        if (env.IsDevelopment())
            options.UseSqlite(config.GetConnectionString("DevConnection"));
        else
            options.UseSqlServer(config.GetConnectionString("DefaultConnection"));
            
        options.EnableSensitiveDataLogging(env.IsDevelopment());
        options.ConfigureWarnings(warnings => warnings.Ignore(CoreEventId.PossibleIncorrectRequiredNavigation...));
    }
    ```

**总结**：你的DbContext配置使用内联函数是完全正确且符合惯例的，因为它简单、一次性且与注册代码上下文紧密相关。这是.NET中配置API的典型用法。