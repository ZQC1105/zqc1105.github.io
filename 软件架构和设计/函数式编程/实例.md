# C# 内联匿名函数与具名函数示例

## 1. 具名函数（Named Functions）

具名函数是使用传统方法声明和定义的函数，有明确的函数名。

```csharp
using System;

class Program
{
    static void Main()
    {
        // 使用具名函数
        int result1 = AddNumbers(5, 3);
        Console.WriteLine($"具名函数结果: {result1}");

        // 使用具名函数作为参数传递
        ProcessNumbers(10, 20, MultiplyNumbers);

        // 具名函数作为回调
        PerformOperation(15, 25, SubtractNumbers);
    }

    // 具名函数示例
    static int AddNumbers(int a, int b)
    {
        return a + b;
    }

    static int MultiplyNumbers(int a, int b)
    {
        return a * b;
    }

    static int SubtractNumbers(int a, int b)
    {
        return a - b;
    }

    // 接受函数作为参数的方法
    static void ProcessNumbers(int x, int y, Func<int, int, int> operation)
    {
        int result = operation(x, y);
        Console.WriteLine($"处理结果: {result}");
    }

    static void PerformOperation(int x, int y, Func<int, int, int> callback)
    {
        Console.WriteLine("执行操作前...");
        int result = callback(x, y);
        Console.WriteLine($"操作结果: {result}");
        Console.WriteLine("执行操作后...");
    }
}
```

## 2. 匿名函数（Anonymous Functions）

### 2.1 使用 delegate 关键字（C# 1.0+）

```csharp
using System;

class Program
{
    static void Main()
    {
        // 使用 delegate 关键字定义匿名函数
        delegate int MathOperation(int x, int y);

        MathOperation add = delegate(int a, int b)
        {
            return a + b;
        };

        MathOperation multiply = delegate(int a, int b)
        {
            return a * b;
        };

        Console.WriteLine($"delegate 加法: {add(5, 3)}");
        Console.WriteLine($"delegate 乘法: {multiply(5, 3)}");

        // 作为参数传递
        Calculate(10, 4, delegate(int x, int y)
        {
            return x / y;
        });
    }

    static void Calculate(int a, int b, MathOperation operation)
    {
        Console.WriteLine($"计算结果是: {operation(a, b)}");
    }
}
```

### 2.2 Lambda 表达式（C# 3.0+）

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

class Program
{
    static void Main()
    {
        // Lambda 表达式基础用法
        Func<int, int, int> add = (a, b) => a + b;
        Func<int, int, int> multiply = (a, b) => a * b;
        Func<int, int> square = x => x * x;
        Action<string> greet = name => Console.WriteLine($"Hello, {name}!");

        Console.WriteLine($"Lambda 加法: {add(5, 3)}");
        Console.WriteLine($"Lambda 平方: {square(4)}");
        greet("World");

        // 多行 Lambda 表达式
        Func<int, int, int> complexOperation = (a, b) =>
        {
            int sum = a + b;
            int product = a * b;
            return sum + product;
        };

        Console.WriteLine($"复杂操作: {complexOperation(3, 4)}");

        // LINQ 中使用 Lambda
        List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

        var evenNumbers = numbers.Where(n => n % 2 == 0);
        Console.WriteLine("偶数: " + string.Join(", ", evenNumbers));

        var squaredNumbers = numbers.Select(x => x * x);
        Console.WriteLine("平方数: " + string.Join(", ", squaredNumbers));

        // 事件处理中使用 Lambda
        var processor = new DataProcessor();
        processor.DataProcessed += (sender, e) =>
        {
            Console.WriteLine($"数据已处理: {e.Message}");
        };

        processor.ProcessData();
    }
}

class DataProcessor
{
    public event EventHandler<DataEventArgs> DataProcessed;

    public void ProcessData()
    {
        // 处理数据...
        OnDataProcessed("数据处理完成");
    }

    protected virtual void OnDataProcessed(string message)
    {
        DataProcessed?.Invoke(this, new DataEventArgs(message));
    }
}

class DataEventArgs : EventArgs
{
    public string Message { get; }

    public DataEventArgs(string message)
    {
        Message = message;
    }
}
```

### 2.3 局部函数（C# 7.0+）

```csharp
using System;

class Program
{
    static void Main()
    {
        // 局部函数示例
        int CalculateFactorial(int n)
        {
            if (n <= 1) return 1;
            return n * CalculateFactorial(n - 1);
        }

        Console.WriteLine($"5的阶乘: {CalculateFactorial(5)}");

        // 在方法中使用局部函数
        ProcessNumbers(7);
    }

    static void ProcessNumbers(int baseNumber)
    {
        // 局部函数可以访问外部方法的变量
        int multiplier = 2;

        int DoubleValue(int x) => x * multiplier;

        int AddBase(int x) => x + baseNumber;

        Console.WriteLine($"双倍值: {DoubleValue(10)}");
        Console.WriteLine($"加基数: {AddBase(10)}");

        // 更复杂的局部函数
        string FormatResult(int value)
        {
            if (value > 100)
                return $"结果较大: {value}";
            else if (value < 0)
                return $"结果为负: {value}";
            else
                return $"结果正常: {value}";
        }

        Console.WriteLine(FormatResult(150));
        Console.WriteLine(FormatResult(-5));
        Console.WriteLine(FormatResult(50));
    }
}
```

## 3. 实际应用对比

```csharp
using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        List<Employee> employees = new List<Employee>
        {
            new Employee { Id = 1, Name = "张三", Salary = 50000 },
            new Employee { Id = 2, Name = "李四", Salary = 60000 },
            new Employee { Id = 3, Name = "王五", Salary = 45000 },
            new Employee { Id = 4, Name = "赵六", Salary = 70000 }
        };

        // 具名函数方式
        var highSalaryEmployees1 = FilterEmployees(employees, IsHighSalary);
        Console.WriteLine("具名函数 - 高薪员工:");
        PrintEmployees(highSalaryEmployees1);

        // 匿名函数方式 (delegate)
        var midSalaryEmployees = FilterEmployees(employees, delegate(Employee emp)
        {
            return emp.Salary >= 50000 && emp.Salary <= 60000;
        });

        Console.WriteLine("\n匿名函数 (delegate) - 中等薪资员工:");
        PrintEmployees(midSalaryEmployees);

        // Lambda 表达式方式
        var specificEmployees = employees.FindAll(emp => emp.Name.Contains("张") || emp.Salary > 65000);
        Console.WriteLine("\nLambda 表达式 - 特定员工:");
        PrintEmployees(specificEmployees);

        // 使用局部函数
        void PrintEmployees(IEnumerable<Employee> empList)
        {
            foreach (var emp in empList)
            {
                Console.WriteLine($"  {emp.Name}: {emp.Salary:C}");
            }
        }
    }

    // 具名函数
    static bool IsHighSalary(Employee employee)
    {
        return employee.Salary > 55000;
    }

    // 通用过滤方法
    static List<Employee> FilterEmployees(List<Employee> employees, Predicate<Employee> filter)
    {
        return employees.FindAll(filter);
    }
}

class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Salary { get; set; }
}
```

## 4. 异步示例

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        // 具名异步函数
        async Task<string> FetchDataAsync(string url)
        {
            await Task.Delay(1000); // 模拟网络请求
            return $"数据来自: {url}";
        }

        // 匿名异步函数 (Lambda)
        Func<string, Task<string>> fetchDataLambda = async (url) =>
        {
            await Task.Delay(500);
            return $"Lambda 获取: {url}";
        };

        Console.WriteLine("开始获取数据...");

        // 使用具名函数
        var result1 = await FetchDataAsync("https://api.example.com/data");
        Console.WriteLine(result1);

        // 使用匿名函数
        var result2 = await fetchDataLambda("https://api.example.com/users");
        Console.WriteLine(result2);

        // 直接在方法调用中使用匿名异步函数
        await ProcessAsync(async () =>
        {
            await Task.Delay(300);
            Console.WriteLine("匿名异步函数执行完成");
        });
    }

    static async Task ProcessAsync(Func<Task> asyncAction)
    {
        Console.WriteLine("开始处理...");
        await asyncAction();
        Console.WriteLine("处理完成");
    }
}
```

## 5. 性能与使用建议

```csharp
using System;
using System.Diagnostics;

class Program
{
    static void Main()
    {
        const int iterations = 1000000;

        // 具名函数
        Func<int, int, int> namedFunc = Add;

        // 匿名函数
        Func<int, int, int> anonymousFunc = (a, b) => a + b;

        // 性能测试
        Stopwatch sw = new Stopwatch();

        sw.Start();
        for (int i = 0; i < iterations; i++)
        {
            namedFunc(i, i + 1);
        }
        sw.Stop();
        Console.WriteLine($"具名函数耗时: {sw.ElapsedMilliseconds}ms");

        sw.Restart();
        for (int i = 0; i < iterations; i++)
        {
            anonymousFunc(i, i + 1);
        }
        sw.Stop();
        Console.WriteLine($"匿名函数耗时: {sw.ElapsedMilliseconds}ms");

        // 使用建议：
        // 1. 简单操作使用 Lambda 表达式
        // 2. 复杂逻辑使用具名函数或局部函数
        // 3. 需要重复使用的逻辑使用具名函数
        // 4. 只在单个方法中使用的辅助逻辑使用局部函数
    }

    static int Add(int a, int b) => a + b;
}
```

## 总结对比

| 特性             | 具名函数             | 匿名函数 (Lambda)  | 局部函数               |
| ---------------- | -------------------- | ------------------ | ---------------------- |
| **语法**         | 传统方法定义         | `(参数) => 表达式` | 在方法内定义           |
| **作用域**       | 类级别               | 定义它的作用域内   | 包含它的方法内         |
| **可重用性**     | 高，可在多处调用     | 低，通常单处使用   | 中，只在包含方法内     |
| **可读性**       | 高，有明确名称       | 取决于复杂度       | 高，与上下文相关       |
| **访问外部变量** | 只能访问参数和类成员 | 可以捕获外部变量   | 可以访问包含方法的变量 |
| **性能**         | 通常最优             | 可能创建闭包开销   | 与具名函数类似         |

选择建议：

- 使用**具名函数**：逻辑复杂、需要多处重用、需要良好封装时
- 使用**Lambda 表达式**：简单操作、LINQ 查询、事件处理、作为参数传递时
- 使用**局部函数**：辅助逻辑、需要访问外部方法变量、提高代码可读性时
