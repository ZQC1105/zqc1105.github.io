# C# 装饰器设计模式详解

装饰器模式是一种结构型设计模式，允许在不改变对象结构的情况下，动态地向对象添加额外的功能。

## 1. 核心概念

### 基本结构

```
组件接口 (IComponent)
    ↑
具体组件 (ConcreteComponent)
    ↑
装饰器基类 (Decorator) → 持有 IComponent 引用
    ↑
具体装饰器 (ConcreteDecoratorA, ConcreteDecoratorB, ...)
```

## 2. 简单示例：咖啡订单系统

```csharp
using System;

// 1. 组件接口
public interface ICoffee
{
    string GetDescription();
    double GetCost();
}

// 2. 具体组件
public class SimpleCoffee : ICoffee
{
    public string GetDescription() => "Simple Coffee";
    public double GetCost() => 5.0;
}

// 3. 装饰器基类
public abstract class CoffeeDecorator : ICoffee
{
    protected ICoffee _coffee;

    protected CoffeeDecorator(ICoffee coffee)
    {
        _coffee = coffee;
    }

    public virtual string GetDescription() => _coffee.GetDescription();
    public virtual double GetCost() => _coffee.GetCost();
}

// 4. 具体装饰器
public class MilkDecorator : CoffeeDecorator
{
    public MilkDecorator(ICoffee coffee) : base(coffee) { }

    public override string GetDescription() =>
        _coffee.GetDescription() + ", Milk";

    public override double GetCost() =>
        _coffee.GetCost() + 1.5;
}

public class SugarDecorator : CoffeeDecorator
{
    public SugarDecorator(ICoffee coffee) : base(coffee) { }

    public override string GetDescription() =>
        _coffee.GetDescription() + ", Sugar";

    public override double GetCost() =>
        _coffee.GetCost() + 0.5;
}

public class WhippedCreamDecorator : CoffeeDecorator
{
    public WhippedCreamDecorator(ICoffee coffee) : base(coffee) { }

    public override string GetDescription() =>
        _coffee.GetDescription() + ", Whipped Cream";

    public override double GetCost() =>
        _coffee.GetCost() + 2.0;
}

// 5. 使用示例
class Program
{
    static void Main(string[] args)
    {
        // 简单的咖啡
        ICoffee coffee = new SimpleCoffee();
        Console.WriteLine($"{coffee.GetDescription()} - ${coffee.GetCost():F2}");

        // 加牛奶
        coffee = new MilkDecorator(coffee);
        Console.WriteLine($"{coffee.GetDescription()} - ${coffee.GetCost():F2}");

        // 加糖
        coffee = new SugarDecorator(coffee);
        Console.WriteLine($"{coffee.GetDescription()} - ${coffee.GetCost():F2}");

        // 再加奶油
        coffee = new WhippedCreamDecorator(coffee);
        Console.WriteLine($"{coffee.GetDescription()} - ${coffee.GetCost():F2}");

        // 也可以链式创建
        ICoffee fancyCoffee = new WhippedCreamDecorator(
            new SugarDecorator(
                new MilkDecorator(
                    new SimpleCoffee()
                )
            )
        );

        Console.WriteLine($"Fancy Coffee: {fancyCoffee.GetDescription()} - ${fancyCoffee.GetCost():F2}");
    }
}
```

## 3. 实际应用示例：文本处理系统

```csharp
using System;
using System.Text;

// 1. 组件接口
public interface IText
{
    string Format();
}

// 2. 具体组件
public class PlainText : IText
{
    private readonly string _content;

    public PlainText(string content)
    {
        _content = content;
    }

    public string Format() => _content;
}

// 3. 装饰器基类
public abstract class TextDecorator : IText
{
    protected IText _text;

    protected TextDecorator(IText text)
    {
        _text = text;
    }

    public virtual string Format() => _text.Format();
}

// 4. 具体装饰器
public class BoldDecorator : TextDecorator
{
    public BoldDecorator(IText text) : base(text) { }

    public override string Format() => $"<b>{_text.Format()}</b>";
}

public class ItalicDecorator : TextDecorator
{
    public ItalicDecorator(IText text) : base(text) { }

    public override string Format() => $"<i>{_text.Format()}</i>";
}

public class UnderlineDecorator : TextDecorator
{
    public UnderlineDecorator(IText text) : base(text) { }

    public override string Format() => $"<u>{_text.Format()}</u>";
}

public class ColorDecorator : TextDecorator
{
    private readonly string _color;

    public ColorDecorator(IText text, string color) : base(text)
    {
        _color = color;
    }

    public override string Format() =>
        $"<span style='color:{_color}'>{_text.Format()}</span>";
}

// 5. 客户端代码
class Program
{
    static void Main()
    {
        IText text = new PlainText("Hello, Decorator Pattern!");

        // 添加各种格式
        text = new BoldDecorator(text);
        text = new ItalicDecorator(text);
        text = new ColorDecorator(text, "red");
        text = new UnderlineDecorator(text);

        Console.WriteLine("Formatted Text:");
        Console.WriteLine(text.Format());
        // 输出: <u><span style='color:red'><i><b>Hello, Decorator Pattern!</b></i></span></u>
    }
}
```

## 4. 高级示例：日志记录系统

```csharp
using System;
using System.IO;

// 1. 组件接口
public interface ILogger
{
    void Log(string message, LogLevel level);
}

public enum LogLevel
{
    Info,
    Warning,
    Error
}

// 2. 具体组件
public class ConsoleLogger : ILogger
{
    public void Log(string message, LogLevel level)
    {
        var color = Console.ForegroundColor;

        switch (level)
        {
            case LogLevel.Info:
                Console.ForegroundColor = ConsoleColor.White;
                break;
            case LogLevel.Warning:
                Console.ForegroundColor = ConsoleColor.Yellow;
                break;
            case LogLevel.Error:
                Console.ForegroundColor = ConsoleColor.Red;
                break;
        }

        Console.WriteLine($"[{level}] {DateTime.Now:HH:mm:ss}: {message}");
        Console.ForegroundColor = color;
    }
}

// 3. 装饰器基类
public abstract class LoggerDecorator : ILogger
{
    protected ILogger _logger;

    protected LoggerDecorator(ILogger logger)
    {
        _logger = logger;
    }

    public virtual void Log(string message, LogLevel level)
    {
        _logger.Log(message, level);
    }
}

// 4. 具体装饰器
public class FileLoggerDecorator : LoggerDecorator
{
    private readonly string _filePath;

    public FileLoggerDecorator(ILogger logger, string filePath)
        : base(logger)
    {
        _filePath = filePath;
    }

    public override void Log(string message, LogLevel level)
    {
        base.Log(message, level);

        // 附加文件记录功能
        File.AppendAllText(_filePath,
            $"[{level}] {DateTime.Now:yyyy-MM-dd HH:mm:ss}: {message}\n");
    }
}

public class ErrorOnlyLoggerDecorator : LoggerDecorator
{
    public ErrorOnlyLoggerDecorator(ILogger logger) : base(logger) { }

    public override void Log(string message, LogLevel level)
    {
        // 只记录错误级别的日志
        if (level == LogLevel.Error)
        {
            _logger.Log(message, level);
        }
    }
}

public class TimestampLoggerDecorator : LoggerDecorator
{
    public TimestampLoggerDecorator(ILogger logger) : base(logger) { }

    public override void Log(string message, LogLevel level)
    {
        // 添加时间戳
        var timestampedMessage = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} - {message}";
        _logger.Log(timestampedMessage, level);
    }
}

// 5. 使用示例
class Program
{
    static void Main()
    {
        // 创建基础日志记录器
        ILogger logger = new ConsoleLogger();

        // 添加时间戳功能
        logger = new TimestampLoggerDecorator(logger);

        // 添加文件记录功能
        logger = new FileLoggerDecorator(logger, "app.log");

        // 使用日志系统
        logger.Log("Application started", LogLevel.Info);
        logger.Log("Warning: Low memory", LogLevel.Warning);
        logger.Log("Critical error occurred", LogLevel.Error);

        // 创建只记录错误的日志器
        ILogger errorOnlyLogger = new ErrorOnlyLoggerDecorator(
            new FileLoggerDecorator(
                new ConsoleLogger(),
                "errors.log"
            )
        );

        errorOnlyLogger.Log("This info won't be logged", LogLevel.Info);
        errorOnlyLogger.Log("This error will be logged", LogLevel.Error);
    }
}
```

## 5. 装饰器模式的优缺点

### 优点：

- **开闭原则**：可以在不修改现有代码的情况下扩展功能
- **单一职责原则**：可以将大型类拆分为多个小装饰器
- **运行时添加功能**：可以在运行时动态地添加或移除功能
- **组合优于继承**：避免了继承带来的类爆炸问题

### 缺点：

- **装饰器栈可能复杂**：多层装饰可能导致调试困难
- **初始化代码可能繁琐**：创建装饰链的代码可能很长
- **类型问题**：装饰后的对象不是原始类型

## 6. 最佳实践和注意事项

1. **使用场景**：
   - 需要在不影响其他对象的情况下，动态、透明地给对象添加职责
   - 当继承扩展不切实际时（如类被标记为sealed）
   - 需要撤销功能时（可以简单地移除装饰器）

2. **C# 特定实现提示**：

   ```csharp
   // 使用扩展方法简化装饰器的使用
   public static class CoffeeExtensions
   {
       public static ICoffee AddMilk(this ICoffee coffee)
       {
           return new MilkDecorator(coffee);
       }

       public static ICoffee AddSugar(this ICoffee coffee)
       {
           return new SugarDecorator(coffee);
       }
   }

   // 使用示例
   ICoffee coffee = new SimpleCoffee()
       .AddMilk()
       .AddSugar()
       .AddMilk(); // 可以添加多次
   ```

3. **与继承的区别**：
   - 继承是静态的，装饰是动态的
   - 装饰可以在运行时改变，继承在编译时确定
   - 装饰支持多个独立扩展的组合

装饰器模式在.NET Framework中也有广泛应用，例如：

- `Stream` 类的装饰器：`BufferedStream`、`CryptoStream`、`GZipStream`
- `TextWriter`/`TextReader` 的装饰器

这种模式特别适合需要灵活扩展功能，同时又需要保持代码简洁和可维护性的场景。
