# 适配器模式的总结

## 6. 适配器模式的优点和适用场景

### 6.1 优点

| 优点           | 说明                                   |
| -------------- | -------------------------------------- |
| **接口兼容性** | 让原本不兼容的接口能够一起工作         |
| **代码重用**   | 可以重用现有的类，无需修改源代码       |
| **开闭原则**   | 可以随时添加新的适配器而不影响现有代码 |
| **单一职责**   | 将接口转换逻辑与业务逻辑分离           |
| **灵活解耦**   | 客户端与具体实现解耦，易于维护和扩展   |
| **透明性**     | 客户端无需知道适配器的存在             |

**技术细节说明：**

- **解耦程度高**：客户端只依赖目标接口，不依赖具体实现
- **扩展性强**：新增适配器不会影响现有适配器
- **测试友好**：可以创建测试适配器来模拟外部依赖
- **维护性**：当被适配者接口变化时，只需修改适配器

### 6.2 适用场景

| 场景             | 具体示例               | 说明                           |
| ---------------- | ---------------------- | ------------------------------ |
| **集成遗留系统** | 老系统与新系统对接     | 旧代码接口不符合新系统要求     |
| **使用第三方库** | 多个支付网关、日志库   | 不同厂商提供的接口不一致       |
| **接口版本兼容** | API版本升级            | 需要支持新旧版本客户端         |
| **统一接口规范** | 多个子系统统一接口     | 为不同子系统提供统一访问方式   |
| **数据格式转换** | XML转JSON、CSV转对象   | 不同数据格式间的转换           |
| **平台适配**     | Windows/Linux/Mac兼容  | 不同平台API的适配              |
| **测试桩(Stub)** | 单元测试中模拟外部服务 | 创建测试用的适配器模拟真实服务 |

**实际应用判断标准：**

1. 需要在不修改源代码的情况下复用现有类
2. 系统需要使用多个具有相似功能但接口不同的类
3. 需要创建一个可以在多个不兼容类间工作的类
4. 需要使用现有的子类，但无法使其父类接口匹配目标接口

### 6.3 与相关模式对比

#### 适配器 vs 桥接模式

| 方面         | 适配器模式               | 桥接模式                   |
| ------------ | ------------------------ | -------------------------- |
| **目的**     | 使不兼容接口协同工作     | 将抽象与实现分离，独立变化 |
| **使用时机** | 事后补救，已有代码不匹配 | 设计时规划，预先设计结构   |
| **关注点**   | 接口转换                 | 结构分离                   |
| **复杂度**   | 相对简单                 | 相对复杂                   |
| **典型场景** | 集成第三方库             | 跨平台开发、多维度变化     |

**关键区别：**

- 适配器是**补救模式**（已有代码不匹配）
- 桥接是**设计模式**（预先设计解耦）

#### 适配器 vs 装饰器模式

| 方面         | 适配器模式 | 装饰器模式   |
| ------------ | ---------- | ------------ |
| **目的**     | 转换接口   | 增强功能     |
| **接口变化** | 改变接口   | 保持接口     |
| **对象关系** | 包装并转换 | 包装并增强   |
| **使用方式** | 通常一对一 | 可以嵌套多层 |

**示例对比：**

- 适配器：`圆形接口` → `方形适配器`（改变形状）
- 装饰器：`咖啡` → `加糖装饰器` → `加奶装饰器`（增强味道）

#### 适配器 vs 外观模式

| 方面         | 适配器模式       | 外观模式       |
| ------------ | ---------------- | -------------- |
| **接口数量** | 通常转换一个接口 | 简化多个接口   |
| **复杂程度** | 相对简单         | 相对复杂       |
| **目的**     | 接口转换         | 接口简化       |
| **透明度**   | 可能暴露被适配者 | 隐藏子系统细节 |

**示例对比：**

- 适配器：`USB-A转USB-C`（一对一转换）
- 外观：`电脑启动按钮`（封装开机自检、系统加载等多个步骤）

#### 适配器 vs 代理模式

| 方面         | 适配器模式   | 代理模式               |
| ------------ | ------------ | ---------------------- |
| **目的**     | 接口转换     | 访问控制               |
| **对象创建** | 包装现有对象 | 可能创建新对象         |
| **关注点**   | 接口兼容性   | 访问安全性、延迟加载等 |

## 7. 最佳实践

### 7.1 设计原则应用

| 原则         | 在适配器中的体现                     |
| ------------ | ------------------------------------ |
| **开闭原则** | 可以新增适配器而不修改现有代码       |
| **单一职责** | 适配器只负责接口转换，不包含业务逻辑 |
| **依赖倒置** | 客户端依赖抽象接口，不依赖具体实现   |
| **接口隔离** | 目标接口应该最小化，只暴露必要方法   |
| **里氏替换** | 适配器应该完全替代目标接口           |

### 7.2 实现建议

#### 1. 优先使用对象适配器

```csharp
// 推荐：对象适配器（组合）
public class Adapter : ITarget
{
    private readonly Adaptee _adaptee; // 组合方式

    public Adapter(Adaptee adaptee)
    {
        _adaptee = adaptee;
    }
}

// 避免：类适配器（继承，C#中通过接口模拟）
public class Adapter : Adaptee, ITarget // 多重继承问题
{
}
```

**理由：**

- 更灵活：可以在运行时切换被适配者
- 符合组合优于继承原则
- 避免C#不支持多重继承的局限性

#### 2. 保持适配器简单

```csharp
// 正确：只做接口转换
public class PaymentAdapter : IPaymentProcessor
{
    public bool ProcessPayment(PaymentRequest request)
    {
        // 只做必要的转换
        var legacyRequest = ConvertToLegacyFormat(request);
        return _legacySystem.Process(legacyRequest);
    }
}

// 避免：在适配器中添加业务逻辑
public class PaymentAdapter : IPaymentProcessor
{
    public bool ProcessPayment(PaymentRequest request)
    {
        // ❌ 不应该在这里添加业务逻辑
        if (request.Amount <= 0)
            throw new Exception("金额无效");
        // ... 转换逻辑
    }
}
```

#### 3. 考虑性能优化

```csharp
// 优化：缓存转换结果
public class DataAdapter : IDataFormat
{
    private readonly Dictionary<string, object> _cache = new();

    public string Convert(string input)
    {
        if (_cache.TryGetValue(input, out var cached))
            return (string)cached;

        // 执行转换
        var result = ExpensiveConversion(input);
        _cache[input] = result;
        return result;
    }
}
```

#### 4. 使用依赖注入

```csharp
// 注册适配器
services.AddSingleton<ILogger>(provider =>
{
    var config = provider.GetService<IConfiguration>();
    return config["LoggerType"] switch
    {
        "Log4Net" => new Log4NetAdapter(new Log4NetLibrary()),
        "NLog" => new NLogAdapter(new NLogLibrary()),
        _ => new DefaultLoggerAdapter()
    };
});
```

#### 5. 编写完善的测试

```csharp
[TestFixture]
public class PaymentAdapterTests
{
    [Test]
    public void ProcessPayment_ConvertsRequestCorrectly()
    {
        // 准备
        var legacySystem = new Mock<ILegacyPaymentSystem>();
        var adapter = new PaymentAdapter(legacySystem.Object);

        // 执行
        var result = adapter.ProcessPayment(new PaymentRequest { Amount = 100 });

        // 验证
        legacySystem.Verify(x => x.Process(It.Is<LegacyRequest>(r =>
            r.Amount == 100)), Times.Once);
    }
}
```

#### 6. 文档化和注释

```csharp
/// <summary>
/// 支付网关适配器
/// 将统一支付接口适配到第三方支付网关A
///
/// 转换规则：
/// 1. MerchantId → CustomerEmail (添加@example.com后缀)
/// 2. Amount → 直接映射
/// 3. Currency → CurrencyCode (格式不变)
/// 4. Description → 直接映射
///
/// 异常处理：
/// - 网络超时：重试3次
/// - 支付失败：返回false，不抛出异常
/// </summary>
public class GatewayAAdapter : IPaymentProcessor
{
    // 实现代码...
}
```

#### 7. 考虑双向适配需求

```csharp
// 如果需要两个系统互相调用
public class BidirectionalAdapter : ISystemA, ISystemB
{
    private readonly ISystemA _systemA;
    private readonly ISystemB _systemB;

    // 提供两种构造方式
    public BidirectionalAdapter(ISystemA systemA)
    {
        _systemA = systemA;
    }

    public BidirectionalAdapter(ISystemB systemB)
    {
        _systemB = systemB;
    }

    // 实现两种接口
    public void MethodA()
    {
        if (_systemB != null)
            _systemB.MethodB(); // 转换调用
        else
            _systemA.MethodA();
    }
}
```

### 7.3 反模式警告

| 反模式           | 问题                   | 解决方案               |
| ---------------- | ---------------------- | ---------------------- |
| **全能适配器**   | 一个适配器适配太多接口 | 拆分为多个专用适配器   |
| **业务逻辑泄露** | 适配器包含业务逻辑     | 将业务逻辑移到服务层   |
| **过度适配**     | 不需要适配器时强行使用 | 评估是否真的需要适配器 |
| **性能瓶颈**     | 适配器引入太多开销     | 优化转换逻辑，考虑缓存 |
| **维护困难**     | 适配器链太长           | 扁平化设计，减少层级   |

### 7.4 现代C#特性应用

```csharp
// 使用扩展方法作为轻量级适配器
public static class LegacySystemExtensions
{
    public static PaymentRequest ToPaymentRequest(this LegacyRequest legacy)
    {
        return new PaymentRequest
        {
            Amount = legacy.Amount,
            Currency = legacy.CurrencyCode,
            // 使用模式匹配处理不同情况
            CustomerId = legacy.CustomerEmail?.Split('@')[0] ?? "unknown"
        };
    }
}

// 使用record简化适配器
public record PaymentAdapter(LegacyPaymentSystem System) : IPaymentProcessor
{
    public bool ProcessPayment(PaymentRequest request) =>
        System.MakePayment(
            request.MerchantId,
            request.Amount,
            request.Currency
        );
}
```

### 7.5 决策流程图

```
是否需要使用现有类？ → 否 → 不需要适配器
        ↓是
现有类接口是否符合需求？ → 是 → 直接使用
        ↓否
考虑修改现有类？ → 可行 → 修改源代码（如果可以）
        ↓不可行
        ↓
    ┌─────────────┐
    │ 使用适配器模式 │
    └─────────────┘
        ↓
选择适配器类型：
1. 对象适配器（推荐） → 需要运行时灵活性
2. 类适配器 → 简单场景，C#中有限制
3. 双向适配器 → 需要互相转换
```

## 总结要点

1. **适配器是接口转换器**：核心作用是转换接口，使不兼容的类可以协作
2. **优先使用对象适配器**：更灵活，符合现代设计原则
3. **保持适配器简单**：只负责转换，不添加业务逻辑
4. **考虑性能影响**：转换可能引入开销，需要优化
5. **善用现代语言特性**：使用扩展方法、record等简化实现
6. **全面测试**：适配器是集成点，需要充分测试
7. **文档化转换规则**：明确记录接口映射关系

适配器模式是解决接口不兼容问题的经典方案，正确使用可以显著提高代码的复用性和系统的可维护性。
