# 数据库和 SQL 面试题目（60 题）

## 一、基础概念和理论（15 题）

### 初级题目（8 题）

**1. 什么是数据库？数据库管理系统（DBMS）的作用是什么？**

```
数据库：有组织的数据集合。
DBMS作用：
- 数据定义（创建、修改、删除结构）
- 数据操作（增删改查）
- 数据控制（权限、完整性、并发）
- 数据维护（备份、恢复、优化）
```

**2. 关系型数据库和非关系型数据库的主要区别是什么？**

```
关系型数据库：
- 使用表和行列结构
- 遵循ACID原则
- 使用SQL查询
- 如：MySQL, PostgreSQL, SQL Server

非关系型数据库：
- 灵活的数据模型（文档、键值、图、列族）
- 强调可扩展性和性能
- 如：MongoDB, Redis, Cassandra
```

**3. SQL 是什么？DDL、DML、DCL、TCL 分别是什么？**

```
SQL：结构化查询语言
DDL（数据定义语言）：CREATE, ALTER, DROP, TRUNCATE
DML（数据操作语言）：SELECT, INSERT, UPDATE, DELETE
DCL（数据控制语言）：GRANT, REVOKE
TCL（事务控制语言）：COMMIT, ROLLBACK, SAVEPOINT
```

**4. 什么是主键（Primary Key）和外键（Foreign Key）？**

```
主键：
- 唯一标识表中的每一行
- 不能为NULL
- 一个表只能有一个主键

外键：
- 建立两个表之间的关系
- 引用另一个表的主键
- 保证引用完整性
```

**5. 数据库约束有哪些类型？**

```
- NOT NULL：不允许空值
- UNIQUE：唯一性
- PRIMARY KEY：主键
- FOREIGN KEY：外键
- CHECK：检查条件
- DEFAULT：默认值
```

**6. 什么是数据库范式？简述第一、第二、第三范式**

```
范式：数据库设计规范，减少数据冗余和异常
第一范式（1NF）：每列都是原子值，不可再分
第二范式（2NF）：满足1NF，非主键列完全依赖于主键
第三范式（3NF）：满足2NF，消除传递依赖（非主键列不依赖于其他非主键列）
```

**7. 什么是索引？它的优缺点是什么？**

```
索引：加快数据检索速度的数据结构
优点：
- 加快查询速度
- 保证数据唯一性
缺点：
- 占用存储空间
- 降低插入、更新、删除速度
- 需要维护成本
```

**8. 数据库事务的 ACID 特性是什么？**

```
ACID：
Atomicity（原子性）：事务要么全部完成，要么全部回滚
Consistency（一致性）：事务前后数据库状态一致
Isolation（隔离性）：并发事务互不干扰
Durability（持久性）：事务提交后永久保存
```

### 中级题目（7 题）

**9. 什么是存储过程？优缺点是什么？**

```
存储过程：预编译的SQL代码块
优点：
- 提高性能（预编译）
- 减少网络流量
- 增强安全性
- 代码重用
缺点：
- 调试困难
- 移植性差
- 版本控制困难
```

**10. 什么是触发器？使用场景是什么？**

```
触发器：自动执行的存储过程，响应特定事件（INSERT, UPDATE, DELETE）
使用场景：
- 审计跟踪
- 数据验证
- 自动计算字段
- 级联操作
类型：BEFORE/AFTER, INSTEAD OF
```

**11. 什么是视图？优缺点是什么？**

```
视图：虚拟表，基于查询结果
优点：
- 简化复杂查询
- 增强安全性（隐藏敏感数据）
- 逻辑数据独立性
缺点：
- 性能可能受影响
- 更新限制较多
类型：普通视图、物化视图
```

**12. 什么是游标？何时使用？**

```
游标：逐行处理查询结果集的机制
使用场景：
- 逐行处理需要复杂业务逻辑
- 需要多次扫描同一结果集
注意：游标性能较差，应尽量避免使用
```

**13. 什么是死锁？如何避免和解决？**

```
死锁：两个或多个事务互相等待对方释放锁
避免方法：
- 保持事务简短
- 按相同顺序访问资源
- 使用合适的隔离级别
- 设置锁超时
解决方法：数据库自动检测并回滚其中一个事务
```

**14. 什么是数据库连接池？**

```
连接池：预先创建的数据库连接集合
优点：
- 减少连接创建开销
- 提高响应速度
- 控制连接数量
配置参数：最小连接数、最大连接数、超时时间
```

**15. 什么是数据库分片（Sharding）？**

```
分片：将大数据集水平分割到多个数据库
策略：
- 范围分片
- 哈希分片
- 地理位置分片
挑战：跨分片查询、事务、数据再平衡
```

## 二、SQL 查询和操作（25 题）

### 初级题目（10 题）

**16. SELECT 语句的基本语法是什么？**

```sql
SELECT [DISTINCT] column1, column2, ...
FROM table_name
[WHERE condition]
[GROUP BY column]
[HAVING condition]
[ORDER BY column [ASC|DESC]]
[LIMIT number];
```

**17. WHERE 和 HAVING 的区别是什么？**

```
WHERE：
- 在分组前过滤行
- 不能使用聚合函数
- 作用于单行

HAVING：
- 在分组后过滤组
- 可以使用聚合函数
- 作用于分组
```

**18. JOIN 的类型有哪些？**

```
INNER JOIN：返回匹配的行
LEFT JOIN：返回左表所有行和匹配的右表行
RIGHT JOIN：返回右表所有行和匹配的左表行
FULL OUTER JOIN：返回所有匹配和不匹配的行
CROSS JOIN：笛卡尔积
SELF JOIN：表与自身连接
```

**19. 写出查询每个部门最高工资的 SQL**

```sql
-- 方法1：使用GROUP BY
SELECT department_id, MAX(salary) as max_salary
FROM employees
GROUP BY department_id;

-- 方法2：使用子查询
SELECT e.department_id, e.salary
FROM employees e
WHERE e.salary = (
    SELECT MAX(salary)
    FROM employees
    WHERE department_id = e.department_id
);
```

**20. UNION 和 UNION ALL 的区别是什么？**

```
UNION：
- 合并结果集并去重
- 排序处理
- 性能较差

UNION ALL：
- 合并结果集不去重
- 不排序
- 性能较好
```

**21. 如何删除重复记录？**

```sql
-- 使用CTE和ROW_NUMBER()
WITH CTE AS (
    SELECT *,
           ROW_NUMBER() OVER (
               PARTITION BY column1, column2
               ORDER BY id
           ) as rn
    FROM table_name
)
DELETE FROM CTE WHERE rn > 1;

-- 使用GROUP BY保留一条
DELETE FROM table_name
WHERE id NOT IN (
    SELECT MIN(id)
    FROM table_name
    GROUP BY column1, column2
);
```

**22. 什么是子查询？类型有哪些？**

```
子查询：嵌套在主查询中的查询
类型：
- 标量子查询（返回单个值）
- 行子查询（返回单行多列）
- 列子查询（返回单列多行）
- 表子查询（返回多行多列）
位置：SELECT, FROM, WHERE, HAVING
```

**23. 如何实现分页查询？**

```sql
-- SQL Server
SELECT * FROM table_name
ORDER BY column
OFFSET 10 ROWS
FETCH NEXT 5 ROWS ONLY;

-- MySQL
SELECT * FROM table_name
ORDER BY column
LIMIT 10, 5;

-- Oracle
SELECT * FROM (
    SELECT t.*, ROWNUM rn
    FROM (
        SELECT * FROM table_name
        ORDER BY column
    ) t
    WHERE ROWNUM <= 15
) WHERE rn > 10;
```

**24. 什么是 CASE 表达式？举例说明**

```sql
SELECT
    employee_id,
    salary,
    CASE
        WHEN salary < 3000 THEN '低薪'
        WHEN salary BETWEEN 3000 AND 8000 THEN '中薪'
        ELSE '高薪'
    END as salary_level
FROM employees;
```

**25. NULL 值的处理注意事项**

```
- NULL与任何值比较都是NULL
- 使用IS NULL或IS NOT NULL判断
- 聚合函数忽略NULL（COUNT(*)除外）
- COALESCE()返回第一个非NULL值
- NULLIF()两个值相等返回NULL
```

### 中级题目（10 题）

**26. 窗口函数有哪些？举例说明**

```sql
-- 排名函数
ROW_NUMBER()：连续排名
RANK()：并列排名，跳过名次
DENSE_RANK()：并列排名，不跳过名次

-- 聚合窗口函数
SUM() OVER (PARTITION BY ...)
AVG() OVER (PARTITION BY ...)

-- 示例
SELECT
    employee_id,
    department_id,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank_in_dept,
    AVG(salary) OVER (PARTITION BY department_id) as avg_salary_dept
FROM employees;
```

**27. 什么是公用表表达式（CTE）？**

```sql
-- 递归CTE示例
WITH RECURSIVE EmployeeHierarchy AS (
    -- 锚点成员
    SELECT employee_id, manager_id, 1 as level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- 递归成员
    SELECT e.employee_id, e.manager_id, eh.level + 1
    FROM employees e
    INNER JOIN EmployeeHierarchy eh ON e.manager_id = eh.employee_id
)
SELECT * FROM EmployeeHierarchy;
```

**28. 如何优化大表查询性能？**

```
1. 添加合适的索引
2. 避免SELECT *，只选择需要的列
3. 使用分页
4. 优化WHERE条件（避免函数操作）
5. 避免使用NOT IN，改用NOT EXISTS或LEFT JOIN
6. 使用覆盖索引
7. 定期分析和重建索引
8. 分区表
```

**29. 什么是执行计划？如何分析？**

```
执行计划：数据库执行查询的步骤
查看方法：
- SQL Server: SET SHOWPLAN_ALL ON
- MySQL: EXPLAIN
- Oracle: EXPLAIN PLAN FOR
分析要点：
- 表扫描还是索引查找
- 连接类型和顺序
- 估计行数和实际行数
- 排序和聚合操作
```

**30. 批量插入数据的优化方法**

```sql
-- 方法1：使用单个INSERT多值
INSERT INTO table_name (col1, col2)
VALUES (val1, val2),
       (val3, val4);

-- 方法2：批量插入
BEGIN TRANSACTION
-- 多次INSERT
COMMIT

-- 方法3：使用BULK INSERT（SQL Server）
BULK INSERT table_name
FROM 'file_path'
WITH (FIELDTERMINATOR = ',', ROWTERMINATOR = '\n');
```

**31. 如何实现数据归档策略？**

```sql
-- 1. 创建归档表
CREATE TABLE orders_archive LIKE orders;

-- 2. 移动旧数据
INSERT INTO orders_archive
SELECT * FROM orders
WHERE order_date < DATEADD(YEAR, -2, GETDATE());

-- 3. 删除原表数据
DELETE FROM orders
WHERE order_date < DATEADD(YEAR, -2, GETDATE());

-- 4. 分区表自动归档
CREATE PARTITION FUNCTION pf_orders (DATE)
AS RANGE RIGHT FOR VALUES ('2023-01-01', '2024-01-01');
```

**32. 什么是临时表？类型有哪些？**

```
临时表：会话期间存在的临时存储
类型：
1. 局部临时表 (#table)：仅当前会话可见
2. 全局临时表 (##table)：所有会话可见
3. 表变量 (@table)：内存中的临时对象
选择依据：数据量、作用域、性能需求
```

**33. 如何处理数据库中的敏感数据？**

```sql
-- 1. 加密存储
CREATE SYMMETRIC KEY MyKey
WITH ALGORITHM = AES_256
ENCRYPTION BY PASSWORD = 'strong_password';

-- 2. 动态数据脱敏
CREATE MASKING POLICY email_mask AS (email VARCHAR(100))
RETURNS VARCHAR(100) WITH MASKING FUNCTION partial(email, 1, 'xxx@xx.com');

-- 3. 行级安全
CREATE SECURITY POLICY EmployeeSecurityPolicy
ADD FILTER PREDICATE dbo.fn_securitypredicate(employee_id) ON dbo.employees;
```

**34. 如何监控和优化数据库性能？**

```
监控工具：
- SQL Server Profiler
- MySQL慢查询日志
- Oracle AWR报告

优化方法：
1. 识别慢查询
2. 分析执行计划
3. 添加缺失索引
4. 优化查询写法
5. 调整数据库参数
6. 定期维护统计信息
```

**35. 数据库备份和恢复策略**

```
备份类型：
- 完整备份
- 差异备份
- 事务日志备份

恢复模型：
- 简单恢复模式
- 完整恢复模式
- 大容量日志恢复模式

策略示例：
每天完整备份 + 每小时事务日志备份
```

### 高级题目（5 题）

**36. 什么是 SQL 注入？如何防止？**

```
SQL注入：攻击者通过输入恶意SQL代码
防止方法：
1. 使用参数化查询
2. 使用存储过程
3. 验证和清理输入
4. 最小权限原则
5. 使用ORM框架
6. 定期安全审计
```

**37. 分布式数据库事务如何处理？**

```
解决方案：
1. 两阶段提交（2PC）
   - 准备阶段
   - 提交阶段
2. 三阶段提交（3PC）
3. 基于消息的最终一致性
4. Saga模式
5. TCC模式（Try-Confirm-Cancel）
```

**38. 数据库读写分离和高可用架构**

```
读写分离：
- 主库处理写操作
- 从库处理读操作
- 使用代理中间件

高可用方案：
1. 主从复制
2. 主主复制
3. 集群（如SQL Server Always On, MySQL InnoDB Cluster）
4. 数据库镜像
```

**39. 大数据量表的优化策略**

```
1. 分区表
2. 分库分表
3. 归档历史数据
4. 使用列存储索引
5. 物化视图
6. 查询结果缓存
7. 使用NoSQL辅助存储
```

**40. 数据库迁移和版本控制**

```
迁移工具：
- Flyway
- Liquibase
- Entity Framework Migrations

最佳实践：
1. 每次变更一个脚本
2. 可逆的迁移
3. 测试环境验证
4. 备份后执行
5. 监控迁移过程
```

## 三、数据库设计和建模（10 题）

### 中级题目（6 题）

**41. 数据库设计的主要步骤是什么？**

```
1. 需求分析
2. 概念设计（ER图）
3. 逻辑设计（关系模型）
4. 物理设计（表结构、索引）
5. 实施和测试
6. 维护和优化
```

**42. 如何设计扩展性好的数据库？**

```
1. 规范化和反平衡
2. 预留扩展字段
3. 使用代码表
4. 避免过度设计
5. 考虑未来业务变化
6. 设计可拆分的表结构
```

**43. 什么是星型模式和雪花模式？**

```
星型模式：
- 事实表 + 维度表
- 维度表直接连接事实表
- 查询简单，性能好

雪花模式：
- 维度表进一步规范化
- 减少冗余
- 查询复杂，维护困难
```

**44. 如何设计多语言支持的数据库？**

```
方案1：多列方案
   product_name_en, product_name_zh, ...

方案2：多行方案
   Locale表 + 翻译表

方案3：XML/JSON字段
   product_name: {"en": "name", "zh": "名称"}

选择依据：语言数量、查询需求、维护成本
```

**45. 时区和国际化处理**

```sql
-- 存储UTC时间
CREATE TABLE orders (
    id INT PRIMARY KEY,
    order_date_utc DATETIME,
    timezone VARCHAR(50)
);

-- 使用时区转换
SELECT
    order_date_utc AT TIME ZONE 'UTC' AT TIME ZONE timezone as local_time
FROM orders;

-- 统一存储格式
ALTER TABLE users ADD locale VARCHAR(10) DEFAULT 'zh-CN';
ALTER TABLE users ADD currency CHAR(3) DEFAULT 'CNY';
```

**46. 审计跟踪设计模式**

```sql
-- 方法1：添加审计字段
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    created_by INT,
    created_at DATETIME,
    updated_by INT,
    updated_at DATETIME,
    is_deleted BIT DEFAULT 0
);

-- 方法2：单独审计表
CREATE TABLE audit_log (
    id INT IDENTITY PRIMARY KEY,
    table_name VARCHAR(100),
    record_id INT,
    action VARCHAR(10),
    old_data NVARCHAR(MAX),
    new_data NVARCHAR(MAX),
    user_id INT,
    action_time DATETIME
);
```

### 高级题目（4 题）

**47. 如何设计支持软删除的系统？**

```sql
-- 1. 添加删除标记
ALTER TABLE table_name ADD is_deleted BIT DEFAULT 0;
ALTER TABLE table_name ADD deleted_at DATETIME;
ALTER TABLE table_name ADD deleted_by INT;

-- 2. 创建视图排除已删除数据
CREATE VIEW active_records AS
SELECT * FROM table_name WHERE is_deleted = 0;

-- 3. 使用INSTEAD OF触发器
CREATE TRIGGER trg_instead_of_delete
ON table_name
INSTEAD OF DELETE
AS
BEGIN
    UPDATE table_name
    SET is_deleted = 1,
        deleted_at = GETDATE(),
        deleted_by = CURRENT_USER
    WHERE id IN (SELECT id FROM deleted);
END;
```

**48. 数据版本控制设计**

```sql
-- 方法1：有效时间版本
CREATE TABLE products_history (
    id INT,
    name VARCHAR(100),
    price DECIMAL(10,2),
    valid_from DATETIME,
    valid_to DATETIME,
    is_current BIT
);

-- 方法2：全量快照
CREATE TABLE document_versions (
    document_id INT,
    version INT,
    content NVARCHAR(MAX),
    created_at DATETIME,
    created_by INT,
    PRIMARY KEY (document_id, version)
);

-- 查询当前版本
SELECT * FROM products_history
WHERE is_current = 1;
```

**49. 如何实现数据库的缓存策略？**

```
多层缓存策略：
1. 应用层缓存（Redis, Memcached）
2. 数据库查询缓存
3. 结果集缓存
4. 物化视图

缓存失效策略：
- 定时刷新
- 事件驱动刷新
- 手动刷新
- 基于版本号刷新
```

**50. 数据一致性保障方案**

```
强一致性方案：
1. 数据库事务
2. 分布式锁
3. 两阶段提交

最终一致性方案：
1. 消息队列
2. 事件溯源
3. 补偿事务
4. 异步处理
```

## 四、实际场景和问题解决（10 题）

### 综合题目（10 题）

**51. 如何查找并修复数据不一致问题？**

```sql
-- 1. 查找重复数据
SELECT column1, column2, COUNT(*)
FROM table_name
GROUP BY column1, column2
HAVING COUNT(*) > 1;

-- 2. 查找缺失的外键
SELECT *
FROM child_table c
WHERE NOT EXISTS (
    SELECT 1 FROM parent_table p
    WHERE p.id = c.parent_id
);

-- 3. 数据差异比较
SELECT * FROM table1
EXCEPT
SELECT * FROM table2;

-- 修复策略：
-- 1. 确定数据源
-- 2. 创建修复脚本
-- 3. 备份数据
-- 4. 执行修复
-- 5. 验证结果
```

**52. 数据库性能突然下降，如何排查？**

```
排查步骤：
1. 监控当前活动连接和查询
2. 检查锁和阻塞
3. 分析慢查询日志
4. 检查系统资源（CPU、内存、磁盘）
5. 查看数据库参数配置
6. 检查索引碎片
7. 分析执行计划变化
常见原因：缺少索引、统计信息过期、锁竞争、硬件问题
```

**53. 如何设计一个电商数据库？**

```sql
-- 核心表结构
CREATE TABLE users (
    id INT PRIMARY KEY IDENTITY,
    email VARCHAR(100) UNIQUE,
    password_hash VARCHAR(255),
    created_at DATETIME
);

CREATE TABLE products (
    id INT PRIMARY KEY IDENTITY,
    name VARCHAR(200),
    description TEXT,
    price DECIMAL(10,2),
    stock_quantity INT,
    category_id INT
);

CREATE TABLE orders (
    id INT PRIMARY KEY IDENTITY,
    user_id INT,
    status VARCHAR(20),
    total_amount DECIMAL(10,2),
    created_at DATETIME,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE order_items (
    id INT PRIMARY KEY IDENTITY,
    order_id INT,
    product_id INT,
    quantity INT,
    price DECIMAL(10,2),
    FOREIGN KEY (order_id) REFERENCES orders(id),
    FOREIGN KEY (product_id) REFERENCES products(id)
);
```

**54. 如何实现数据导入导出？**

```sql
-- SQL Server导入导出
-- 导出
EXEC xp_cmdshell 'bcp "SELECT * FROM database..table" queryout "C:\data.csv" -c -t, -T -S servername'

-- 导入
BULK INSERT table_name
FROM 'C:\data.csv'
WITH (
    FIELDTERMINATOR = ',',
    ROWTERMINATOR = '\n',
    FIRSTROW = 2
);

-- MySQL导入导出
-- 导出
SELECT * INTO OUTFILE '/tmp/data.csv'
FIELDS TERMINATED BY ','
ENCLOSED BY '"'
LINES TERMINATED BY '\n'
FROM table_name;

-- 导入
LOAD DATA INFILE '/tmp/data.csv'
INTO TABLE table_name
FIELDS TERMINATED BY ','
ENCLOSED BY '"'
LINES TERMINATED BY '\n';
```

**55. 如何处理大数据量的统计报表？**

```
解决方案：
1. 预计算和物化视图
2. 定时任务离线计算
3. 使用OLAP数据库
4. 数据仓库技术
5. 分时段统计
6. 采样统计
7. 使用列存储
```

**56. 数据库安全最佳实践**

```
1. 最小权限原则
2. 定期审计和监控
3. 数据加密（传输和存储）
4. SQL注入防护
5. 定期更新和打补丁
6. 备份加密
7. 访问控制列表
8. 敏感数据脱敏
```

**57. 如何设计支持多租户的数据库？**

```
方案1：独立数据库（高隔离性）
方案2：共享数据库，独立架构（中等隔离）
方案3：共享数据库，共享架构（低隔离）

设计要点：
1. 租户标识字段
2. 数据隔离策略
3. 性能隔离
4. 备份恢复策略
5. 扩展性设计
```

**58. 数据库容量规划和监控**

```
监控指标：
1. 存储空间使用率
2. 连接数
3. 查询响应时间
4. 锁等待时间
5. 缓存命中率

容量规划：
1. 数据增长率预测
2. 性能基准测试
3. 硬件升级计划
4. 数据归档策略
5. 分库分表规划
```

**59. 灾难恢复计划制定**

```
RTO（恢复时间目标）：业务中断可接受时间
RPO（恢复点目标）：数据丢失可接受量

恢复策略：
1. 热备份站点
2. 温备份站点
3. 冷备份站点

测试计划：
1. 定期恢复测试
2. 灾难演练
3. 文档更新
```

**60. 数据库选型考虑因素**

```
技术因素：
1. 数据类型和功能需求
2. 性能和扩展性
3. 高可用性要求
4. 安全特性
5. 生态系统和工具

非技术因素：
1. 成本（许可、维护、硬件）
2. 团队技能
3. 社区支持
4. 供应商支持
5. 云服务兼容性
```

---

这些题目涵盖了数据库和 SQL 的各个方面，从基础概念到高级应用，从理论到实践，可以帮助全面评估候选人的数据库知识和技能。题目按难度分级，可以根据职位要求选择合适的题目进行面试。
